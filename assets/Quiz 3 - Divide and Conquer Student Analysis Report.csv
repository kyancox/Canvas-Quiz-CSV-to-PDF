Name,ID,SISID,SectionIDs,SectionNames,SectionSISIDs,Submitted,ElapsedTime,Attempt,ItemID,ItemType,"1. SuperReverse(A) { // nonsensically scrambles A2.    // base case3.    if (length(A) == 1) return;4.    else { // work and recursive calls5.       SuperReverse(first half of A)6.       for (i = 0,1,...,length(A)-1) {7.          A[i] = A[length(A)-i-1]8.       }9.       SuperReverse(second half of A)10.       for (i = 0,1,...,length(A)-1) {11.          A[i] = A[length(A)-i-1]12.       }13.       SuperReverse(first half of A)14.    }15. }",EarnedPoints,Status,ItemID,ItemType,"1. SuperFindMax(A) { \\ Find the maximum of array A recursively2.    // base cases3.    if (length(A) == 1) return A;4.    if (length(A) == 2){5.       compare these two elements5.       return the greater element}4.    else { // recursive calls5.       a_1 = SuperFindMax the first two thirds of A;6.       a_2 = SuperFindMax the second two thirds of A;7.       a = max{a_1, a_2};8.       return a;9.       }10. }",EarnedPoints,Status,ItemID,ItemType,1. Shuffle(A) { \\ shuffles array A recursively2.    // base cases3.    if (length(A) == 1) return;4.    else { // work and recursive calls5.       Find max element in A (by scanning each element of A)6.       Swap the max element with the second element of A7.       Shuffle the first half of A8.       Shuffle the third quarter of A9.       Shuffle the fourth quarter of A10.    }11. },EarnedPoints,Status,ItemID,ItemType,1. Shuffle(A) { \\ shuffles array A recursively2.    // base cases3.    if (length(A) == 1) return;4.    else { // work and recursive calls5.       Find minimum element in A (by scanning each element of A)6.       Swap the minimum element with the second element of A7.       Shuffle the second half of A8.       Shuffle the first quarter of A9.       Shuffle the second quarter of A10.    }11. },EarnedPoints,Status,ItemID,ItemType,"1. SuperMax(A) { \\ finds the max element in array A recursively2.    // base cases3.    if (length(A) == 1) return A[0];4.    if (length(A) == 2) {6.       return max(A[0], A[1]);7.    } else { // recursive calls8.       a = -Inf;9.       for j in first one-third of A:10.          a = max(a, A[j]);11.       b = SuperMax(the second one-third of A);12.       c = SuperMax(the third one-third of A);13.       return max(a, b, c);14.    }15. }",EarnedPoints,Status,ItemID,ItemType,1. Algorithm(array A) {2.    print(A[0]);3.    // base case4.    if length(A) < 3:5.       return;6.    else { // recursive calls7.       Algorithm( the first two-thirds of A );8.       Algorithm( the last two-thirds of A );9.    }10. },EarnedPoints,Status,ItemID,ItemType,1. Shuffle(A) { \\ shuffles the elements of A2.    // base case3.    if (length(A) < 5) return;4.    else { // work and recursive calls5.       Swap the first and last elements of A;6.       Shuffle the first fifth (1/5) of A;7.       Shuffle the first 4 fifths of A;8.       Shuffle the last 3 fifths of A;9.    }10. },EarnedPoints,Status,ItemID,ItemType,1. SuperSort(A) { \\ sorts array A recursively2.    // base cases3.    if (length(A) == 1) return;4.    if (length(A) == 2) {5.       swap the two elements if they’re out of order;6.       return;7.    } else { // recursive calls8.       SuperSort the first two thirds of A;9.       SuperSort the second two thirds of A;10.      SuperSort the first two thirds of A again;11.    }12. },EarnedPoints,Status,ItemID,ItemType,"1. FancyMin(A) { \\ find the minimum element in A recursively2.    // base cases3.    if (length(A) == 1) return A[0];4.    if (length(A) == 2) {5.       return min(A[0], A[1]);6.    } else { // recursive calls7.       a1 = FancyMin(first one third of A);8.       a2 = FancyMin(last one third of A);8.       a3 = +Inf;9.       for i in middle one third of A:10.          a3 = min(a3, A[i]);11.      return min(a1, a2, a3);12.    }13. }",EarnedPoints,Status,ItemID,ItemType,"
1. crazySwap(A) {2.    // base case3.    if (length(A) < 5){4.       return;5.    } else { // recursive calls6.       Swap the first of A with the last element of A7.       crazySwap(the first fifth of A);8.       crazySwap(the third fifth of A);9.       crazySwap(the fourth fifth of A);10.      return;11.    }12. }
",EarnedPoints,Status,ItemID,ItemType,"
1. WeirdSubsetSum(A) {2.    // base case3.    if (length(A) < 4){4.       return 0;5.    } else if (length(A) == 4){6.       return A[0] + A[1] + A[3];7.    } else { // recursive calls8.       sum1 = WeirdSubsetSum( the first quarter of A);9.       sum2 = WeirdSubsetSum( the second quarter of A);10.      sum3 = last element of A;11.      return sum1+sum2+sum3;12.    }13. }
",EarnedPoints,Status,ItemID,ItemType,"
You have a time-critical routine that needs to run in under 1 second. The routine will run on a server with n available cores, but doesn’t have to use all n cores. You know the routine runs in under 1 second on all n cores, but you want to determine the minimum number of cores to request such that the routine still runs in under 1 second. The routine always runs faster when given more cores, but you don’t know how much faster.
An brute force algorithm is described below.

The brute force algorithm requires O(n) experiments.
In Part A, you will design a divide and conquer algorithm to find the smallest number i such that the routine runs in under 1 second on i cores.Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.
",EarnedPoints,Status,ItemID,ItemType,"
Part B: Give a recurrence relation upper bound, tight up to constant factors, for the performance of your algorithm given in Part A. Don't forget the base case(s).",EarnedPoints,Status,ItemID,ItemType,"
Part C: Solve your recurrence relation given in Part B by providing an asymptotic solution tight up to constant factors, but do NOT use the master theorem or the master-master theorem/nuclear bomb. Show your work. ",EarnedPoints,Status,ItemID,ItemType,"A straightforward approach to compute  for  is described below.

In Part A, you will design a divide and conquer algorithm to compute  that uses fewer multiplications than the provided algorithm. Hint: watch out for the parity of the parameter.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"You are given a size  array  which is sorted in increasing order and has unique elements. You are also given a number . You must find the largest number  such that  is in  and . If no such number exists in  (meaning all elements of  are ) then return ""None"".
For example, if  and , you should return . An ""obvious"" algorithm to do this is given below:

In Part A, you will design a divide and conquer algorithm to find the largest number  such that  and  which has a smaller asymptotic runtime than the above algorithm.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"A straightforward approach to compute  for  is described below.

In Part A, you will design a divide and conquer algorithm to compute  that uses fewer multiplications than the provided algorithm. Hint: watch out for the parity of the parameters.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"You are given a size  array  which is sorted in increasing order and has unique elements. You are also given a number . You must find the smallest number  such that  is in  and . If no such number exists in  (meaning all elements of  are ) then return ""None"".
For example, if  and , you should return . An ""obvious"" algorithm to do this is given below:

In Part A, you will design a divide and conquer algorithm to find the smallest number  such that  and  which has a smaller asymptotic runtime than the above algorithm.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"The CS 577 final is worth n points. Given your current grade, you would like to determine the minimum number of points you need to get an A. However, exam scores are aggregated by an opaque and convoluted formula, so the only way you can determine whether a score is sufficient for an A is to enter the score as a hypothetical in Canvas and check whether, with that score, you have an A.
A brute force algorithm is described below.

In Part A, you will design a divide and conquer algorithm to find the minimum number of points i that you need to get an A. Your algorithm should make asymptotically fewer score checks than the brute force algorithm.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"You are a cell tower operator. The range of the tower you operate, which you are able to change as needed, is , where  is the tower's maximum range. Anyone within distance  of the tower, so at any distance  will get signal.
Your friend that lives nearby the tower has been complaining that they don't get signal. You don't know how far they live, but you know the distance between their residence and your tower is an integer  and is . For a range you set, you can ask your friend whether they are getting a signal. We call this function GetsService(), where  is the range you set. This function returns True if your friend gets signal and False otherwise. 
The tower's electricity costs increase as range increases, so you want to find the smallest range for your tower such that your friend receives a cell signal. 
A brute force algorithm is described below.

The brute force algorithm requires  time to find the smallest range that serves your friend.
In Part A, you will design a divide and conquer algorithm to find this range with smaller asymptotic runtime than the above algorithm.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"You are given an array  with no two elements equal, which is the concatenation of two nonempty arrays  and . You know that  is already sorted in  order, and  is already sorted in  order. In addition, you know that the last element of  is less than the first element of . You must design an algorithm to find, and return, the total number of elements in .
A brute force algorithm is described below.

The brute force algorithm requires  time to find the length of .
In Part A, you will design a divide and conquer algorithm to find this length with smaller asymptotic runtime than the above algorithm.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"Suppose you are given positive integers  where   for nonnegative integer . You would like to determine  using only the elementary operations of addition, subtraction, multiplication, and division.
A brute force algorithm is described below.

The brute force algorithm requires  time to find the correct value of . To help with this task, your friend designed a function called  which takes input  of the form  and computes  in  time. In Part A, you will use  to design a divide and conquer algorithm to find the correct value of  with smaller asymptotic runtime than the above brute force algorithm. Hint: , so  such that  if  is even or  if  is odd.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,ItemID,ItemType,"You are given a perfect square  such that . A straightforward approach to compute  is described below.

In Part A, you will design a divide and conquer algorithm to compute  that uses fewer multiplications than the provided algorithm.
Part A: Design a divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm.",EarnedPoints,Status,NumberOfCorrect,NumberOfIncorrect,NoResponse,PointsPossible,OverallScore
Raghad Abujabal,385605,UW108U211,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:45:00 UTC,00:36:01,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>so if length a = 1, we will return, if it's 2, we will swap elements(base), and then we will do 3 recursive calls on the first 2/3 of a, then 2nd, then 3rd.&nbsp; therefore, Our recursive solution would be T(n)=3T(2n/3)+O(n).&nbsp;</p>",1.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n)=T(k/2)+O(1)</p>,0.75,Graded,18157,essay,"<p>the solution would just be adding the constant factors,</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>base : if a =1, then k=0. our design is, If let's say that we have a variable n and n = sqrta so the means that n = b^k/2.&nbsp; we want to decide if k is even or odd, if it's even then n would be (b^k/2) so that makes n^2 then k= 2(k/2) then if it's odd then a = b multiplied by b*(b^k/2)^2 and that would make k= 2(k/2)+1. then the runtime would be O(log k)</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,1,0,9.0,3.25
PARTH ADITYA,513762,UW117O083,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:45:00 UTC,00:23:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>First 1/2 then n/4 and then again n/4, thus T(n) = T(n/2) + 2T(n/4). So Final solution to this would be T(n) = T(n/2) + 2T(n/4) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(n) for n &gt; 1 and base case is <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) when n = 1</p>
<p>&nbsp;</p>
<p>Thus T(n) = Big Theta (nlog n)</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>As stated in part a we devide the array in 2 halves each time and so we get n/2 array each time we do recursive call, thus T(n/2) complexity. Also there is there is the comparsiobn aspect which is some constanrt c&nbsp; complexity.</p>
<p>&nbsp;</p>
<p>Hence T(n) = T(n/2) + c . and our base case is T(1)= d where both our c, d are constants and both greaterthan 0&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c = T(n/4) + 2c + T(n/8 ) + 3c = .... = T(n/2^k) + kc. The recusion will stop when n/2^k - 1 which implies k = log base2 (n). Thus T(n) = T(1) + clog base2 (n).</p>
<p>&nbsp;</p>
<p>We know T(1) = d from part b. Thus T(n) = d + c log base2 (n) =&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>BS works best here.&nbsp;</p>
<p>low = 1 and high = n-1</p>
<p>while low &lt;= high :&nbsp;</p>
<p>&nbsp; &nbsp; mid = (low + high) /2</p>
<p>if A[mid] &lt; A [mid +1} then low = mid +1&nbsp;</p>
<p>else high = mid -1</p>
<p>&nbsp;</p>
<p>Return low</p>
<p>&nbsp;</p>
<p>The T(n) = T(n/2) + big theta(1) thus T(n) = big theta (n log n)</p>
<p>&nbsp;</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Arsalan Ahmad,507816,UW099V254,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:22:05 UTC,00:18:26,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n) = 3T(n/5)</p>,1.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1)</p>,0.75,Graded,18157,essay,"<p>Using the tree</p>
<p>T(n) = T(n/2) + O(1)</p>
<p>T(n) = T(n/2) + c</p>
<p>T(n) = T(n/4) + 2c</p>
<p>T(n) = T(n/2^k) + kc<br><br></p>
<p>Base case is when n/2^k = 1<br>which means that k = log n<br>so the asymptotic solution is&nbsp;<br>T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Divide and Conquer starting using mid point</p>
<p>Input: A[1...N]</p>
<p>begin</p>
<p>&nbsp;low = 1</p>
<p>high = n</p>
<p>while low &lt; high</p>
<p>mid = (low + high) /2</p>
<p>if A[mid} &lt; A [mid+1}</p>
<p>low = mid + 1</p>
<p>else high = mid</p>
<p>return low</p>
<p>&nbsp;</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.25
Jason Antonellis,421617,UW930N478,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 17:51:32 UTC,00:13:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(n)=3T(2n/3)+O(1) for n&gt;2</p>
<p>base cases:</p>
<p>T(1)=T(2)=O(1)</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Binary Search Algorithm:</p>
<p>left = 1, right = n, result = n,</p>
<p>while left &lt; right:</p>
<p>&nbsp; &nbsp; mid = (left+right) / 2</p>
<p>&nbsp; &nbsp; if routine runs in under 1 second on mid cores:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = mid</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right = mid - 1</p>
<p>else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; left = mid + 1</p>
<p>return result</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + O(1) for n&gt;1</p>
<p>base case(s):</p>
<p>T(1) = O(1)</p>",1.0,Graded,18157,essay,"<p>Level 0: T(n) -&gt; cost = c</p>
<p>Level 1: T(n/2) -&gt; cost = c</p>
<p>Level 2: T(n/4) -&gt; cost = c</p>
<p>Level 3: T(n/8) -&gt; cost = c</p>
<p>....</p>
<p>Level k: Where T(n/2^k) -&gt; cost c</p>
<p>The tree has deth k where n/2^k = 1, so k = log(n)</p>
<p>&nbsp;</p>
<p>Total Cost = c * (log*n) + 1) = c*log(n) + c</p>
<p>Therefore T(n) = O(logn)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Jaxson Banser,480082,UW096Y020,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 02:37:55 UTC,00:26:03,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n) = 3T(n/5) + c; n &lt; 5 | T(n) = 1</p>,3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c; T(1) = 1</p>,1.0,Graded,18157,essay,"<p>T(n) = (T(n/4) + c) + c = ((T(n/8) + c) + c ) + c. Stops at, <img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check=""""> = 1 --&gt; <img class=""equation_image"" title=""\log_2n=k"" src=""/equation_images/%255Clog_2n%253Dk?scale=1"" alt=""LaTeX: \log_2n=k"" data-equation-content=""\log_2n=k"" data-ignore-a11y-check="""">. Each level has constant work. Thus, <img class=""equation_image"" title=""\sum_{k=0}^{\log_2n}c"" src=""/equation_images/%255Csum_%257Bk%253D0%257D%255E%257B%255Clog_2n%257Dc?scale=1"" alt=""LaTeX: \sum_{k=0}^{\log_2n}c"" data-equation-content=""\sum_{k=0}^{\log_2n}c"" data-ignore-a11y-check=""""> = c<img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""> = O(<img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check="""">)&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Starting with an array of ints from 0 --&gt; x</p>
<p>r := x/2</p>
<p>if (r*r &gt; x)</p>
<p>&nbsp; &nbsp;recurse on the left half of the array of ints&nbsp;</p>
<p>else if (r*r &lt; x)&nbsp;</p>
<p>&nbsp; &nbsp;recurse on the right half of array of ints&nbsp;</p>
<p>else</p>
<p>&nbsp; &nbsp;return r</p>",3.0,Graded,0,0,0,9.0,9.0
Shawn Batnagar,485717,UW976U458,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 18:32:46 UTC,00:28:44,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>Base case when T(k) when k&lt;=2, is (1)(e.g does constant work)</p>
<p>T(n)=3T(2n/3) +C</p>
<p>Logic behind this is 3 calls to the recursive method hence 3T along with each call having size 2/3 of the total input hence the 2n/3. Assuming swaps can be done in constant time each call does O(1) or constant work</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Algorithim: routineRun()</p>
<p>Low=0</p>
<p>High=N</p>
<p>when low&gt;high and Low cores can run under 1 second:</p>
<p>return Low</p>
<p>Mid=(low+high)/2</p>
<p>if mid cores can run in under 1 second:</p>
<p>routineRun(low,mid)</p>
<p>else:</p>
<p>routineRun(mid+1,high)</p>
<p>&nbsp;</p>",3.0,Graded,18156,essay,"<p>T(1)=1</p>
<p>T(n)=T(n/2) +c</p>",1.0,Graded,18157,essay,"<p>&nbsp;</p>
<p>Each recursion call does constant amount of work ie C on each level. Each level also sums to a total&nbsp; of n/(2^k). At the last level we get n/(2^k)=1 which gets to a point where k=log2(n) +C which translates to O(logn).</p>
<p>&nbsp;</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Siri Chandra,484742,UW976M402,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-16 23:34:01 UTC,00:29:14,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 2(n/3) + O(n), with a base case of T(n) = O(1), if n=1 or 2.&nbsp;</p>",2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = 2T(k/2) + O(k), and T(1) = O(1).&nbsp;</p>",0.0,Graded,18157,essay,"<p>T(k) = 2T(k/2) + k<br>= 2[2T(k/4) + k/2] + k = 4T(k/4) + 2k<br>= 4[2T(k/8) + k/4] + 2k = 8T(k/8) + 3k&nbsp;<br>...<br>at ith level, the recurrence is 2^i * T(k/2^i) + i * k.&nbsp;<br>We stop when k/2^i = 1, which is k=2^i. i = log base 2 of k, so we know that when k/2^i is 1:&nbsp;<br>2^(log base 2 of k) * O(1) + k * (log base 2 of k) = some constant * k * (log base 2 of k), so we get that T(k) = O(klogk).&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>We start with a base case of k = 1: when k = 1, a is equal to b and thus we would know that the exponent of b must be 1.&nbsp;<br>Take isqrt(a) which gives you some number f = b^floor(k/2).</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
AFIF BIN MOHD HISHAMUDDIN,500392,UW103G424,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 04:36:59 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>T(n) = O(1) if n = 1 (Base case)</p>
<p><img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n.}{2}\right)+2T\left(\frac{n}{4}\right)+O\left(n\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn.%257D%257B2%257D%255Cright)%252B2T%255Cleft(%255Cfrac%257Bn%257D%257B4%257D%255Cright)%252BO%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n.}{2}\right)+2T\left(\frac{n}{4}\right)+O\left(n\right)"" data-equation-content=""T\left(n\right)=T\left(\frac{n.}{2}\right)+2T\left(\frac{n}{4}\right)+O\left(n\right)"" data-ignore-a11y-check=""""></p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2}\right)+c"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252Bc?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2}\right)+c"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2}\right)+c"" data-ignore-a11y-check=""""> for <img class=""equation_image"" title=""n>1"" src=""/equation_images/n%253E1?scale=1"" alt=""LaTeX: n>1"" data-equation-content=""n>1"" data-ignore-a11y-check=""""></p>
<p>Base case <img class=""equation_image"" title=""n\le1"" src=""/equation_images/n%255Cle1?scale=1"" alt=""LaTeX: n\le1"" data-equation-content=""n\le1"" data-ignore-a11y-check="""">, T(n) = c. Algo stops after constant amount of work</p>",1.0,Graded,18157,essay,"<p>We can use unrolling method</p>
<p>T(n) = T(n/2) + c</p>
<p>T(n) = [T(n/4) + c)&nbsp; + c = T(n/4) + 2c</p>
<p>T(n) = [T(n/8) +c] + 2c&nbsp; = T(n/8) +3c</p>
<p>After k iteration we can see that</p>
<p>T(n) = T(n/<img class=""equation_image"" title=""2^k"" src=""/equation_images/2%255Ek?scale=1"" alt=""LaTeX: 2^k"" data-equation-content=""2^k"" data-ignore-a11y-check="""">) + <img class=""equation_image"" title=""k\cdot c"" src=""/equation_images/k%255Ccdot%2520c?scale=1"" alt=""LaTeX: k\cdot c"" data-equation-content=""k\cdot c"" data-ignore-a11y-check=""""></p>
<p>Recursion stops when n/<img class=""equation_image"" title=""2^k"" src=""/equation_images/2%255Ek?scale=1"" alt=""LaTeX: 2^k"" data-equation-content=""2^k"" data-ignore-a11y-check=""""> = 1</p>
<p>solve for k, n = <img class=""equation_image"" title=""2^k"" src=""/equation_images/2%255Ek?scale=1"" alt=""LaTeX: 2^k"" data-equation-content=""2^k"" data-ignore-a11y-check="""">, k = <img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""></p>
<p>Substitute back,&nbsp;</p>
<p>T(n) = T(1) + <img class=""equation_image"" title=""(\log_2n)\cdot c"" src=""/equation_images/(%255Clog_2n)%255Ccdot%2520c?scale=1"" alt=""LaTeX: (\log_2n)\cdot c"" data-equation-content=""(\log_2n)\cdot c"" data-ignore-a11y-check=""""></p>
<p>since T(1) is just constant we have</p>
<p>T(n) = c+<img class=""equation_image"" title=""c\cdot\log_2n"" src=""/equation_images/c%255Ccdot%255Clog_2n?scale=1"" alt=""LaTeX: c\cdot\log_2n"" data-equation-content=""c\cdot\log_2n"" data-ignore-a11y-check=""""></p>
<p>In asymptotic notation:</p>
<p>T(n) = <img class=""equation_image"" title=""O\left(\log n\right)"" src=""/equation_images/O%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: O\left(\log n\right)"" data-equation-content=""O\left(\log n\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Divide:</p>
<p>compute middle index, mid = (low +high)/2</p>
<p>Conquer:<br>Compare the middle element with the first element of A</p>
<p>If the middle element is greater A[mid+1], and A[mid] &gt; A[mid-1] return mid</p>
<p>If&nbsp; A[mid] &lt; A[mid +1] recurse on [mid +1, high]</p>
<p>Else, we are in decreasing region A[mid] &gt; A[mid +1], peak is on the left</p>
<p>O log(n)</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Ryan Bradley,578740,UW107K646,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:37:58 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) &lt;= 3T(n/3) + cn</p>,1.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n/2) + cn</p>,0.0,Graded,18157,essay,"<p>Unroll:</p>
<p>1: n&nbsp;</p>
<p>2: n/2</p>
<p>3: n/4</p>
<p>etc etc. and since the tree only branches into one child per level, the total work for each level is equal to that value.&nbsp;</p>
<p>To solve the recurrence we sum the general term n/2^j, where j is the level from 0 to the height, which is log2(n). Summing the term n/2^j converges toward 1, so we clearly see that the recurrence brings us to a big O of O(log n).</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>sqrt(x, r): where r is originally x/2</p>
<p>if x == 0:</p>
<p>&nbsp; &nbsp; return 0</p>
<p>if x == 1:</p>
<p>&nbsp; return 1</p>
<p>if r * r == x:</p>
<p>&nbsp; return r</p>
<p>elseif r*r &gt; x</p>
<p>&nbsp; return sqrt(x, midpoint of 0 to r)</p>
<p>else</p>
<p>&nbsp; return sqrt(x, midpoint r to x)</p>
<p>&nbsp;</p>",2.5,Graded,0,0,0,9.0,3.5
Chenning Cai,506058,UW999V717,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:29:29 UTC,00:26:15,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>T(n) = T(n/2) + 2T(n/4) + O(n), T(1) = 1;</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + 1, T(1) = 1</p>",1.0,Graded,18157,essay,"<p>Consider the recurrence tree of this relation.&nbsp;</p>
<p>At the root of the tree, the level cost is 1;</p>
<p>At the second level of the tree, we have one node with cost 1, so total level cost is 1;</p>
<p>At the third leve of the tree, we have one node (T(n/4)) with cost 1, so total level cost also 1;</p>
<p>We notice the level cost for all level of the tree is 1. And as the size of n is decreasing by halves, we know the depth of the tree L satisfies that</p>
<p>L = log2(n);</p>
<p>So the total cost of this tree is T(n) = L * 1 = log2(n) * 1 = O(log(n));</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Lets have a array A of all points that could be get from 1 to n, that is, we have A[k] == k for all k belongs [1, 2, ...n]</p>
<p>Base case: if A.length == 1, return the one element array;</p>
<p>Divide: divides A into left half and right half with size of n/2;</p>
<p>Conquer: if the largest element(the end element of the array) in left half of A is not sufficient for getting an A, discard this half; return the right half;</p>
<p>else we discard the right half, return the left half;</p>
<p>Combine: Only one subarray of size 1 will be returned in the end, and the element in it is the least score for getting an A in 577. Return the element;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Ivan Carmona,507081,UW999D315,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 01:05:35 UTC,00:29:49,1,18054,essay,"<p>T(n) = 3T(n/2) + O(n) (3 recursive calls of size n/2 each with a loop (O(n) time) complexity per call)</p>
<p>T(1) = 1; (From return statement)</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Divide-and-Conquer (n, i = 1) (i is 1 on first call (default arg))</p>
<p>begin</p>
<p>&nbsp; if (n - i &lt;= 2) then</p>
<p>&nbsp; &nbsp; return i;</p>
<p>&nbsp; end-if</p>
<p>&nbsp; if (routine runs in over 1 second on n/2 cores) then</p>
<p>&nbsp; &nbsp; Divide-and-Conquer(floor(n/2), i)</p>
<p>&nbsp; else if (routine runs in under 1 second on n/2 cores)&nbsp;then</p>
<p>&nbsp; &nbsp; Divide-and-Conquer(n, i + floor(n/2))</p>
<p>&nbsp; end-if</p>
<p>end</p>",3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>T(1) = 1; (return statement)</p>",1.0,Graded,18157,essay,"<p>At level i, there is one subproblem of size n*(1/2)^i and the total cost at each level is O(1). The input will reach base case at 1, so the tree depth is logn. Thus, T(n) = logn + T(1) =&gt; T(n) = logn + 1.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,1,0,9.0,9.0
Max Cegielski,417908,UW876W675,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 19:36:06 UTC,00:29:28,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = T(n/2) + 2T(n/4) + cn&nbsp; &nbsp; &nbsp;T(1) = O(1)</p>,3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c&nbsp; &nbsp;T(1) = O(1)<br><br><br></p>,1.0,Graded,18157,essay,"<p>Using a recursion tree, it would be a straight line down with each level having a constant cost. So we have to find how many levels in the tree. the base case would hit when n/2^k = 1, solving this for k gives n = 2^k, k = log(n). there are logn levels each doing constant time work, so the overall running time is O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Algorithm: MinScore, Returns min score needed to get an A in the course<br>Input, i= score to start looking at, n = score to look to<br>Base Case: if i == n: return i if it gets you an A<br><br>Split n in half<br>if score n/2 good enough score: return MinScore( 1, n/2)<br>else: return MinScore(n/2 +1, n)<br><br></p>",2.5,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Grant Hohol,484477,UW977G421,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 17:51:07 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>B(n) = B(n/2) + B(n/4) + B(n/4) + cn and B(1) = 1</p>,3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Say we have a list of n cores labeled 1 to n. We will run a recursive algorithm in this list by divide and conquer. At each step, given a list of cores L, we split this list in half and recurse on each half. Say the length of L is n, then we recurse on L[0 to floor(n/2)] and L[ceil(n/2) to n]. The return value of this recursive call is simply a boolean denoting if the call found a set of i cores that run in 1 second or less. The base case for this recursion is just a list of 1 element. When we reach this base case, we check if the routine runs in under 1 second on this one element. If it does, we return true and break and set the best value to 1, and if it does not, we return false. The merge step of this algorithm is the most important part. Say we are looking to merge two lists A and B. Because A and B have been returned from a recursive call, we know that these two lists of cores each run in greater than 1 second. When we merge, we simply take each element from B, one by one, and add it A. After adding the element Bi to A, we check if this new list of cores A U Bi runs in under 1 second. If it does, we set the best value to the length of A U Bi, and break. If it does not, we continue adding the elements from B until B is empty. Once B is empty, we have merged A and B to create a new list, and we continue up the recursion.&nbsp;</p>",1.0,Graded,18156,essay,<p>B(n) = 2B(n/2) + 1 and B(1) = 1</p>,0.0,Graded,18157,essay,"<p>Using a recursion tree. We start with a value of n at the root node, which we will call level 0. The total work at this node is constant. In fact, the total work at any nodes is going to be constant. The root node has two children, each of whoms problem size is halved, so in this case is n/2. The total work at this level is equivalent to the number of nodes which is 2. Each of those children have two children, and their problem sizes are also halved to be n/4. The total work at this level is equivalent to the number of nodes which is 4. Therefore, we can see the pattern for total work. The total work done at any given level k is equal to 2^k. Now we must find how many levels there are. The tree terminates when the problem size is 1. The problem size of the nodes is halved at each level of the tree, so this means the problem size at level k is equivalent to n/2^k. Therefore the tree terminates when n/2^k = 1 -&gt; n=2^k -&gt; k = lg n. So, there are lg n levels to the tree. The total work done overall is equivalent to the work done per level * the number of levels. Therefore we have the summation from k = 0 to k = lg n of 2^k which we can see is asymptotically less than O(n) as it is O(log n).&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Andrew Chen,485893,UW978V608,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 20:15:31 UTC,00:21:44,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) = 2T(n/3) + n/3 for all n &gt; 2. The base case is T(n) = 1 for n &lt;=2.</p>,3.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + 1 with base case T(1) = 1</p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + 1</p>
<p>T(n) = T(n/2^2) + 2</p>
<p>T(n) = T(n/2^3) + 3</p>
<p>From this, the patttern that emerges is T(n) = T(n/2^k) + k. Since T(1) = 1, 1 = n/2^k, which gives us k = log_2 n. Plugging this back into our recurrence, we have T(n) = T(n/2^{log_2 n}) + log_2 n = T(n/n) + log_2 n = 1 + log_2 n, which is O(log n).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>We can implement a divide and conquer algorithm for this problem using binary search. We can set this up like this:<br>ALG(n):<br>closest = 0<br>max = n</p>
<p>while closest &lt; max do</p>
<p>r = (closest + max) /2</p>
<p>if GetsService(r) == True then max&nbsp; = r</p>
<p>else closest = r + 1</p>
<p>return closest</p>
<p>&nbsp;</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Leyan CHEN,500457,UW009Q107,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:45:00 UTC,00:15:47,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>the scan for max takes 0(n) time</p>
<p>there are three recursive calls on subarrays for size n/2, n/4, and n/4</p>
<p>so total recurrence:</p>
<p>T(n) =T(n/2) +2T(n/4)+O(n)</p>",2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>let T(k) be the running time when a =b^k</p>
<p>&nbsp;base case: T(1) = O(1)</p>
<p>at eachh step we call isqrt(a)&nbsp;</p>
<p>upper -bound is :</p>
<p>T(k) &lt;=T(uppper(k/2)) + e, T(1) = c_0</p>
<p>unrollling gives t(k) = O(logk )</p>",0.0,Graded,18157,essay,"<p>T(k) = t(k/2) + c</p>
<p>[4pt]=T(k/2^i)+ic</p>
<p>the base case occurs when k/2=1</p>
<p>T(k) = T(1)+clog2K</p>
<p>simplify: T(k) = O(logk)</p>
<p>whithout using the Master Theorem, the solution is T(k) = O(logk) for the asymptotic solution to the recurrence T(k) = T(k/2) + O(1)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>algo type: devide and conqure using isqrt(a)</p>
<p>recurrence: T(k) = T(k/2) +o(1)</p>
<p>base case: T(1)=O(1)</p>
<p>asymptotic runtime: O(logk), which is asymptotically faster then the brute force O(k)</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Angela Chung,517415,UW995W317,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:34:33 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(2n/3) + c</p>
<p>T(1) = 1; T(2) = 1</p>
<p>&nbsp;</p>
<p>The algorithm performs 2 recursions of size 2n/3 on each part of the array. Base cases checking length, returning A, and comparing the two values takes O(1) time and thus contribute that much to the recurrence relation.&nbsp;</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(1) = 1</p>
<p>&nbsp;</p>
<p>Algorithm performs recurrence steps of size n/2, and checking the length of A/returning/finding median is O(1)</p>",1.0,Graded,18157,essay,"<p>T(n/2) = T(n/4) + 2c<br>T(n/4) = T(n/8) + 3c</p>
<p>&nbsp;</p>
<p>Stop when n/2^k = 1</p>
<p>Summation from i = 1 to log_2(k) of (1/2)^k * n</p>
<p>Comes out to be Theta( logn )</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Input : Array a, number k<br>&nbsp; &nbsp; if size of A = 1<br>&nbsp; &nbsp; &nbsp; &nbsp; return A[i]<br>&nbsp; &nbsp; else<br>&nbsp; &nbsp; &nbsp; &nbsp; find median m of A<br>&nbsp; &nbsp; &nbsp; &nbsp; if m &lt; k<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recurse on right half of A (including median / 2 values that make up median if size of A is even)&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; if m &gt; k<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;recurse on left half of A (including median / 2 values that make up median if size of A is even)&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; if m = k<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return m<br><br></p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Sebastian Cui,516639,UW009C633,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-16 23:46:20 UTC,00:20:05,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>Base Cases:<br>T(1) = O(1)</p>
<p>Recurrence:<br>T(n) = 2T(n/3) + c*n</p>",2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base Case:<br>T(1) = O(1)</p>
<p>Recurrence:</p>
<p>T(x) = T(x/2) + O(1)</p>
<p>T(x) = O(logx)</p>",1.0,Graded,18157,essay,"<p>T(x) = T(x/2) + C</p>
<p>= T(x/4) + 2*C</p>
<p>= T(x/8) + 3*C</p>
<p>&nbsp;</p>
<p>This pattern will show that it will eventually become:<br>T(x) = T(x/2^n) + n*C, where n is the number of expansions</p>
<p>This will stop when x/2^n = 1.</p>
<p>We can change this to x = 2^n</p>
<p>so n = log(x)</p>
<p>We can substitute this back in the original equation:<br>T(x) = T(1) + c * log(x)</p>
<p>This ultimately become O(log(x))</p>
<p>T(x) = O(log(x))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>input: x: perfect square &gt;=0</p>
<p>output: mid: sqrt(x)</p>
<p>low &lt;- 0</p>
<p>high &lt;- x</p>
<p>while low &lt;= high:</p>
<p>&nbsp; &nbsp; &nbsp;mid &lt;- (low + high)./2</p>
<p>&nbsp; &nbsp; &nbsp;if mid* mid == x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return mid</p>
<p>&nbsp; &nbsp; &nbsp; else if mid * mid &lt; x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low &lt;- mid + 1</p>
<p>&nbsp; &nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high &lt;- mid -1</p>",3.0,Graded,0,0,0,9.0,8.5
Phuong Thao Dang,493444,UW102Y823,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 09:08:24 UTC,00:29:23,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>n: length of array</p>
<p>T(n) = 2 * T(2/3 *n ) + c = 2 * T(2/3*n) + O(1)</p>
<p>c: constant work of printing</p>
<p>for n &lt; 3, T(n) = 1 =&gt; T(0) = T(1) = T(2) = 1</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>&nbsp;</p>
<p>T(k) = T (k/2) + c = T(k/2) + O(1)</p>
<p>for k &lt;= 1, T(k) = 1 =&gt; T(0) = T(1) = 1</p>
<p>c: constant number of steps 4 steps = O(1)</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>Using a tree:</p>
<p>&nbsp;</p>
<table style=""border-collapse: collapse; width: 100%; height: 145px;"" border=""1"">
<tbody>
<tr style=""height: 29px;"">
<td style=""width: 33.305%; height: 29px;"">step&nbsp;</td>
<td style=""width: 33.305%; height: 29px;"">input&nbsp;</td>
<td style=""width: 33.3064%; height: 29px;"">work</td>
</tr>
<tr style=""height: 29px;"">
<td style=""width: 33.305%; height: 29px;"">0</td>
<td style=""width: 33.305%; height: 29px;"">k</td>
<td style=""width: 33.3064%; height: 29px;"">1</td>
</tr>
<tr style=""height: 29px;"">
<td style=""width: 33.305%; height: 29px;"">1</td>
<td style=""width: 33.305%; height: 29px;"">k/2</td>
<td style=""width: 33.3064%; height: 29px;"">1</td>
</tr>
<tr style=""height: 29px;"">
<td style=""width: 33.305%; height: 29px;"">2</td>
<td style=""width: 33.305%; height: 29px;"">k/4</td>
<td style=""width: 33.3064%; height: 29px;"">1</td>
</tr>
<tr style=""height: 29px;"">
<td style=""width: 33.305%; height: 29px;"">j</td>
<td style=""width: 33.305%; height: 29px;"">k/(2^j)</td>
<td style=""width: 33.3064%; height: 29px;"">1</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>height of the tree : j</p>
<p>k / (2^j) = 1</p>
<p>k = 2^j</p>
<p>j = log<sub>2&nbsp;</sub>k&nbsp;</p>
<p>&nbsp;</p>
<p>total work is&nbsp; &nbsp;T(k) = <img class=""equation_image"" title=""\sum_{i=0}^{\log k}1=\left(\log_2k+1\right)\cdot1\in O\left(\log k\right)"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog%2520k%257D1%253D%255Cleft(%255Clog_2k%252B1%255Cright)%255Ccdot1%255Cin%2520O%255Cleft(%255Clog%2520k%255Cright)?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log k}1=\left(\log_2k+1\right)\cdot1\in O\left(\log k\right)"" data-equation-content=""\sum_{i=0}^{\log k}1=\left(\log_2k+1\right)\cdot1\in O\left(\log k\right)"" data-ignore-a11y-check=""""></p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Algorithm(n, k)</p>
<p>Base case:</p>
<p>if k = 0: return 1</p>
<p>else if k = 1: return n</p>
<p>else:</p>
<p>&nbsp; &nbsp; &nbsp;if k is odd:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a = Algorithm( n, (k-1) /2 )&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return a*a*n</p>
<p>&nbsp; &nbsp; &nbsp;else (that is k is even):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = Algorithm (n, k /2 )</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return a * a</p>
<p>&nbsp;</p>
<p>recursively call an algorithm if k &gt; 1, depending on if k is odd or even return the Algorithm(n, k/2) multiplied by itself&nbsp; if its even, else return the algorithm(n, (k-1)/2) multiplied by itself and multiplied by the base if k is odd</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Naveen Keshava Murthy,641054,UW118D007,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 21:12:24 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>Let A(n) be the number of basic operations done by the algorithm for an input of size 'n'.&nbsp;</p>
<p>For the base cases, A(1) = 1 because we do 1 comparison to check if the length==1?</p>
<p>and A(2)=2 because we do 1 comparison to check the length and 1 comparison to find the min of A[0] and A[1].</p>
<p>&nbsp;</p>
<p>For larger size inputs, we do 2 recursive calls of size (n/3) and then iterate through the middle third of the array doing n/3 comparisons.&nbsp;</p>
<p>Thus, <strong>A(n) = 2A(n/3) + (n/3) with A(1)=1 and A(2)=2.</strong></p>
<p>&nbsp;</p>
<p>Using other definitions of the basic operation like including the return statement or being even more specific, we can get other values of A(1) and A(2) but the main point is that the base cases take only constant work (it is not a factor of 'n').&nbsp;</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Let A(n) be the number of look ups we do to find the minimum required mark to earn an A (the look up to check whether a particular mark will get an A is the basic operation of the algorithm).&nbsp;</p>
<p>Thus,&nbsp;</p>
<p><strong>A(n) = A(n/2) + O(1) with A(1)=1.&nbsp;</strong></p>
<p>O(1) can also just be written as a constant 'c'. (I do this in question 4 when solving the recurrence anyways).&nbsp;</p>
<p>Explanation:</p>
<p>O(1) work is done in each iteration of the while loop to check whether the value `mid` is enough to earn an A. I'm assuming that this lookup takes constant time.&nbsp;</p>
<p>In the base case, when there is only 1 possible mark, we can immediately look up whether this mark gets an A or not, which again takes constant time.&nbsp;</p>
<p>In all other cases, we halve the search space.&nbsp;</p>",1.0,Graded,18157,essay,"<p>A(n) = A(n/2)+O(1) with A(1) = c</p>
<p>A(n) = A(n/2) + c (writing the O(1) explicitly using a constant 'c')</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = A(n/2^2) + 2c</p>
<p>In general, in the ith unwinding</p>
<p>A(n) = A(n/2^i) + ic.&nbsp;</p>
<p>This reaches the base case of A(1) when n/2^i = 1 or n=2^i or i=log_2(n) - ""log of n to base 2"".&nbsp;</p>
<p>So, A(n) = A(1) + c*log_2(n)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = c + c*log_2(n)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = c(1+log_2(n))</p>
<p>&nbsp;</p>
<p>Thus asymptotically, <strong>A(n) = O(log_2(n))</strong>.&nbsp;</p>
<p>In fact, this is actually <strong>A(n)=Big-Theta(log_2(n))</strong> because we can bound it from below as well.&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Binary search on 'i' - the value that will get an A.&nbsp;</p>
<p>We can think of the marks as an array of true/false (T/F) where T means that the mark gets an A and F means that it does not get an A.&nbsp;</p>
<p>[F, F, F, F, F, T, T, T, T....T]</p>
<p>All marks from 0 to 1 before the minimum will <strong>not</strong> get an A and all marks starting from the minimum and upto 100 will get an A.&nbsp;</p>
<p>So, we need to find the first occurrence of T in the range [0, 100].</p>
<p>This is a typical binary search problem which halves the search space in each iteration .</p>
<p>C++ style code for the algorithm:</p>
<p style=""padding-left: 40px;""><code>int lo = 0; // lowest possible grade</code></p>
<p style=""padding-left: 40px;""><code>int hi = 100; // highest possible grade</code></p>
<p style=""padding-left: 40px;""><code>while (lo &lt; hi) {</code></p>
<p style=""padding-left: 40px;""><code>&nbsp; int mid = lo+(hi-lo)/2; // mid is the (# of points) we are checking in this iteration of the while loop.</code></p>
<p style=""padding-left: 40px;""><code>&nbsp; if (mid gets an A on the final) { hi = mid; } // mid might be the lowest score needed to get an A</code></p>
<p style=""padding-left: 40px;""><code>&nbsp; else { lo = mid+1; } // mid definitely does not get an A so we increment 1 to it and check the range [mid+1, hi]</code></p>
<p style=""padding-left: 40px;""><code>}</code></p>
<p style=""padding-left: 40px;""><code>if (lo gets an A on the final) { cout &lt;&lt; lo &lt;&lt; '\n'; }</code></p>
<p>&nbsp;</p>
<p><code>The return value of the algo (variable lo) will be the minimum score needed to get an A.</code></p>",2.5,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,1,0,9.0,8.5
Benjamin Isom,491454,UW985P134,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 18:19:05 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>Recurrence: T(n) = 2T(2n/3)+ c&nbsp;</p>
<p>Base: T(2) = 1</p>
<p>Base: T(1) = 1<br><br>This is because the program reaches base case if n is less than 3 and assumes non empty and valid so either length of 2 or 1 and in base case does constant time of returning.&nbsp;</p>
<p>Then algorithm splits the input by a factor of two-thirds each time and there are two different calls to the algorithm. Then in each call to algorithm it does constant amount of work of calling print on the first element of array something done in constant time.&nbsp;</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c&nbsp;</p>
<p>T(1) = 1</p>",1.0,Graded,18157,essay,<p>On the kth layer the amount of work per layer is of constant time as the algorithm throws out data each time instead of splitting it and continuing to do it on both and each node of the tree does constant time as all you do each time is find the midpoint of the array. The amount of layers there are is log(n) (in base two) since you split the data in half each time. Therefore the amount of work is log(n) * constant which is then O(log(n)).&nbsp;</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>I would design an algorithm similar to a binary search. I would have n be list of numbers to n and I would start at i = floor((n)/2) and check that to see if I receive an A. If so then I will throw out all entries above that point and run algo on that data. If I did not receive an A with that score then I would throw out all 1 to midpoint inclusive entries&nbsp; and will run the algorithm again on that set. Note that I will keep the entry if it received an A as this could be the minimum but will throw out the entry if it does not receive an A as this cannot be the entry. This will ""converge"" on the lowest score that receives an A. My base case in this scenatrio is checking if the spread is of length 1 and if so returning that number of points as the lowest amount of points to get an A. This works as the amount of points to get an A is a fixed range and we are essentially able to do binary search on a sorted array of numbers from 1-N</p>
<p>&nbsp;</p>
<p>Algo 2: (n)</p>
<p>if m=n return n and exit&nbsp;<br>i = n/2&nbsp; floor</p>
<p>if you get an A with i points on the final then&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; delete entries i+1-n</p>
<p>&nbsp; &nbsp; &nbsp; Algo 2(n)</p>
<p>else</p>
<p>&nbsp; &nbsp; &nbsp;delete entries 1-n</p>
<p>&nbsp; &nbsp; &nbsp;Algo2(n)</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Ignas Dauksys,481666,UW956T352,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 17:39:01 UTC,00:29:12,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(n) = T(2n/3) + T(2n/3) + T(2n/3) + n; T(1) = 1&nbsp;</p>
<p>or T(n) = 3T(2n/3) + n; T(1) = 1</p>",1.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + n; T(1) = 1</p>,0.5,Graded,18157,essay,"<p>T(n) = T(n/2) + n</p>
<p>&nbsp;= T(n/2^2) + n + n/2</p>
<p>= T(n/2^3) + n + n/2 +n/2^2</p>
<p>...</p>
<p>T(n) = T(n/2^k) + n/2^k (this can be written out as a geometric series AND lg2n = k</p>
<p>T(n) = T(1) + n * <img class=""equation_image"" title=""\sum_{i=0}^{k-1}\frac{1}{2^{^{lgn}}}"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257Bk-1%257D%255Cfrac%257B1%257D%257B2%255E%257B%255E%257Blgn%257D%257D%257D?scale=1"" alt=""LaTeX: \sum_{i=0}^{k-1}\frac{1}{2^{^{lgn}}}"" data-equation-content=""\sum_{i=0}^{k-1}\frac{1}{2^{^{lgn}}}"" data-ignore-a11y-check=""""> (this will result in a series heading to a constant, with the a = 1/2 &lt; 1</p>
<p>T(n) = 1 + n * (1-(1/2)^lg n) (when going to infinity will only leave the n term existing, which mean the recurrence relation would end up being O(n))</p>
<p>T(n) = T(n/2) + n = O(n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>A divide and conquer algorithm for this case would be one that checks if the value divided by 2 of the input is 0. If it is 0, this is the base case of the recursion and will return the value. after this, we would track the result of the recursion by the use of a variable. By dividing the input value in half, and then multiplying the results of the recursion together would give us a better run time performance than this brute force algorithm. (e.g. sqrt(16) -&gt; sqrt(16/2) * sqrt(8/2) = 2 * 2 = 4)</p>",1.0,Graded,0,1,0,9.0,3.0
Ajinkya Dhamdhere,489649,UW108Q017,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:27:02 UTC,00:11:10,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>Base Case: T(n) = O(1) when n &lt; 3</p>
<p>Reccurence Relation: T(n) = 3T(n/3) + O(1)</p>",0.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n / 2) + O(1)</p>
<p>&nbsp;</p>
<p>Base case is O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n / 2) + c</p>
<p>T(n) = T(n / (2)^2) + 2c</p>
<p>T(n) = T(n / (2)^3) + 3c</p>
<p>...</p>
<p>T(n) = T(1) + c* log<sub>2</sub>(n)</p>
<p>so T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log(n))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>We can use binary search to do a log(n) runtime where n is the value of x.&nbsp;</p>
<p>BinarySearch(low, x):<br>low = 0</p>
<p>high = x</p>
<p>while low &lt; high:</p>
<p>&nbsp; &nbsp; &nbsp; middle = (low + high) / 2</p>
<p>&nbsp; &nbsp; &nbsp; // Base Case: We found it</p>
<p>&nbsp; &nbsp; &nbsp; if middle * middle == x:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return middle</p>
<p>&nbsp; &nbsp; &nbsp;elif low * low &lt; middle:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return BinarySearch(low, middle)</p>
<p>&nbsp; &nbsp; &nbsp;else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return BinarySearch(middle, x)</p>
<p>&nbsp;</p>",2.5,Graded,0,0,0,9.0,6.0
Nicolas Dittmar Greaves,425181,UW117O084,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 15:02:52 UTC,00:10:13,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n) = 2+(n/5)+(4n/5)+(3n/5)</p>,2.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(k/2) + O(1)</p>,0.0,Graded,18157,essay,"<p>&nbsp;1 -&gt; 1/2 -&gt; 1/4 -&gt; ...</p>
<p>1/2^x cost for x levels</p>
<p>stops when k = 1</p>
<p>Cost is k/2^x = 1</p>
<p>k = 2^x -&gt; x = log2k</p>
<p>Total cost will be log2k + 1 which is O(logk)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>isqrt(a):</p>
<p>&nbsp; if (a &lt; 1)</p>
<p>&nbsp; &nbsp;return 1</p>
<p>&nbsp;n = k /2</p>
<p>&nbsp;result = result + isqrt(n)</p>
<p>return result&nbsp;</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
SAKETH EDPUGANTI,584833,UW107J930,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:34:41 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2) + 2T(n/4) + O(n)</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case : r = 1 ; we can stop searching.&nbsp;</p>
<p>T(n) = 2T(n/2)&nbsp;</p>",0.0,Graded,18157,essay,"<p>We can use a recursion tree or unrolling method to solve this recurrence relation.&nbsp;</p>
<p>T(n) = 2T(n/2)&nbsp;</p>
<p>= 2(2T(n/4) ) = 4T(n/4)&nbsp;</p>
<p>= 8T(n/8)&nbsp;</p>
<p>This can be generalised as 2<sup>i</sup>T(n/2<sup>i</sup>)&nbsp;</p>
<p>Adding the time of all levels, we get a geometric series which sum is 1/1-r&nbsp;</p>
<p>Whcih comes to O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Can use a binary search algorithm to find the optimal time in O(logn).&nbsp;</p>
<p>Recursively check in each half of the tower's maximum range distance&nbsp;</p>",0.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Anqi GAO,578872,UW117Y079,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 03:47:14 UTC,00:21:52,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(<img class=""equation_image"" title=""\frac{2n}{3}"" src=""/equation_images/%255Cfrac%257B2n%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{2n}{3}"" data-equation-content=""\frac{2n}{3}"" data-ignore-a11y-check="""">) + O(1), T(1) = O(1)</p>",2.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">) + c, T(1) = O(1)</p>",1.0,Graded,18157,essay,"<p>We can solve it byu expanding step by step</p>
<p>&nbsp;T(n) = T(n/2) + c</p>
<p>=(T(n/4)+c)+c=T(n/4) + 2c = T(n/8)+ 3c = T(n/2^k) + kc</p>
<p>&nbsp;</p>
<p>When n/2^k = 1 which means k = log<img class=""equation_image"" title=""2^n"" src=""/equation_images/2%255En?scale=1"" alt=""LaTeX: 2^n"" data-equation-content=""2^n"" data-ignore-a11y-check="""">&nbsp;</p>
<p>T(n) = T(1) + c log<img class=""equation_image"" title=""2^n"" src=""/equation_images/2%255En?scale=1"" alt=""LaTeX: 2^n"" data-equation-content=""2^n"" data-ignore-a11y-check=""""></p>
<p>Since T(1) = O(1)</p>
<p>T(n) = O(logn)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>LowerBound(A,k)</p>
<p>&nbsp; &nbsp;if A[n] &lt; k: return ""None""</p>
<p>&nbsp; &nbsp;lo <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> 1 ; hi <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> n</p>
<p>&nbsp; &nbsp;ans <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> ""None""</p>
<p>&nbsp; &nbsp;while lo <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> hi;</p>
<p>&nbsp; &nbsp; &nbsp; mid <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> [(lo + hi)/2]</p>
<p>&nbsp; &nbsp; &nbsp; if A[mid] <img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check=""""> k:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> A[mid]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hi <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> mid - 1</p>
<p>&nbsp; &nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lo <img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""> mid + 1</p>
<p>return ans</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Dongjoon Kim,328887,UW118O730,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:04:46 UTC,00:22:50,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>P(n) = P(n/2) + 2P(n/4) + cn</p>
<p>P(1) = 1&nbsp;</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c = T(n/4) + 2c = T(n/8) + 3c ... = T(n/2<sup>k</sup>) + kc, for some integer k.</p>
<p>Since T(1) = 1, the recurrence relation comes to the base case when n/2<sup>k</sup> is 1. Then, k = log<sub>2</sub>n.</p>
<p>Then T(n) = T(1) + log<sub>2</sub>n * c = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>If A[1] &gt; k, then return ""None""</p>
<p>First, find the middle value of the array. Let i be the index of the mdidle value If</p>
<p>#1: <span style=""font-family: inherit; font-size: 1rem;"">A[i]=k&nbsp; or&nbsp; </span></p>
<p><span style=""font-family: inherit; font-size: 1rem;"">#2: A[i]&nbsp; &lt; k and A[i + 1] &gt; k, then return A[i].&nbsp;</span>&nbsp;</p>
<p>Else if A[i] &gt; k, then do the recursive call with the left half of the array A, which is A[1:i-1].</p>
<p>Else if A[i] &lt; k and A[i+1] &lt; k, then do the recursive call with the right half of the array A, which is A[i+1, n].</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Milos Graovac,487295,UW982K388,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 21:41:37 UTC,00:29:25,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>I will name this occurence S(n). S(1), the base case, runs at a constant time, so S(1) = O(1). For the rest of the algorithm, it first runs a linear search (O(n)), does a swap (O(1)), the recursivley does this 3 times on sizes of the second half of the array (1/2), first quarter of the array (1/4) and the second quarter of the array (1/4) . So, S(n) = S(n/2)+2S(n/4)+O(n), S(1) = O(1).&nbsp;</p>",3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>For the base case, it is a simple constant if statement check, so it runs at constant time. The recursive part has 2 recursive calls, both on a/2. C(n)=2C(n/2)+n, C(1) = 1.</p>",0.0,Graded,18157,essay,"<p>C(n) = 2C(n/2)+n=2(2C(n/4)+n/2)+n=... We can see a pattern emerge here, where at every level k, we double the value <img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check="""">. We stop this sequence when that value=1, in other words, when k= logn. Since each level will equal in total n, C(n)=nlogn&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Algorithm: CALC(a,b)</p>
<p>k=1</p>
<p>Base case: if (isqrt(a) = k) return k;</p>
<p>Because we know k will have to be an integer, that means that a&gt;=b, becuase only way to make b^k = a if b was larger would be with fractions(not allowed).&nbsp;</p>
<p>return CALC(a/2, b) + CALC(a/2, b)</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Chengduo Gu,535403,UW952S315,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 20:08:09 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>base case: when&nbsp; array length n = 1; algorithm just return A[0],</p>
<p>T(1) = c&nbsp; &nbsp; &nbsp;//c is const valve++++</p>
<p>when n&gt;1,split array into 3 arrays,each size = n/3; and recurrence call SuperMax for each three ,then do two times of compare Max</p>
<p>so Time = 3T(n/3), merge time = O(1)</p>
<p>total time = 3T(n/3) + O(1)</p>",0.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>assume algorithm&nbsp; compare time = T(n) when input size = n.</p>
<p>so T(n) = T(n/2) +c&nbsp; &nbsp; &nbsp;//c is const time of compare time</p>
<p>BASE CASE: when n =1, only once T(1) = d</p>
<p>this seem like T(n) = T(n/2) + O(1)</p>
<p>thruogh Master Theorem : a = 1,b = 2,f(n) = O (1)</p>
<p>compare n^(log <img class=""equation_image"" title=""_b"" src=""/equation_images/_b?scale=1"" alt=""LaTeX: _b"" data-equation-content=""_b"" data-ignore-a11y-check=""""> a) = n^(log 1) = n^0 = 1</p>
<p>so f(n) = O(1) = O (n<img class=""equation_image"" title=""^{\log_ba-c}"" src=""/equation_images/%255E%257B%255Clog_ba-c%257D?scale=1"" alt=""LaTeX: ^{\log_ba-c}"" data-equation-content=""^{\log_ba-c}"" data-ignore-a11y-check="""">) for&nbsp; some&nbsp; n &gt; 0</p>
<p>&nbsp;</p>
<p>T(n) = T(n/2) + c when n &gt;1, =d when n = 1.</p>
<p>so T(n) = <img class=""equation_image"" title=""\theta"" src=""/equation_images/%255Ctheta?scale=1"" alt=""LaTeX: \theta"" data-equation-content=""\theta"" data-ignore-a11y-check="""">(log n)</p>",1.0,Graded,18157,essay,"<p>when countinue expansion k times</p>
<p>T(n) = T(n/2) +c</p>
<p>= T(n/4) + 2c</p>
<p>= T(n/8) + 3c</p>
<p>........</p>
<p>= T(n/2^k) + kc</p>
<p>d &lt;= T(n) &lt;=d + c log&nbsp;</p>
<p>d + c (log<img class=""equation_image"" title=""_2"" src=""/equation_images/_2?scale=1"" alt=""LaTeX: _2"" data-equation-content=""_2"" data-ignore-a11y-check=""""> n ) &lt; = T(n) &lt;= d + c(log<img class=""equation_image"" title=""_2"" src=""/equation_images/_2?scale=1"" alt=""LaTeX: _2"" data-equation-content=""_2"" data-ignore-a11y-check=""""> n)</p>
<p>so T(n)&nbsp; = d + c log<img class=""equation_image"" title=""_2"" src=""/equation_images/_2?scale=1"" alt=""LaTeX: _2"" data-equation-content=""_2"" data-ignore-a11y-check=""""> n <img class=""equation_image"" title=""\pm"" src=""/equation_images/%255Cpm?scale=1"" alt=""LaTeX: \pm"" data-equation-content=""\pm"" data-ignore-a11y-check="""">O(1) = theta(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>input : n = max possible score</p>
<p>output: minimum score to get an A</p>
<p>&nbsp;let low = 1, high = n;</p>
<p>while low &lt; high do</p>
<p>&nbsp; &nbsp; mid = (low+ high)/2</p>
<p>&nbsp; &nbsp; if mid can get A on final, then</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; high = mid;</p>
<p>&nbsp; &nbsp; else&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; low = mid +1</p>
<p>return low</p>
<p>&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Joseph Hellerud,487983,UW983V853,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 21:32:37 UTC,00:30:00,1,18054,essay,"<p>T(n) &lt;= 3*T(n/2) + cn; T(1) &lt;= c, where c is some constant</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) &lt;= T(n/2) + c; T(1) &lt;= c, where c is some constant</p>",1.0,Graded,18157,essay,"<p>T(n) &lt;= T(n/2) + c; T(1) &lt;= c</p>
<p>T(n) &lt;= T(n/4) + 2c</p>
<p>T(n) &lt;= T(n/8) + 3c</p>
<p>T(n) &lt;= T(n/(2^k)) + kc</p>
<p>n/(2^k) = 1 so lg(n) = k</p>
<p>T(n) &lt;= 1 + lg(n) * c so it is O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Given an array of size n, you find the mid point k given by the cieling of (n/2). given that point you check the point just before and after the mid point, if A[k-1] &lt; A[k] &lt; A[k+1], store the value k, then do a recursive call on the array A[k ... n] and return the value (k-1) + the return of the recursive call. if A[k-1] &gt; A[k] &gt; A[k+1], do a recursive call on the array A[1 ... (k-1)] and return the value of the recursive call. If A[k-1] &lt; A[k] and A[k] &gt; A[k+1], return the value (k-1). Base Case: if the size of array is 1, then return 0.&nbsp;</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Samarah Hiba,521136,UW009J068,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:43:01 UTC,00:29:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2T(n/3) + cn</p>
<p>&nbsp;</p>
<p>cn --&gt; cn/3, cn/3: there are only 2 recursive calls in a1 and a2, the base cases are when there exists 1 element and when there exists only 2 elements to find the min element from A[0] and A[1]</p>",2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + cn</p>
<p>&nbsp;</p>
<p>Base case is going to be when a/b is equal to 1.&nbsp;</p>",0.0,Graded,18157,essay,"<p>O(nlogn)&nbsp;</p>
<p>cn/2 --&gt; cn/4 --&gt; cn/8&nbsp;</p>
<p>log2(n)&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>k = 2j is k is even, k = 2j + 1 if k is odd</p>
<p>b was given in the original brute force algorithm</p>
<p>function isqrt(a,b)&nbsp;</p>
<p>while( a/b != 1)</p>
<p>{</p>
<p>part1 = isqrt (a/b) + 1;</p>
<p>&nbsp;</p>
<p>}</p>
<p>return part1;</p>
<p>the value for part1 should give the answer ultimately</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Matan Ivri,511295,UW973N260,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:24:16 UTC,00:25:47,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>n: length of the array</p>
<p>T(1) = T(2) = O(1)</p>
<p>T(n) = T(2n/3) + T(2n/3) + T(2n/3) + O(1) = 3T(2n/3) + O(1)</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>n: points in the final exam</p>
<p>O(log n):</p>
<p>T(n) &lt;= T(n/2) + c &lt;= T(n/2) + O(1) = O(log n); T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + O(1); T(1) = 1</p>
<p>depth of tree is k, and in lowest level the inout size is n/2^k -&gt; n/2^k = 1 -&gt; n = 2^k -&gt; log n = log 2^k -&gt;&nbsp;</p>
<p>k = log n, so depth of the tree is log n.</p>
<p>total work: sum from i = 0 to i = log n, of 2^ i * c = log (n) * c -&gt; O(log n)</p>
<p>T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>n: points in final exam</p>
<p>Brute Force: O(n), because run on every item</p>
<p>Devide an conquer: O(log n):</p>
<p>i = n/2</p>
<p>RecursiveCheck(i, n):</p>
<p>// base case got n in the exam and still didnt get A</p>
<p>if(i == n):</p>
<p>&nbsp; &nbsp; then return null</p>
<p>else if(i give A):</p>
<p>&nbsp; &nbsp; then return min(i, recursiveCheck(i/2, n)) // check if there is a smaller i that gets A</p>
<p>else: // (i doesn't give A)</p>
<p>&nbsp; &nbsp; then return RecursiveCheck((n-i) / 2, n) // look in higher i (mid between i and n)</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
NUQMAN BIN NOR ISKANDAR,576469,UW110S300,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 04:13:49 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,<p>T(n) = T(n/3) + c ; T</p>,0.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> T(n/2) + c</p>",0.0,Graded,18157,essay,"<p>Prove this by recursion tree</p>
<p>n ----- c<br>|<br>n/2 -- c<br>|<br>n/4 --- c<br>|</p>
<p>n/<img class=""equation_image"" title=""2^k"" src=""/equation_images/2%255Ek?scale=1"" alt=""LaTeX: 2^k"" data-equation-content=""2^k"" data-ignore-a11y-check=""""> --- c&nbsp; &nbsp; &nbsp; &nbsp; k = log n</p>
<p>&nbsp;</p>
<p>so, <img class=""equation_image"" title=""\sum_{i=0}^{\log n}"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog%2520n%257D?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log n}"" data-equation-content=""\sum_{i=0}^{\log n}"" data-ignore-a11y-check=""""> c</p>
<p>= c<img class=""equation_image"" title=""\sum_{i=0}^{\log n}1"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog%2520n%257D1?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log n}1"" data-equation-content=""\sum_{i=0}^{\log n}1"" data-ignore-a11y-check=""""></p>
<p>= c(log n + 1)</p>
<p>= c log n + c</p>
<p>so here, asymptotic solution is&nbsp; O(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>ALG(x : int, i : int) -&gt; r : int<br>input: let x is our value of perfect square, and i is our current tracking value<br>output: r, the square root of x</p>
<p>Base case: if i == 1 or i == 0 or i*i == x, return i</p>
<p>Divide: <br>if x is even and can be divide without having remainder, ALG(x, x/10)<br>else if x is even and can be divide without having remainder, ALG(x,x/2)<br>else if x is odd and can be divide without having remainder, ALG(x, x/5)<br>else if x is odd and can be divide without having remainder, ALG(x,x/3)</p>
<p>Conquer:<br>If i*i == x, return i</p>",0.0,Graded,0,0,0,9.0,0.0
Adnan Fazulbhoy,450085,UW107V551,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 15:48:18 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>Base Cases : <br>when n =&lt; 4 : T(n) = O(1)&nbsp; &nbsp;<br>Recursive Case (when n&gt;4 ):&nbsp; 2T(n/4) + O(1)&nbsp;<br><br></p>,3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>For array of size n.&nbsp;<br>Base Case:<br>T(1) = O(1)&nbsp;</p>
<p>Reccurence Relation:<br>T(n) = T(n/2) + O(1)&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + C<br>T(n/2) = T(n/2<sup>2</sup>) + C</p>
<p>=&gt; T(2) = T(n/2<sup>2</sup>) + 2C<br>=&gt; T(n) = T(n/2<sup>k</sup>) + kc</p>
<p>n/2<sup>k</sup> = 1 =&gt; k = log<sub>2</sub>n&nbsp;</p>
<p><br>&nbsp;= &gt;T(n) = T(1) + log<sub>2</sub>n x C</p>
<p>= &gt; T(n) = C + log<sub>2&nbsp;</sub>x C</p>
<p>= &gt; T(n) is O(logn) or T(n) = (logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Psudocode for algorythim is as follows given sorted array A of length 'n' and number 'k' as given:&nbsp;<br>Algo(A,k):<br>a=1 ; b=len(A) ; ans=""None""</p>
<p>while a&lt;b :&nbsp;</p>
<p style=""padding-left: 40px;"">let m = (a+b)/2</p>
<p style=""padding-left: 40px;"">if&nbsp; A[m] &gt;= k :</p>
<p style=""padding-left: 80px;"">ans = A[m]</p>
<p style=""padding-left: 80px;"">b = m - 1</p>
<p style=""padding-left: 40px;"">else:</p>
<p style=""padding-left: 80px;"">low = m + 1&nbsp;</p>
<p>return ans<br><br><br>Using a modified binary search algorithym inorder to obtain faster result by narrowing search array each time. Narrowing search until our case isn't met (a&lt;b).</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Anvesha Girish,513362,UW117V071,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 18:01:02 UTC,00:29:02,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>Let T(n) be the time complexity of the algorithm</p>
<p>Base Case: If n&gt;=3 then T(n)=O(1)</p>
<p>The time complexity will be T(n)=2T(2n/3)+O(1) for the recurrence relation where T(n)=1 for n=3</p>",2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: T(n)=O(1) and let T(n) be the time complexity</p>
<p>Recursive relation: T(n)= T([n/2]) + C</p>
<p>The constant factors O(1)=d</p>
<p>Upper bound: T(n)&lt;=d+c[log<sub>2</sub>n]= O(log n)</p>",1.0,Graded,18157,essay,"<p>Recursive tree: level 0- c on size n</p>
<p>level 1- c on size n/2</p>
<p>we keep halving until it gets to size 1</p>
<p>Where depth h is the smallest h with n/2<sup>h</sup> &lt;=1</p>
<p>therefore h=[log<sub>2</sub>h]</p>
<p>T(h)= <img class=""equation_image"" title=""\phi"" src=""/equation_images/%255Cphi?scale=1"" alt=""LaTeX: \phi"" data-equation-content=""\phi"" data-ignore-a11y-check="""">+[c+c+c...n times]</p>
<p>t(h)= d+c[log<sub>2</sub>n]</p>
<p>therefore the asymptotic solution is T(n)=O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Algorithm using divide and conquer: Repeatedly divide the array into halves and check the middle element.</p>
<p>If the middle element is smaller than the next one the turning point lies in the right half otherwise it lies in the left half.</p>
<p>Continue this process recursively until the exact index where the order changes from increasing to decreasing is found.</p>
<p>The runtime is comparitively faster than the brute force algorithm with O (log n)</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Karl Haidinyak,517596,UW999A724,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 20:50:14 UTC,00:16:21,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(N) &lt;= T(N/5) + T(3N/5) + T(4N/5) + 1</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(N) &lt;= T(N / 2) + 1 where T(1) = 1</p>,0.0,Graded,18157,essay,"<p>T(N) &lt;= (T(N/4) + 1) + 1 and T(1) = 1</p>
<p>T(N) &lt;= ((T(N/8) + 1) + 1) + 1 &lt;= (((T(N/16) + 1) + 1) + 1) + 1 &lt;= ... &lt;= T(N/2^k) + k</p>
<p>N/2^k = 1 -&gt; 2^k = N -&gt; k = log(N)</p>
<p>T(1) + log(N)</p>
<p>T(N) is an element of O(log(N))</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>DCPower</p>
<p>Input n, k: Base n &gt; 0, exponent k &gt;=0</p>
<p>if k = 0: return 1</p>
<p>Initialize low = 0, high = INT_MAX, l2 to n * ln(k)</p>
<p>while low &lt;= high</p>
<p>Initialize mid to low + high / 2, l1 to ln(mid)</p>
<p>if l1 = l2 return l1</p>
<p>else if l1 &lt; l2: low = mid + 1</p>
<p>else: high = mid - 1</p>
<p>end while</p>
<p>return -1</p>
<p>&nbsp;</p>",0.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Abby Hanson,492031,UW987M830,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 19:05:43 UTC,00:22:32,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>T(n) = 2*T(2n/3) + O(1), T(0) = 1, T(1) = 1, T(2) = 1. The cost per call is constant, as it is a print operation, indicated with O(1). Could also be written as c.&nbsp;</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= 2*T(n/2) + c. T(1) = c.&nbsp;</p>,0.25,Graded,18157,essay,"<p>T(n) &lt;= 2*T(n/2) + c, and T(1) = c. Using the recursion tree method. The cost of each call is constant, so in each node, there will be a constant term. We have two recursive calls, so our root node will contain the value c, and it will have two children, each with cost c/2. We repeat until we get to tree depth k, at which all nodes will have a cost per call of c/2^k. Recursion will end when tree height is log n. At each tree height, the total cost is c, so our total runtime is the summation from 0 to logn of c, so our total runtime is c*log(n), where n is the maximum range that the cell tower can reach. Asymptotic solution: O(logn). All logs in this case are of base 2.&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>input: array of potential cell phone signal ranges of length n. This array holds each natural number from 0 to n in increasing order.</p>
<p>divide: call getsService() on the n/2th array element, assuming integer division WLOG, and split the array of ranges into two sorted arrays of ranges of equal length. If GetsService is true for the n/2th element, recurse into the left half of the array, as we want to find the smallest possible range that serves our friend. If GetsService is false, recurse into the right half of the array, as we have not found a range big enough to cover our friend yet. Repeat this process until we split the array into two single-element arrays. Then, follow the base case.</p>
<p>base case: if there is one range value in the array, call GetsService on that value and if it is True, return that value as the smallest range that serves your friend, as there is only one range value.&nbsp;</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.25
Yuxuan Hu,473694,UW100K219,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 19:20:08 UTC,00:28:03,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2T(n/3)+(n/3)*c</p>
<p>base case: T(1) = O(1) = c, T(2) = O(1) = c</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(x) = T(x/2) +c = T(x/2) + O(1)</p>
<p>base case: T(1) = O(1) = c&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(x) = T(x/2) + c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x=2^k, k = log(x)</p>
<p>&nbsp; &nbsp; &nbsp; =(T(x/4) +c) +c</p>
<p>&nbsp; &nbsp; &nbsp; = ...</p>
<p>&nbsp; &nbsp; &nbsp; = T(x/(2^k)) + kc</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(1) + log(x) *c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= c + log(x) *c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;=O(log(x))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>return value: return the square root of x</p>
<p>divide: have a list is from 0 to x, split this list in to two list repeatively by choose the min and max value and calculate the median of this list, then generate two list : [min,median] and [median,max]</p>
<p>conquer: since we have the median as a number, we can calculate the median*median and compare it with the x, if it's too large we choose the [min,median], if it's too small, we choose the [median,max] list as min and max value and continue to calculate the median</p>
<p>base case: when x is 0, just return itself 0 since <img class=""equation_image"" title=""\sqrt{x}"" src=""/equation_images/%255Csqrt%257Bx%257D?scale=1"" alt=""LaTeX: \sqrt{x}"" data-equation-content=""\sqrt{x}"" data-ignore-a11y-check=""""> (x=0) is 0; if the input is 1, just return itself since <img class=""equation_image"" title=""\sqrt{1}"" src=""/equation_images/%255Csqrt%257B1%257D?scale=1"" alt=""LaTeX: \sqrt{1}"" data-equation-content=""\sqrt{1}"" data-ignore-a11y-check="""">&nbsp; is 1</p>
<p>def squareroot(x):</p>
<p>if x == 0 or x == 1:</p>
<p>&nbsp; &nbsp; &nbsp; return x</p>
<p>low = 0</p>
<p>high = x</p>
<p>while low &lt;= high:</p>
<p>&nbsp; &nbsp; &nbsp; median = (low+high)/2</p>
<p>&nbsp; &nbsp; &nbsp; if median *median == x:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return median</p>
<p>&nbsp; &nbsp; &nbsp; else if median*median &lt; x:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = median + 1</p>
<p>&nbsp; &nbsp; &nbsp; else if median * median &gt; x:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = median - 1</p>",3.0,Graded,0,0,0,9.0,9.0
Sheldon Huynh,569790,UW107X093,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 19:36:51 UTC,00:29:36,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(1) = 1<br>T(2) = 1</p>
<p>T(n) = 2T(n/3) + n/3</p>",3.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1)=1</p>
<p>T(n) &lt;= T(n/2) + c</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n/2) = T(n/4) + c</p>
<p>...</p>
<p>T(1) = 1</p>
<p>to get from T(n) to T(1) log_2(n) calls had to be made</p>
<p>Each call (including the base case) gives a constant, c, amount of work</p>
<p>so T(n)&lt;=c*log_2(n)</p>
<p>Thus, the algorthim is o(log_2(n))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Using an algorthim similar to binary search except instead of searching for x search for x^2</p>
<p>input: x, r (starts as floor(x/2)),u (starts at x), l (starts at 0)</p>
<p>check if r*r == x, then return r</p>
<p>First check if r^2 is less than or greater than x<br>If it is greater, then return another function again but input x=x, r = (ceil(u + r)) / 2, u = u, l = r<br>else return function but as x=x, r = (floor(l+r))/2, u = r, l=l</p>
<p><br>PSUEDO CODE:</p>
<p>input: x= value that is being sqrt,r =potential value that can equal sqrt(x), u = upper bound, l = upper bound</p>
<p>output: the square root of x<br>sqrt(x,r):</p>
<p>if r*r == x:</p>
<p>&nbsp; &nbsp; &nbsp;return r;</p>
<p>if(r*r&gt;x):</p>
<p>&nbsp; &nbsp; return sqrt(x,ceil((r+x)/2,u,r));</p>
<p>else:</p>
<p>&nbsp; &nbsp; return sqrt(x,floor(r/2),r,l);</p>",3.0,Graded,0,0,0,9.0,9.0
Snehal Jaiswal,483614,UW102S700,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:21:57 UTC,00:29:14,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>There are two recursive calls as we can see. First calls 1/3 of first part of A and second calls 1/3 of last of A.</p>
<p>Base case: n&lt;=2, constabt work is done. T(1) = O(1) and T(2) = O(1)</p>
<p>&nbsp;</p>
<p>When we use all the observations, we can conclude the following:</p>
<p>T(n) = 2T(n/3) + cn ( for n&gt;2) &lt;----- Answer</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case T(1) = O(1) (n &lt;= 1)</p>
<p>for binary search divide and conquer algorithm,&nbsp; we can use :</p>
<p>T(n) = T(n/2) + O(1) ,&nbsp; for&nbsp; (n &gt;1)</p>
<p>O(1) for n &lt; 1.</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) +1(c)</p>
<p>&nbsp; = (T(n/4) + c) + c = T(n/4) + 2c</p>
<p>= T(n/8) + 3c</p>
<p>if we keep continuing....</p>
<p>we find that,</p>
<p>T(n) = T(n/(2^k)) + kc</p>
<p>&nbsp;</p>
<p>now when n/2^k &lt;= 1 we get k = logn (with base 2)</p>
<p>&nbsp;so T(n) = T(1) = c [logn ] = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>start:</p>
<p>less &lt;-1</p>
<p>high&lt;-n</p>
<p>while (less &lt;= high ) do</p>
<p>middle &lt;- ((high +less)/2)</p>
<p>if score is (middle) , will give an A then</p>
<p>high &lt;- middle -1</p>
<p>else&nbsp;</p>
<p>less &lt;- middle&nbsp; +1</p>
<p>return less</p>
<p>end</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Harshul Jalan,449555,UW966C997,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 18:13:49 UTC,00:29:54,1,18054,essay,<p>T(1) = O(1)<br>T(n) = 3*T(n/2) + O(n)<br><br></p>,3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(1) = O(1)<br>T(n) = T(n/2) + O(1)</p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c<br>T(n/2) = T(n/(2^2)) + c<br>so,<br>T(n) = T(n/(2^2)) + 2c<br>i.e.<br>T(n) = T(n/(2^i)) + ic<br><br>This goes on till it reaches base case: T(1) = O(1) i.e. T(1) = c<br>lets assume there will be k layers:<br>then n/(2^k) = 1<br>making k = lg n<br><br>So, T(n) = T(n/(2^k)) + kc<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = T(1) + c*(lg n)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = c + c*(lg n)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = c*(1 + lg n)<br>Therefore, T(n) belongs to O(lg n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Algo(A, l, h):<br>&nbsp; &nbsp;if l == h then<br>&nbsp; &nbsp; &nbsp; &nbsp;return l<br>&nbsp; &nbsp;m = (l+h)/2<br>&nbsp; &nbsp;if A[m] &lt; A[m+1] then<br>&nbsp; &nbsp; &nbsp; &nbsp; return Algo(A, m+1, h)<br>&nbsp; &nbsp;otherwise:<br>&nbsp; &nbsp; &nbsp; &nbsp; return Algo(A, l, m)<br><br>answer = Algo(A, 1, n)</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Jeremy Jarocki,504787,UW987V042,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 20:35:51 UTC,00:25:56,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>T(n)=T(n/5)+T(4n/5)+T(3n/5)+1</p>
<p>T(1)=1</p>",2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)=T(n/2) + 1</p>
<p>T(1)=1</p>",1.0,Graded,18157,essay,"<p>Each layer takes constant time to run, including the base case and there is only a maximum of 1 recursive call per layer. To get to T(1), for K layers, 2^K = n and thus K = log n. Since all layers have a constant run time, the run time of the algorithm is 1*C * log n or simply C*log n where C is an arbitrary constant for the time it takes for the constant functions to run.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>findSplit(A) {</p>
<p>&nbsp; //Base Case. Length / 2 provides an integer value for the middle of the array</p>
<p>&nbsp; let middle = A[length / 2]</p>
<p>&nbsp; //If left and right dont exist, set values to a flag to set the base case to true</p>
<p>&nbsp; let left = A[length / 2 - 1]</p>
<p>&nbsp; let right = A[length / 2 + 1]</p>
<p>&nbsp; // In 1 2 3 1, suppose the middle element is 3 and since both neighbors are &lt; than it, the length of A1 is 3 by the problem definition. Thus, 4/2-1 = 3.</p>
<p>&nbsp; if (left &lt; middle &amp;&amp; right &gt; middle) return (length / 2 - 1);</p>
<p>&nbsp;</p>
<p>&nbsp; // Recursive cases. If decreasing, go to left to find the ""middle"" element but if increasing go to the right</p>
<p>&nbsp; if (left &gt; middle) {</p>
<p>&nbsp; &nbsp; return findSplit(A[1..middle])</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; return findSplit(A[middle..end of A])</p>
<p>&nbsp; }</p>
<p>}</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Travis Johnson,445212,UW946E622,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 17:53:49 UTC,00:22:25,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(n) = 3*T(n/3) + n; T(1) = 1.</p>,0.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>M(n) &lt;= 2 + M(n/2). T(1) = 0, T(0) = 0</p>",1.0,Graded,18157,essay,"<p>M(n) &lt;= 2 + M(n/2). Total Cost = <img class=""equation_image"" title=""\sum^k_{i=0} 2. \frac n{2^k} = 1 \implies 2^k = n \implies k = \log n. \sum^k_{i=0}2=\sum^{\log n + 1}_{i=1} 2= 2\log n + 2 \in O(\log n). "" src=""/equation_images/%255Csum%255Ek_%257Bi%253D0%257D%25202.%2520%255Cfrac%2520n%257B2%255Ek%257D%2520%253D%25201%2520%255Cimplies%25202%255Ek%2520%253D%2520n%2520%255Cimplies%2520k%2520%253D%2520%255Clog%2520n.%2520%255Csum%255Ek_%257Bi%253D0%257D2%253D%255Csum%255E%257B%255Clog%2520n%2520%252B%25201%257D_%257Bi%253D1%257D%25202%253D%25202%255Clog%2520n%2520%252B%25202%2520%255Cin%2520O(%255Clog%2520n).%2520?scale=1"" alt=""LaTeX: \sum^k_{i=0} 2. \frac n{2^k} = 1 \implies 2^k = n \implies k = \log n. \sum^k_{i=0}2=\sum^{\log n + 1}_{i=1} 2= 2\log n + 2 \in O(\log n). "" data-equation-content=""\sum^k_{i=0} 2. \frac n{2^k} = 1 \implies 2^k = n \implies k = \log n. \sum^k_{i=0}2=\sum^{\log n + 1}_{i=1} 2= 2\log n + 2 \in O(\log n). "" data-ignore-a11y-check=""""> This shows that we can run this recursive algorithm to only use log n multiplications instead of n.&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Power:</p>
<p>Input: n, k: Base n &gt; 0, Exponent k &gt;= k</p>
<p>Output: power: The value of n^k</p>
<p>if k == 0: return 1 end</p>
<p>if k == 1: return n end</p>
<p>power = Power(n, k / 2) # integer division</p>
<p>if k % 2 == 1: return n*power*power end</p>
<p>else: return power*power end</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Parker Kalis,481374,UW924C040,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:27:58 UTC,00:30:00,1,18054,essay,"<p>3 Recursive calls (First half 2x, Second Half 1x) (2n / 2)&nbsp; (n/2), first half gets reversed twice, work per level increases</p>
<p>Base Case: F(1) = 1; (F(n) = 1)</p>
<p>Recurrence: 3T(n/2) + n</p>
<p>&nbsp;</p>",2.5,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base Case: F(1) = n, n^1 = n</p>
<p>Recurrence: 2T(n/2) + logn</p>",0.0,Graded,18157,essay,<p>O(nlogn)</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Instead of multiplying every single base by the power. Instead we can split the range from 1 to k in half. With this range split in half we can use a recursive algorithm to calculate two different numbers that when we merge can multiply to reach the correct exponentiation. By substituting additon withing the recursive cases to find a portion of the total n^k value, we can save compute on multiplication. Each of the smaller solutions will be added up to equal the final value n^k. We will keep splitting and dcing un</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Justin Kim,504758,UW988V267,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:28:58 UTC,00:22:57,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(2n/3) + O(1) for n &gt;= 2, T(1) = O(1), T(2) = O(1)</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(Math.ceil(n/2)) + O(1)</p>
<p>BC: T(1) = O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(n/4) + 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(n/8) + 3</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(n/2<sup>k</sup>) + k</p>
<p>n/2<sup>k</sup> = 1 =&gt; n = 2<sup>k</sup> =&gt; k = log<sub>2</sub>(n)</p>
<p>T(n) = T(n/2<sup>log<sub>2</sub>(n)</sup>) + log<sub>2</sub>(n)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(1) + log<sub>2</sub>(n)</p>
<p>&nbsp;</p>
<p>T(n) = Theta(log<sub>2</sub>(n))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Intuition: binary search-like</p>
<p>Base case: if |A| == 1 (ie, only one elt in searchable array): return the score, ie, A[0]</p>
<p>Divide: split the sorted range of scores in half, taking some midpoint m (use ceil if between idx) and getting the value at A[m]</p>
<p>Conquer: check if getting a score of m gives you an A. If true, recursively search the lower half, else search the higher half.</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Owen Kloepping,481456,UW924M948,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:41:07 UTC,00:30:00,1,18054,essay,<p>T(1) = 1<br>T(n) = T(n/2) + T(n/2) + T(n/2) + cn<br>= 3T(n/2) + cn</p>,3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>base case is constant time<br>2 recursive case&nbsp;<br><br>T(1) = 1<br>T(n) = T(n/2) + c<br>= T(n/2) + c</p>,1.0,Graded,18157,essay,"<p>(recursion tree)<br>T(n) : c<br>T(n/2) : c/2&nbsp;<br>T(n/4): c/4<br>...<br>T(n/2^k): c / 2^k<br><br>Stop recursing when height n/2^k = 1 (reached base case), which gives,<br>&nbsp;k = log2(n)<br><br>sum up all the recursive calls<br><img class=""equation_image"" title=""\sum_{k=0}^{\log2\left(n\right)}\frac{c}{2^k}"" src=""/equation_images/%255Csum_%257Bk%253D0%257D%255E%257B%255Clog2%255Cleft(n%255Cright)%257D%255Cfrac%257Bc%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \sum_{k=0}^{\log2\left(n\right)}\frac{c}{2^k}"" data-equation-content=""\sum_{k=0}^{\log2\left(n\right)}\frac{c}{2^k}"" data-ignore-a11y-check=""""><br>so c is summed log2(n) times so there log2(n) total work done, so&nbsp;<br>T(n) = O(log n)</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Basically searching for the first element of A2 since from it we can find the length of A1, the first element of A2 is a local max of the array, it can be found using a binary search like algorithm, after this elemnt is found just return: len of A - index of A2[0] (in A)<br>(iterative approach)<br>L = 0<br>R = A len<br>while (L &lt;= R)&nbsp;<br>&nbsp; m = (L+R)/2<br>&nbsp; if (A[m] is a local max): return A len - m<br>&nbsp; elif (A[m] is increasing order, ie A[m-1] &lt; A[m] &lt; A[m+1]): L = M+1<br>&nbsp; else (A[m] in decreasing order, in A[m-1] &gt; A[m] &gt; A[m+1]): R = M-1<br>return -1 #no m found<br><br>(recursive approach)<br>findLen(A, start_index, end_index):<br>&nbsp; m = (start_index + end_index) / 2&nbsp;<br>&nbsp; if (A[m] is local max): <br>&nbsp; &nbsp; &nbsp; return len of A - m<br>&nbsp; elif (A[m] is in ascending order, ie A[m-1] &lt; A[m] &lt; A[m+1]):<br>&nbsp; &nbsp; &nbsp; return findLen(A, m+1, R)<br>&nbsp; elif (A[m] is in descending order, ie A[m-1] &lt; A[m] &lt; A[m+1]): <br>&nbsp; &nbsp; &nbsp; return findLen(A, L, m-1)</p>
<p>&nbsp;</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Pranav Krishnan,521330,UW977G586,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:35:14 UTC,00:18:10,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>Base case: T(n) = c when n (length) &lt; 4</p>
<p>Reccurence: T(n). = 2T(n/4) + c when n (length) &gt;= 4</p>",2.5,Graded,18155,essay,<p>Divide and Conquer Approach: Use a <strong>binary search </strong>(divide and conquer approach)&nbsp;taking the number of crores at the middle i each reccurrence which halves the range of values to test until the smallest number i is found such that the routine runs in under 1 second on i cores.</p>,3.0,Graded,18156,essay,"<p>Base Case: T(n) = theta(1) for n &lt;= 1</p>
<p>Reccurence: T(n) = T(cieling n/2) + theta(1) for values of n &gt; 1</p>",1.0,Graded,18157,essay,"<p>To solve for the recurrence, unroll the relationship formed in part B:</p>
<p>Given T(n) = T(cieling n/2) + theta (1) for values of n &gt; 1 and the base case of T(n) = theta(1) for n &lt;= 1<br>Replace the constant with var c:<br>T(n) = T(n/2) + c</p>
<p>Unrolling gives us: T(n/4) + c + c = T(n/4) + 2c</p>
<p>Following this approach gives us a general question T(1/(2^k) * n) + k*c ) or T(n/2^k) + k*c as a general equation for k terms</p>
<p>Unrolling fully simplifies down to T(1) + c*log base 2 of n which has a time complexity of T(n) = theta(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Albert Lee,500803,UW099V222,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:35:25 UTC,00:27:40,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>S(n) = S(n/2) + S(n/4) + S(n/4) + cn</p>
<p>&nbsp;</p>
<p>first shuffle + second shuffle + third shuffle + find &amp; swap</p>",2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Recurrence relation: BS(n) = BS(n/2) + c</p>
<p>We first calculate i by taking the average of the min and max: constant time.</p>
<p>If min == max, we know that we have found the answer, as the range of points contains only a single valid value. The base case comparison is also constant.</p>
<p>Assuming score(i) is constant, the operation of sliding the max bound to the left is also constant time.</p>
<p>Similarly, the operation of sliding the min bound to the right is also constant time.&nbsp;</p>
<p>Therefore, we have a constant operation time of c, and some number of recursive levels. We will find the number of recurisive levels in part C.</p>",0.75,Graded,18157,essay,"<p>Recall that the recurrence relation is BS(n/2)+c<br>We are halving the list of possible points during every recursive call, which is O(log(n)). From Part B we confirmed that we are doing O(1) work within each recursive call, assuming that score(i) is constant. Hence, when we combine the two discoveries we get that BS(n/2) = O(log(n)).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Note: score(i) is the act of plugging point i into canvas. We will assume this is constant time. We also assume that i is a limited range of discrete points.</p>
<p>BS(min, max):</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp;i = (min+max) // 2</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp;if min == max: // Base Case</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return i</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp;if score(i) == A:</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = i</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp;else:</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min =i</p>
<p style=""text-align: left;"">&nbsp; &nbsp; &nbsp;return BS(min,max)</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.25
Benjamin Lelivelt,568168,UW107S132,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 21:14:58 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>Base Case: When lenA &lt; 5 returns O(1) time</p>
<p>Reccurance: T(n/5) + T(4n/5) + T(3n/5) + c</p>
<p>&nbsp;</p>",3.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base Case when x = 1, since square root of 1 is 1 it will return immediatly, so R(1) = O(1)</p>
<p>Reccurance Relation: R(n) = R(n/2) + c, as each level eliminates half of the values from x' to 2x' or to 0 (the remaining values it could be)</p>",1.0,Graded,18157,essay,"<p>For Each level, my program does a constant amount of work (multiplication is constant) so it runs in O(1)</p>
<p>The number of levels is bounded by R(n/2), which = O(logn) amount of work, so the final runtime would be O(1) * O(logn)</p>
<p>= O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>For Function R</p>
<p>Input x, x', level (starts at 2)</p>
<p>Base Case: If x' * x' = x, return x'</p>
<p>If x' * x' &gt; x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;return R(x, x' - x'/level, level++)</p>
<p>else if x' * x' &lt; x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;return R(x, x' + x'/level, level++)</p>
<p>&nbsp;</p>",3.0,Graded,0,0,0,9.0,9.0
Noah Li,569996,UW104R075,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 22:25:20 UTC,00:29:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>T(n) = T(n/2) + 2T(n/4) + c (for some constant c);</p>
<p>T(1) = 1</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2(n/2) + c; for some constant c</p>
<p>T(1) = 1</p>",0.0,Graded,18157,essay,"<p>At the root, it starts out with n values, with the cost being c. In the second level, there's two recursive calls, and each subproblem gets divided into 2. The cost for the whole level is also c. So there would be two nodes that have the value n/2. At level k, the size called would be n/(2^k). At the base case, which is 1, the amount of levels would be n/(2^k) = 1. n = 2^k. k = log2(n). In total there are log2(n) + 1 levels if you include the root. Since each level also requires cost c. The total asymptotic solution would be O((log2(n) + 1) * c) which is ~ O(n).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Base Case: if k = 0, return 1</p>
<p><strong>Divide</strong>:&nbsp;</p>
<p>Divide k into two parts: left and right half.&nbsp;</p>
<p><strong>Conquer</strong>:</p>
<p>Recursively multiply n by itself for however many value in the halves. If any half happens to have a length of 0, return 1.</p>
<p><strong>Merge</strong>:</p>
<p>Assume each half is leftHalf and rightHalf, respectively. Calculate both halves. Then, multiply each other and return the value.</p>
<p>&nbsp;</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Yeongseok Lim,453031,UW954S491,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 17:21:07 UTC,00:28:51,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2(n/3)+cn, T(1)=1</p>",2.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = 2(k/2)+cn, T(1)=1</p>",0.0,Graded,18157,essay,"<p>in each recursion, the subproblem becomes the size of half and the problem is splitted into two subproblems. So it's going to be O(nlogn).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>1. Divide -&gt; split the problem, even (k=2j) odd(k=2j+1)</p>
<p>2. Conquer -&gt; Recursively solve each case even and odd</p>
<p>3. merge -&gt; combine the result</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
Icheng Lin,513300,UW009N445,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 02:32:10 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) &lt;= 2*T(n/4) + T(n/2) + cn; T(1) &lt;= c</p>,3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n/2) + c; T(1) &lt;= c</p>,1.0,Graded,18157,essay,"<p>T(n) &lt;= T(n/2) + c; T(1) &lt;= c<br>Assume k as the tree height</p>
<p>(sum from i=0 to k)(n/(2^k))<br>=n*(sum from i=0 to k)((1/2)^k)<br><br>The recursion terminates when n/(2^k) = 1<br>n = 2^k<br>k = log_2(n)<br><br>Back to solving the sum<br>n*(sum from i=0 to k)((1/2)^k)<br>=n(1 / (1-0.5))<br>=n(1/0.5)<br>=log_2(n)<br>=O(log(n))</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Algorithm: FindMinGreaterThanK<br>Input: Sorted array A from smallest to largest, minimum value k<br>Output: minimum value in A that &gt;= k</p>
<p>if len(A) == 1:<br>&nbsp; &nbsp; &nbsp; &nbsp; return ((A[1] &gt;= k) ? A[1] : ""None"")</p>
<p>middle = floor(len(A) / 2)<br>if (A[middle] &gt;= k):<br>&nbsp; &nbsp; &nbsp; &nbsp; return FindMinGreaterThanK(A[:middle])<br>else:<br>&nbsp; &nbsp; &nbsp; &nbsp; return FindMinGreaterThanK(A[middle:])</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Prajeeth Kittoor Muralidhar,641938,UW118C786,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-16 23:35:17 UTC,00:26:15,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>2T(n/4)+ theta(1)&nbsp; base case=theta(1) for n&lt;=4</p>,3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)=T(n/2)+ O(1) base case when a=b n=1 and T(1)=O(1)</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n)=T(n/2)+c&nbsp; for k&gt;1, T(1)=d</p>
<p>=T(n/2)+c</p>
<p>=(T(n/4)+c)+c<br>unrolling k times<br>=T(n/2^k)+ kc<br>n/2^k=1<br>k=logbase2n<br>T(n)=c*logbase2n<br>T(n)=theta(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>findPower(a,b)</p>
<p>if(a==b) return 1</p>
<p>if(a&lt;b) return 0</p>
<p>&nbsp;</p>
<p>sqrta=isqrt(a)</p>
<p>sqrtofadivb= isqrt(a/b)</p>
<p>if sqrta * sqrta==a</p>
<p>j=findpower(sqrta,b)</p>
<p>if j&gt;0</p>
<p>return 2*j</p>
<p>if sqrtadivb * sqrtadivb==a</p>
<p>j=findpower(sqrtadivb,b)</p>
<p>if j&gt;0</p>
<p>return 2*j+1</p>
<p>&nbsp;</p>
<p>return 0</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Zander Lowery,579374,UW963A210,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 21:53:00 UTC,00:29:55,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2T(n/3) + n, T(1) = O(1), T(2) = O(1)</p>",2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n/2) + O(1); T(1) = O(1)</p>,1.0,Graded,18157,essay,"<p>We will use a recurrence tree.&nbsp;</p>
<p>Level 0: we just have n for constant work&nbsp;</p>
<p>Level 1: we replace n in level 0 with n/2 giving a total work of n/2</p>
<p>Level 2: We replace n in level 1 with n/2 giving a total work of n/4.&nbsp;</p>
<p>&nbsp;</p>
<p>Thus, for every level, we reduce the amount of work that needs to be done by a factor of 1/2 and get a constant size and a work of n/2^k.</p>
<p>1=(n/2^k) =&gt; 2^k = n =&gt; k = log(n).<br>This gives a sum{k=0}_{k = log n} of 1 because the work is constant. This gives a O(log(n)) runtime&nbsp;</p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>CanGetA(i) returns true or false depending if the score i gives an A. Intialize low = 0.</p>
<p>Algo(low, n):</p>
<p>hi = n</p>
<p>mid = low + hi / 2</p>
<p>if(canGetA(mid)): hi = mid</p>
<p>else: low = mid</p>
<p>Algo(low, hi);</p>
<p>if hi &gt;= 1 and CanGetA(hi) then: return hi</p>
<p>else: return none/null</p>",2.5,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.0
Mo Lubbad,511375,UW100Z899,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 03:21:49 UTC,00:26:59,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(n) = 3T(2n/3) + O(1) if n &gt; 2 and T(n) = O(1) if n&lt;= 2</p>,3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>low = 1, high = n, answer = n&nbsp;</p>
<p>while low is less than or equal to high: you create a variable mid that will be (low+high) / 2, then if the routine runs in under 1 second, answer = mid and high = mid - 1. Else low becomes mid + 1</p>
<p>after the while return answer</p>
<p>&nbsp;</p>",3.0,Graded,18156,essay,<p>T(n) = T(n/2) + c; T(1) = c<sub>0<sup>&nbsp;</sup></sub>&nbsp;</p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c. Expand it: T(n/2) = T(n/4) +c and substitute it back so T(n) = T(n/4) + c + c or T(n) = T(n/4) + 2c. Expand it again: T(n/4) = T(n/8) + c and sub it back in, so T(n) = T(n/8) + 3c. Identify whats happening: T(n) = T(n/(2^k)) + kc. So n/(2^k) = 1 which means k = log<sub>2</sub>n. T(n) = c<sub>0</sub> + clog<sub>2</sub>n. If you drop the constants, you get O(logn).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
AADITYA MALHOTRA,486534,UW115A330,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 20:18:12 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 1 + 1 + 1 + ( (n/3) + 1) +(n/3) + T(n/3) + T(n/3) + 1</p>
<p>T(n) = 2 . T(n/3) + 5 + (2n/3)</p>
<p>T(n) &lt;= 2 . T(n/3) + c.n, T(1) = 1, T(2) = 1</p>",3.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)&nbsp; = T(n/2) + 1 + 1 + 1 + 1= T(n/2) + 4 &lt;= T(n/2) + c from some c &gt;= 4</p>
<p>Final :&nbsp; &nbsp; &nbsp;T(n) &lt;= T(n/2) + c, T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(n) &lt;= T(n/2) + c, T(1) = 1</p>
<p>the binary tree will look like</p>
<p>c -&gt; c -&gt; c -&gt; ... from 0 to K times</p>
<p>So the summartion will be from i=0 to K ( c ) = k+1</p>
<p>Now the base case is when n / 2^k = 1, so k = log2 (n)</p>
<p>So the sumamation becomes k + 1 = log2 (n) + 1 = O(log2 (n))</p>
<p>So the recurrance is O(log2 (n)), which is better than the brute force linear algo.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>let list A be the list of ranges of the tower from 1 to n</p>
<p>algo ( A ):</p>
<p>&nbsp; &nbsp; if |A| == 1: return A[0]</p>
<p>&nbsp; &nbsp; mid = floor (|A| / 2)</p>
<p>&nbsp; &nbsp; if GetsService(mid) == False:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return algo(A[mid+1 : ]</p>
<p>&nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return algo( A[ : mid])</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Kevin Marshall,397830,UW948M770,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 03:48:19 UTC,00:33:24,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n)=1+n+T(n/2)+T(n/4)+T(n/4)</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>With isqrt poorly defined, this is impossible.&nbsp; Behavior is undefined.</p>",0.0,Graded,18157,essay,"<p>Behavior of isqrt is undefined.&nbsp; Therefore, impossible to make an algorithm that uses it.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>This question makes no sense.&nbsp; If isqrt(a) returns b^floor(k/2), then all you have to do is check whether b^2k == a or b^(2k+1) == a and you have k.&nbsp; No recurrence needed.</p>
<p>And without a good definition of what isqrt(a) actually does, I can't answer this question.&nbsp; This is why there shouldn't be ""hand-wavy"" definitions in problems in an algorithms class.</p>
<p>I suspect what is wanted here is that with a=b^k that if you know k/2, you can divide the work of traversing all possible k into 1:floor(k/2) and floor(k/2) halves and recurse until k/2 = 1 (base case).&nbsp; When one of the halves returns with a b^k that equals a, you short-circuit out of the recursion.&nbsp; I assume that's what's wanted here, but without knowing what isqrt actually returns, (is it b? is it k? is it both (a tuple)... what am I working with here?)</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Joey Martino,481355,UW919N126,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 21:45:40 UTC,00:13:26,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>2O(n/4) + 1</p>,2.0,Graded,18155,essay,"<p>Algorithm: for each i 1 to n<br>Base Case: when n = 0, time = infinity</p>
<p>If the routine runs in OVER 1 second on i cores, multiply i by 2.&nbsp;</p>
<p>If the algorithm runs in UNDER 1 second on i cores, subtract 1 from i and check (i-1) runtime.&nbsp;</p>
<p>If the algorithm runs in under 1 second on k cores and over one second on k-1 cores, we have found the threshold.&nbsp;<br><br>This halves the unnecessary checks on cores that run in over one second. The brute force algorithm checks every value of i through n, including the values of j (WLOG, the first value of i that would run in over one second) and below. This algorithm allows i to approach the threshold twice as fast before fine tuning.&nbsp;</p>",1.0,Graded,18156,essay,<p>O(n/2) + 1 as the algorithm cuts the list in half and then parses to find the threshold of where the process takes under one second.</p>,0.0,Graded,18157,essay,<p>Log(2) of n</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
Ismael Jaral-Vera,280130,UW842K376,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:41:32 UTC,00:25:13,1,18054,essay,"","",Not Attempted,18057,essay,<p>T(n) = 2(n/2) + n</p>,0.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>t(n) = 2(n/2) + n</p>,0.0,Graded,18157,essay,<p>not sure.</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Need to find the length of A, we dont know where it ends, we do know that once the next value is less than we have reach the next array.</p>
<p>k: the current element we are comparing</p>
<p>j: the next element after k</p>
<p>input: A[]</p>
<p>basecase: A[k] &lt; A[j]</p>
<p>split the array into parts and recursively call with sub array.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",0.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,0.0
Finn Kuhse,517486,UW999X670,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:39:55 UTC,00:15:01,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>C(n)=C(n/5)+C(n/5)+C(n/5)+1, n&gt;5</p>",2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"",0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>log(a,b)</p>
<p>if(a/b=1)</p>
<p>return b</p>
<p>else</p>
<p>log(a,isqrt(a))</p>
<p>log(a,isqrt(a)*b)</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Madeline Kwong,517478,UW996Q976,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 17:09:49 UTC,00:24:27,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = 3T(n/5) + O(1), T(1) = 1</p>",2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c, T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c, T(1) = 1</p>
<p>T(n/2) = (T(n/4) + c) + c</p>
<p>T(n/4) = ((T(n/8) + c) + c) +c = T(n/16) + 3c</p>
<p>... T(k) = T(n/2^k) + kc</p>
<p>n/2^k = 1</p>
<p>k = logn</p>
<p>total sum = kc = clogn&nbsp;</p>
<p>= O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Input: Array of ranges A[0 .. n]</p>
<p>Output: Smallest range that receives signal</p>
<p>def ALG(A)</p>
<p>Base Case: if |A| == 1: return A[1]</p>
<p>Divide: Divide A into 2 halves, with midpoint represented as mid.</p>
<p>if (GetService(A[mid]) == true): return A[0 : mid] (left half)</p>
<p>else: return A[mid +1: n] (right half)</p>
<p>If mid is true check ranges in the left half and if not check ranges to the right half. This will output the smallest range that receives a cell signal.</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Quinn Lanke,494350,UW980E793,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 19:54:52 UTC,00:21:59,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>T(n) = T(n/2) + 2T(n/4) + O(n)</p>
<p>Base case: T(n) = 1</p>",2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + O(1)</p>
<p>Base case: T(n) = 1</p>",0.0,Graded,18157,essay,"<p>Tree: n --&gt; n/2 + n/2 --&gt; n/4 + n/4 + n/4 + n/4 --&gt; n*(1/2)^h</p>
<p>Amount of work done at each level = O(1) so 1 each time</p>
<p>Base case: n*(1/2)^h = 1 --&gt; n = 2^h --&gt; log2(n) (log2(n) = log base 2 of n)</p>
<p><img class=""equation_image"" title=""\sum_{i=0}^k"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255Ek?scale=1"" alt=""LaTeX: \sum_{i=0}^k"" data-equation-content=""\sum_{i=0}^k"" data-ignore-a11y-check="""">1^i</p>
<p>k is our height, which is just log2(n) (calculated from base case)</p>
<p><img class=""equation_image"" title=""\sum_{i=0}^{\log2\left(n\right)}"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog2%255Cleft(n%255Cright)%257D?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log2\left(n\right)}"" data-equation-content=""\sum_{i=0}^{\log2\left(n\right)}"" data-ignore-a11y-check="""">1^i = 1 + 1 + 1 ... = log2(n)</p>
<p>So our total work is O(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Input: Sorted list A, integer k that you are looking for<br>Output: largest integer that is less than or equal to k<br>Define a variable currMax to store the current maximum x value that we have found</p>
<p>FIND(A, k)<br>Base case: if size of A = 1:<br>if element in A is less than or equal to k:<br>---store current element in currMax<br>---return currMax<br>if element in A is greater than k:<br>---if currMax has not been initialized, return ""none""<br>---if currMax has been initialized/has a value, return currMax<br>else:<br>---FIND(first half of A, k)<br>---FIND(second half of A, k)</p>",1.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Seongrok Lee,578937,UW107G464,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 20:37:18 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>n &lt; 3 :base case O(1)</p>
<p>n&gt;=3 recursive 2n/3 + O(1)</p>
<p>T(n)= 2T(2n/3) +O(1)&nbsp;&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>recurrence&nbsp;</p>
<p>T(n)= O(1) -&gt; theta(1)&nbsp; if n=0 - base case</p>
<p>T(n-1)+theta(1) if n&gt;=1&nbsp;</p>
<p>algorithm checks each possible score from 1 to n by one by one</p>
<p>T(n) = theta(1) +n*theta(1)&nbsp; it has tight bound T(n) = O(n) theta</p>
<p>T(n)=T(n/2)+theta(1)=theta(logn)</p>
<p>so brute force O(n)</p>
<p>Devide and Conquer is O(logn) theta</p>",1.0,Graded,18157,essay,"<p>T(0)=d (constant) T(n)=T(n-1) +O(1)</p>
<p>equivalently , there exist constans c_small *c_large &gt;0</p>
<p>T(n)= T(n-1) +cn&nbsp; (c_small &lt; cn &lt; large)</p>
<p>&nbsp;</p>
<p>T(n)= T(n-1) +cn</p>
<p>&nbsp; &nbsp; &nbsp; = T(n-2)+c_(n-1)+cn</p>
<p>&nbsp; &nbsp; .....</p>
<p>&nbsp; &nbsp; &nbsp; = T(0) + sigma( 1 to n) ci&nbsp; &nbsp;= d+sigma(1ton) ci&nbsp; &nbsp; &gt;&gt; using bound , d+n*c_small &lt;= T(n) &lt;= d+n*c_large</p>
<p>So, T(n) = theta(n)&nbsp; &nbsp;..... basecase : T(0)=theta(1)&nbsp;</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>T(n) =O(n) (scanning all the score(n))&nbsp; &nbsp;, so I think the score and the results are monotonic , so I'd like to use binary search. T(n) =</p>
<p>Divide and conquer (binary search) -&gt; O(logn)</p>
<p>The algorithm repeatedly splits the range (1~n) in half, checking the midpoint to decide whether to search the lower to upper half</p>
<p>if mid gives A &gt; search lower , else search upper hlaf,</p>
<p>T(n)=T(n/2)+O(1) = O(logn)&nbsp; it's faster than brute force algorithm O(n)</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.0
Thomas PARKER,505394,UW991F568,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 03:22:53 UTC,00:28:47,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 3T(n/3) + 1 | Base Case: T(1) = A[0], T(2) = max{A[0], A[1]}</p>",0.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2)+1 Base case: T(1) = 1 (none/value less than k)</p>,1.0,Graded,18157,essay,"<p>Recursion: n/2 --&gt; n/4 --&gt; n/8</p>
<p>Work per level: 1 + 1 + 1</p>
<p>Generic recursion: n/(2^k) --&gt; base case: n/(2^k) = 1 --&gt; Manipulation: log(n) = k</p>
<p>Summation from i = 0 to k of (1) sums to k. From the generic recurisong, we have log_2(n) = k. So the summation = log_2(n) which is big-O of log(n).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Base Cases: Consider an array of size 1, if x &gt; k return none, else return x</p>
<p>Divide step: Divide A in half and call the two halves L and R for the left and right halves respectively.</p>
<p>Conqure step: If R[1] &lt;= k, recurse on R. Otherwise recurse on L.</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
ANDREW PECHENUK,426844,UW932C288,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:12:50 UTC,00:20:06,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>Base case will return the array if length of the array is less than five. So:<br>T(1) = 1<br>There are three recursive calls. Each call is running on a fifth of data structure.:<br>T(n) = 3T(n/5) + 5n&nbsp;</p>,1.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>One recursive call, that is splitting the list in half each time.<br>T(n) = T(n/2) + n T(1) = 1</p>",0.5,Graded,18157,essay,<p>T(n) = T(n/2) + n<br>T(n) = T(n/4) + T(n/2) + n<br>T(n) = T(n/8) + T(n/4) + T(n/2) + n<br><br>Asymptotic Solution: O(nlogn)<br><br></p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Take sorted list of possible test scores in ascending order. Choose the median index is the list, and plug the value in that index into Canvas. If the grade returned is not an A, then discard of the current index and left half of the list. Else if the grade returned is an A, discard of the right half of the list not including the current index. Proceed to recurse on the remaining lists until you are left with one value which is your minimum points needed for an A.&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.0
Vidit Raju,517242,UW987K025,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:08:27 UTC,00:23:18,1,18054,essay,"<p>3T(n/2) + 2O(n)</p>
<p>= 3T(n/2) + O(n)</p>
<p>&nbsp;</p>
<p>T(n) = { BigTheta(1), n=1 | 3T(n/2) + O(n), n &gt; 1}</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = { BigTheta(1), base case | T(n/2) + O(1), every other case }</p>",0.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c&nbsp;</p>
<p>= T(n/4) + 2c</p>
<p>= T(n/8) + 3c</p>
<p>....</p>
<p>= T(1) + clog<sub>2</sub>n</p>
<p>T(n) = BigTheta(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>A divide and conquer algorithm that has an asymptotically faster performance than the given brute force algorithm would be binary search.&nbsp;</p>
<p>First we would define the base case of the first element being greater than K, which means there are no values in the array that will be less than or equal to k.&nbsp;</p>
<p><br>We then define variables low = 1 and high = n and we find the median of these two variables. We will then set this index as current index.</p>
<p>We will start from this current index and compare its value to k. If this value is larger than k, then we subtract 1 from current index and do the same comparison at that index value. If this median index is smaller than k, then we also compare the next index's (current index + 1) value to k. If the next index's value is larger than k, we return this current index's value. Otherwise, we move current index to the next index (current index + 1) and repeat the same comparisons.&nbsp;</p>",1.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Yirga Reminick,492016,UW985T067,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 20:37:54 UTC,00:26:20,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>Base case(constant size):<br><img class=""equation_image"" title=""T\left(n\right)=\Theta\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253D%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=\Theta\left(1\right)"" data-equation-content=""T\left(n\right)=\Theta\left(1\right)"" data-ignore-a11y-check=""""> for <img class=""equation_image"" title=""n\le5"" src=""/equation_images/n%255Cle5?scale=1"" alt=""LaTeX: n\le5"" data-equation-content=""n\le5"" data-ignore-a11y-check=""""><br><br>Recursive case: 1 constant time swap + 3 recursive shuffles:<br>T(n) = T(n/5) + T(4n/5) + T(3n/5) + <img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check=""""> for n &gt; 5</p>",2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>In each step we 1. compare the middle element(O(1) work) and 2. recurse on one half of size n/2<br><br>This gives:<br>T(n) = T(n/2) + 1,&nbsp; &nbsp; T(1) = 1</p>",0.75,Graded,18157,essay,"<p>Unwinding:<br>T(n) = T(n/2) + c<br>&nbsp; &nbsp; &nbsp; &nbsp; = T(n/4) + 2c<br>&nbsp; &nbsp; &nbsp; &nbsp; = T(n/8) + 3c<br>&nbsp; &nbsp; &nbsp; &nbsp; .... = <img class=""equation_image"" title=""T\left(\frac{n}{2^k}\right)+kc"" src=""/equation_images/T%255Cleft(%255Cfrac%257Bn%257D%257B2%255Ek%257D%255Cright)%252Bkc?scale=1"" alt=""LaTeX: T\left(\frac{n}{2^k}\right)+kc"" data-equation-content=""T\left(\frac{n}{2^k}\right)+kc"" data-ignore-a11y-check=""""><br>Stop when <img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check="""">= 1 <img class=""equation_image"" title=""\Rightarrow"" src=""/equation_images/%255CRightarrow?scale=1"" alt=""LaTeX: \Rightarrow"" data-equation-content=""\Rightarrow"" data-ignore-a11y-check="""">k = <img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""><br><br>Substitute:<br>T(n) = T(1) + c<img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""> = 1 + log(n) = log(n)<br><br>So we get <strong>T(n) = log(n)</strong></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>We can use binary search since A is sorted in increasing order. We'll name the algorithm FindGE<br><br>FindGE(A, k):<br>&nbsp; &nbsp; &nbsp;if A is empty:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return None<br>&nbsp; &nbsp; &nbsp;mid = <img class=""equation_image"" title=""\lfloor\frac{n}{2}\rfloor"" src=""/equation_images/%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor?scale=1"" alt=""LaTeX: \lfloor\frac{n}{2}\rfloor"" data-equation-content=""\lfloor\frac{n}{2}\rfloor"" data-ignore-a11y-check=""""><br>&nbsp; &nbsp; &nbsp;if A[mid] &lt; k:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return FindGE(A[mid+1..n], k)<br>&nbsp; &nbsp; &nbsp;else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left = FindGE(A[1..mid-1], k)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if left = None:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return A[mid]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return left</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.25
Lucas Mazzoni,431385,UW936D763,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-16 23:24:34 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2T(n/4) + c</p>,2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + cn; T(1) = 1</p>,0.5,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Input: Array H[1...n] of house positions<br>Output: Smallest range r</p>
<p>r := 0<br>If H empty: return&nbsp;<br>if |H| = 1 and GetService(r) = true: return r</p>
<p>low := 0<br>high := H[n]-H[1]<br><br></p>
<p>while low &lt; high:</p>
<p>&nbsp; &nbsp; mid := (low + high) /2<br>&nbsp; &nbsp; if GetService(mid):</p>
<p>&nbsp; &nbsp; high := mid<br>&nbsp; &nbsp; else:<br>&nbsp; &nbsp; low:= mid + 1<br>&nbsp; &nbsp; end<br><br>return low</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Andrew McDonagh,430929,UW937K015,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 21:19:02 UTC,00:26:04,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n) = 2T(n/4) + cn; T(3) = 0, T(2) = 0, T(1) = 0, T(0) = 0</p>",1.5,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>A recurrence relation for this problem would be T(n) = 2T(n/2) + cn; with base case T(1) = 0</p>,0.0,Graded,18157,essay,"<p>Solving using a recurrence tree would get the root level, T(n),&nbsp; and then the first level having two subproblems = 2T(n/2) + cn with a cost of cn, and the second level with four subproblems = 2(2T(n/4) + cn/2) giving a cost of n as well. And the depth of the tree would be log<sub>2</sub>n. The work to iterate through the area of good service would take constant time, so that times the cost and the depth would give a O(nlogn) runtime.&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>A divide and conquer algorithm that would work for this problem would be similar to a mergesort by dividing n by two until you find an area where your friend doesnt get range. So if n is 100, then the first divide would get the two 50s of n and set the range at 50, then 25, and so on. Once your friend is out of range you know the area of which he gets service and can iterate over that to find the exact distance.</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Ben MORRISON,565618,UW106R760,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 15:41:34 UTC,00:28:27,1,18054,essay,<p>S(n)= 2S(n/2) + 2n; S(1) = 1</p>,1.5,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>L(n) = L(n/2) + c; L(1) = 1&nbsp;</p>,1.0,Graded,18157,essay,"<p>L(n/2) + c</p>
<p>L(n/4) + n/2 + c</p>
<p>L(n/8) + n/4 + n/2 + c</p>
<p>c + sum from i = 1 to n of n/2^i&nbsp;</p>
<p>0(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>lessThanK(A, k)</p>
<p>Input: A, k: sorted array A, number k&nbsp;</p>
<p>n = length[A]</p>
<p>if length[A] = 1</p>
<p>&nbsp; &nbsp; &nbsp;if A[1] &lt; k</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return A[1]</p>
<p>if A[1] &gt; k the</p>
<p>&nbsp; &nbsp; &nbsp;return none</p>
<p>&nbsp; &nbsp; &nbsp;end</p>
<p>left = A[1, n/2}</p>
<p>right = A[n/2+1, n]</p>
<p>if (left[n/2] &gt; k)&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;return lessThanK(left, k)</p>
<p>else (right[n/2] &gt; k)</p>
<p>&nbsp; &nbsp; &nbsp;return lessThanK(right, k)</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Nathan Tsang,512152,UW982Q037,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:25:57 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2) + 2T(n/4) + cn</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + T((n-1)/2) + O(1)</p>,0.0,Graded,18157,essay,"<p>T(n/2) = n, n/2, n/4....summation i = 0 to k of (n/(2^i)) = n * sum(1/2^i). n/(2^k) = 1 so k = log n. Thus T(n/2) = nlog n<br>T((n - 1) / 2) &lt;= T(n/2) = nlogn<br>T(n) = nlog n + nlog n + O(1) = nlogn</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>function( int a, int b)<br>if a = 1, return&nbsp; k = 0<br>else {<br>if a is even, b is even, return (isqrt(a), b)<br>if a is odd, b is odd, return (isqrt(a - 1), b)<br>else if a is even and b is odd return none, same for vice versa<br>return k = a<br>}</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Sam Nesler,487387,UW100G410,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 20:09:42 UTC,00:25:44,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n)=T(n/2)+2T(n/4)+cn; T(1)=0</p>,2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c; T(1) = c</p>,1.0,Graded,18157,essay,"<p>There are k = log(n) levels to the recurrence since we divide the input in half each level.</p>
<p>T(n) = T(n/2^log(n))+log(n)c</p>
<p>2^log_2(n) is equal to n, so</p>
<p>T(n) = T(n/n) + log(n)*c</p>
<p>T(n) = T(1) + log(n) * c</p>
<p>can substitute T(1) = c</p>
<p>T(n) = c(1+log(n))</p>
<p>with big O we can ignore constants so this becomes</p>
<p>T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>you could just binary search. divide and conquer means: divide input, solve smaller inputs, merge together. I am pretty sure that binary search (each level divide input in half) recursively, then merge (decide whether to take the recursive function's result or our result) is divide and conquer. we have to solve in O(log n) which means constant work per level and split input in half each level, so there can't be any other way to do it.</p>
<pre>Algorithm 2: ""Nonobvious"" Algorithm<br>Input: A, k: Array A with length n, number k<br>begin<br>  low &lt;- 1<br>  high &lt;- n<br>  result &lt;- ""None""<br>  <br>  mid &lt;- Math.floor((low + high) / 2)<br>  if A[mid] &lt;= k then<br>    result = A[mid]<br>    low &lt;- mid + 1 // mid is valid, but maybe there's something larger and better out there<br>  else<br>    high &lt;- mid - 1<br>  end<br>  // base case: 1 thing, no more recursion<br>  // maybe we got nothing, maybe the recursion got nothing, both, or neither<br>  // first 2: obviously take what we can get<br>  // 3rd: take the one from the recursion (higher)<br>  // 4th: oh well<br>  // this means: always take recursion's result unless we got something and they didn't<br>  if (low &lt; high) then<br>  recursive_result &lt;- Algorithm2(A[low..high], k)<br>    if (recursive_result != ""None"") then<br>      result &lt;- recursive_result<br>    end<br>  end<br><br>  return result<br>end</pre>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Cole Niemann,415992,UW087P521,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 19:47:03 UTC,00:20:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>t(n) = 3t(n/5) + 1 ; t(1) = 1</p>
<p>&nbsp;</p>
<p>reasoning: 3 recursive calls are called on 1/5th of the array and swapping first and last element is O(1). base case is O(1), even including the conditional&nbsp;</p>",2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>t(n) = 2t(n/2) + 1 ; t(1) = 1</p>,0.0,Graded,18157,essay,"<p>using recursion tree we see the work at each level is constant, with the height of the tree being log(n) where n is the number of points on the exam</p>
<p>using this we get Sum(1) from 0 to logn thus we get something like log(n) + 1, which is O(logn) for some constant c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; 1 \</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;1/2&nbsp; &nbsp; &nbsp; &nbsp; 1/2</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>let p be an array of length n, where each entry corresponds to points on the exam; ex p[1] = 1</p>
<p>binarySearch(p)</p>
<p>modify the base case of binary search to be : if p[index] gets A &amp;&amp; p[index -1] doesnt get A return</p>
<p>&nbsp;</p>
<p>essentially use binary search on the points of the exam, where the return condition is if A is granted, this is logn, where our brute force algo is order n</p>",1.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Eva Nolan,483104,UW975V393,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:15:32 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>&nbsp;<img class=""equation_image"" title=""T\left(n\right)\le T(\frac{n}{5})+T\left(\frac{4n}{5}\right)+T\left(\frac{3n}{5}\right)+cn;T\left(c\right)=1"" src=""/equation_images/T%255Cleft(n%255Cright)%255Cle%2520T(%255Cfrac%257Bn%257D%257B5%257D)%252BT%255Cleft(%255Cfrac%257B4n%257D%257B5%257D%255Cright)%252BT%255Cleft(%255Cfrac%257B3n%257D%257B5%257D%255Cright)%252Bcn%253BT%255Cleft(c%255Cright)%253D1?scale=1"" alt=""LaTeX: T\left(n\right)\le T(\frac{n}{5})+T\left(\frac{4n}{5}\right)+T\left(\frac{3n}{5}\right)+cn;T\left(c\right)=1"" width=""346"" height=""34"" data-equation-content=""T\left(n\right)\le T(\frac{n}{5})+T\left(\frac{4n}{5}\right)+T\left(\frac{3n}{5}\right)+cn;T\left(c\right)=1"" data-ignore-a11y-check=""""> where <img class=""equation_image"" title=""c\le4"" src=""/equation_images/c%255Cle4?scale=1"" alt=""LaTeX: c\le4"" data-equation-content=""c\le4"" data-ignore-a11y-check=""""></p>
<p>&nbsp;</p>",2.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""T\left(n\right)\le2T\left(\frac{n}{2}\right)+cn;T\left(1\right)=1"" src=""/equation_images/T%255Cleft(n%255Cright)%255Cle2T%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252Bcn%253BT%255Cleft(1%255Cright)%253D1?scale=1"" alt=""LaTeX: T\left(n\right)\le2T\left(\frac{n}{2}\right)+cn;T\left(1\right)=1"" data-equation-content=""T\left(n\right)\le2T\left(\frac{n}{2}\right)+cn;T\left(1\right)=1"" data-ignore-a11y-check=""""></p>",0.0,Graded,18157,essay,"<p><img class=""equation_image"" title=""\Theta\left(n\log n\right)"" src=""/equation_images/%255CTheta%255Cleft(n%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(n\log n\right)"" data-equation-content=""\Theta\left(n\log n\right)"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""\sum_i^n2^i\frac{n}{2^i}"" src=""/equation_images/%255Csum_i%255En2%255Ei%255Cfrac%257Bn%257D%257B2%255Ei%257D?scale=1"" alt=""LaTeX: \sum_i^n2^i\frac{n}{2^i}"" data-equation-content=""\sum_i^n2^i\frac{n}{2^i}"" data-ignore-a11y-check="""">&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Algorithm(A, k):</p>
<p>input: A, k</p>
<p>output: x in A that is smallest element greater than or equal to k</p>
<p>// base case: n = |A|&nbsp;</p>
<p>if A[n] &lt; k, return ""None""</p>
<p>m1 = Algorithm(A[(n/2)+1, n], k)</p>
<p>m2 = Algorithm(A[1, (n/2)], k)</p>
<p>return min{m1, m2}</p>",1.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
Alexander Oliva,507307,UW999K624,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:45:00 UTC,00:29:22,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2T(n/2) + O(1)</p>,1.0,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2(n/2) + 1</p>,0.0,Graded,18157,essay,"<p>T(n) = 2T(n/2) + 1 =&gt; 2T(n/(2^k)) + 1 / k =&gt; n = 2^k =&gt; k = log_2(n)</p>
<p>O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Recursively divide the array of ranges into two arrays</p>
<p>For each new array A:</p>
<p>if len(A) == 1 and GetService(A[0]) == true:</p>
<p>return A[0]</p>
<p>if A[0] != A[len(A) - 1]:</p>
<p>&nbsp;return alg(A[mid:], A[:mid])</p>
<p>&nbsp;</p>
<p>idea:</p>
<p>Recursively divide the array of ranges into two arrays</p>
<p>Check the start and end of each new section, if the start and end are the same, discard.</p>
<p>Do this recursively until there is a single element for which GetService(r) is true</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.0
Mikhail Ortiz-Lunyov,438618,UW919V662,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 19:09:46 UTC,00:23:52,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(N) = 3T(2N/3) + n, T(1) = 1, T(2) = 2</p>",2.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(N) = 2(N/2)+n , Best case: T(1) = 1</p>",0.0,Graded,18157,essay,"<p>Pattern: n/(2^K), Base Case: T(1) = 1</p>
<p>n/(2^K) = 1&nbsp; ===&nbsp; n = 2^K&nbsp; &nbsp;===&nbsp; K = log(n)</p>
<p>Asymptotic solution = Log(n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>The algorithm will check if the fist element of the input array is &gt; K. If this is true, then the algorithm returns ""None"".</p>
<p>Otherwise, the algorithm will check the size of the array. If the array is of size 1, then that number will be returned.</p>
<p>Otherwise, if the array is size &gt; 1, the input array will be split in two, and the algorithm will recurse into each half. From the results of each recursion will be compared. If both halves return ""None"", then ""None"" will be returned. Otherwise, the larger number will be returned, even if one of the halves returns ""None"".</p>",1.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
Jeevan Jyot Singh,515308,UW109F253,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 17:34:11 UTC,00:25:04,1,18054,essay,"<p>There are 3 recursive calls.<br>So, for those, recurrence is 3T(n/2)</p>
<p>And we loop through the array twice, so, 2O(n)<br>Base case is O(1)<br><br>So, the recurrence relation is 3T(n/2) + 2O(n) + O(1)</p>
<p>= 3T(n/2) +2n</p>",2.5,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>As we recurse on half of ranges each time, and arithmetic work is in constant time,<br>T(n) = T(n/2) = O(1)</p>",0.75,Graded,18157,essay,"<p>T(n) = T(n/2) + c = T(n/4) + 2c = T(n/8) + 3c...... = T(n/2<sup>k</sup>) + kc</p>
<p>The recursion will stop when the size is 1 i.e. n/2<sup>k</sup> = 1, so, k =log<sub>2</sub>n</p>
<p>T(n) = T(1) +clog<sub>2</sub>n<br>so,<br>T(n) = O(log<sub>2</sub>n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>We can set a low and high values to do a binary search and calling recursively.&nbsp;</p>
<p>i.e. sqrt(x, low, high)<br>Initially, set low to 0 and high to x.<br>set mid = (high + low)/2</p>
<p>if mid*mid == x. return the mid, that is the sqrt(x)</p>
<p>if mid*mid &gt; x, split and recurse with high now set to mid -1</p>
<p>i.e. sqrt(x, low, mid-1)</p>
<p>else, if mid*mid &lt; x, split and recurse on the second half, with low not set to mid.</p>
<p>i.e. sqrt(x,mid, high)</p>",3.0,Graded,0,0,0,9.0,8.25
Frank Sun,449002,UW936F949,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 19:59:03 UTC,00:11:46,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>Base case: T(1) = O(1)</p>
<p>Recurrence: T(n) = T(n/2) + 2T(n/4) + O(n)</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>We could use binary search to find the smallest number of cores i where the routine runs under 1s.</p>
<p>At each step, we test the midpoint and recurse on the half of the range where the condition first becomes true.</p>
<p>Algo: Test the routine at the midpoint number of cores m = [(low + high) /2]</p>
<p>If it already runs in under 1 second on m cores, we know all larger core counts will also work, so we search on the left half to see whether it can still work with less cores.</p>
<p>And we stop when the search range collapses to one value, and that index is the smallest number of cores that meets the time limit.</p>",3.0,Graded,18156,essay,"<p>Base case: T(1) = O(1)</p>
<p>Recurrence: T(n) = T(n/2) + O(1), or T(n) = T(n/2) + c for some constant c.</p>",1.0,Graded,18157,essay,"<p>Recurrence: T(n) = T(n/2) + c, T(1) = d</p>
<p>T(n) = T(n/2) + c (Expand it)</p>
<p>= T(n/4) + 2c</p>
<p>= T(n/8) + 3c</p>
<p>= T(n/2^k) + kc</p>
<p>Stop when n/2^k = 1 =&gt; k = log2n. Thus, T(n) = T(1) + clog2n = d + clog2n.<br>Therefore, T(n) = O(logn).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Aaron Yan,545259,UW104O790,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 09:34:49 UTC,00:24:56,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(1) = 1; T(2) = 1; T(n) = 3T(2n/3) + 1</p>,3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(1) = 1; T(n) = T(n/2) + 1</p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + 1 = T(n/4) + 1 + 1 = ... = T(n/2^k) + k. Since we stop at T(1) = 1, we get n/2^k = 1, so n = 2^k. Taking the logarithm of both sides yields log(n) = k. Thus, T(n) = T(1) + log(n) = 1 + log(n), which is O(log n) time complexity.&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>findX(A, k):</p>
<p>&nbsp; &nbsp; mid = A.length / 2</p>
<p>&nbsp; &nbsp; if A[mid] == k OR mid == 1: // if A[mid] is k or A[mid] is the first element in the current array</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if A[mid] &gt;= k: return A[mid]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; else: return ""None""</p>
<p>&nbsp; &nbsp; else if A[mid] &lt; k: findX(A[mid+1:], k) // exludes mid index in new subarray</p>
<p>&nbsp; &nbsp; else findX(A[1...mid], k) // including mid index in new subarray</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Kindred Yi,579174,UW107Y604,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:05:22 UTC,00:27:04,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>When n &lt; 3, T(n)=O(1)</p>
<p>When n <img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check=""""> 3, T(n)=2T(<img class=""equation_image"" title=""\frac{2n}{3}"" src=""/equation_images/%255Cfrac%257B2n%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{2n}{3}"" data-equation-content=""\frac{2n}{3}"" data-ignore-a11y-check="""">)+O(1)</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0)=O(1), T(1)=O(1), <img class=""equation_image"" title=""T\left(k\right)\le T\left(\lceil\frac{k}{2}\rceil\right)+c,k\ge2"" src=""/equation_images/T%255Cleft(k%255Cright)%255Cle%2520T%255Cleft(%255Clceil%255Cfrac%257Bk%257D%257B2%257D%255Crceil%255Cright)%252Bc%252Ck%255Cge2?scale=1"" alt=""LaTeX: T\left(k\right)\le T\left(\lceil\frac{k}{2}\rceil\right)+c,k\ge2"" data-equation-content=""T\left(k\right)\le T\left(\lceil\frac{k}{2}\rceil\right)+c,k\ge2"" data-ignore-a11y-check="""">,</p>",1.0,Graded,18157,essay,"<p>When K<img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check="""">2,</p>
<p><img class=""equation_image"" title=""T\left(k\right)\le T\left(\frac{k}{2}\right)+c\le T\left(\frac{k}{4}\right)+2c\le\ldots\le T\left(\frac{k}{^{2^i}}\right)+ic"" src=""/equation_images/T%255Cleft(k%255Cright)%255Cle%2520T%255Cleft(%255Cfrac%257Bk%257D%257B2%257D%255Cright)%252Bc%255Cle%2520T%255Cleft(%255Cfrac%257Bk%257D%257B4%257D%255Cright)%252B2c%255Cle%255Cldots%255Cle%2520T%255Cleft(%255Cfrac%257Bk%257D%257B%255E%257B2%255Ei%257D%257D%255Cright)%252Bic?scale=1"" alt=""LaTeX: T\left(k\right)\le T\left(\frac{k}{2}\right)+c\le T\left(\frac{k}{4}\right)+2c\le\ldots\le T\left(\frac{k}{^{2^i}}\right)+ic"" data-equation-content=""T\left(k\right)\le T\left(\frac{k}{2}\right)+c\le T\left(\frac{k}{4}\right)+2c\le\ldots\le T\left(\frac{k}{^{2^i}}\right)+ic"" data-ignore-a11y-check=""""></p>
<p>Stops when<img class=""equation_image"" title=""\frac{k}{2^i}\le1"" src=""/equation_images/%255Cfrac%257Bk%257D%257B2%255Ei%257D%255Cle1?scale=1"" alt=""LaTeX: \frac{k}{2^i}\le1"" data-equation-content=""\frac{k}{2^i}\le1"" data-ignore-a11y-check="""">, let <img class=""equation_image"" title=""i=\lceil\log_2k\rceil,"" src=""/equation_images/i%253D%255Clceil%255Clog_2k%255Crceil%252C?scale=1"" alt=""LaTeX: i=\lceil\log_2k\rceil,"" data-equation-content=""i=\lceil\log_2k\rceil,"" data-ignore-a11y-check=""""> so <img class=""equation_image"" title=""T\left(k\right)\le T\left(1\right)+c\lceil\log_2k\rceil\le C+c\log_2k=O\left(\log k\right)"" src=""/equation_images/T%255Cleft(k%255Cright)%255Cle%2520T%255Cleft(1%255Cright)%252Bc%255Clceil%255Clog_2k%255Crceil%255Cle%2520C%252Bc%255Clog_2k%253DO%255Cleft(%255Clog%2520k%255Cright)?scale=1"" alt=""LaTeX: T\left(k\right)\le T\left(1\right)+c\lceil\log_2k\rceil\le C+c\log_2k=O\left(\log k\right)"" data-equation-content=""T\left(k\right)\le T\left(1\right)+c\lceil\log_2k\rceil\le C+c\log_2k=O\left(\log k\right)"" data-ignore-a11y-check=""""></p>
<p>Also<img class=""equation_image"" title=""T\left(k\right)\ge c^{\prime}\lfloor\log_2k\rfloor=\Omega\left(\log k\right)"" src=""/equation_images/T%255Cleft(k%255Cright)%255Cge%2520c%255E%257B%255Cprime%257D%255Clfloor%255Clog_2k%255Crfloor%253D%255COmega%255Cleft(%255Clog%2520k%255Cright)?scale=1"" alt=""LaTeX: T\left(k\right)\ge c^{\prime}\lfloor\log_2k\rfloor=\Omega\left(\log k\right)"" data-equation-content=""T\left(k\right)\ge c^{\prime}\lfloor\log_2k\rfloor=\Omega\left(\log k\right)"" data-ignore-a11y-check=""""></p>
<p>Thus<img class=""equation_image"" title=""T\left(K\right)=\Theta\left(\log k\right)"" src=""/equation_images/T%255Cleft(K%255Cright)%253D%255CTheta%255Cleft(%255Clog%2520k%255Cright)?scale=1"" alt=""LaTeX: T\left(K\right)=\Theta\left(\log k\right)"" data-equation-content=""T\left(K\right)=\Theta\left(\log k\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>findK(a, b):</p>
<p>&nbsp; &nbsp; if a == 1: return 0</p>
<p>&nbsp; &nbsp; s = isqrt(a)</p>
<p>&nbsp; &nbsp; if s * s == a: return 2 * findK(s, b)</p>
<p>&nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; t = a / b</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; u = isqrt(t)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return 2 * findK(u, b) + 1</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Henry Yu,579074,UW107R808,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 17:28:13 UTC,00:25:03,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n)=3T(n/5)+O(1)</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2T(n/2) + O(1); comparisons take constant time</p>,0.0,Graded,18157,essay,"<p>n/2^k=1 =&gt; k=log_2(n); there are log_2(n) steps, each with a cost of 1 (for constant operations), so the asymptotic solution is $\Theta(\log n))$.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Base case: if len(A)==2 and A[0] &lt; A[1], then we can return 1 since both arrays must be nonempty, meaning they must both be at least length 1.</p>
<p>Split A[1..n] into two subarrays: A_l and A_r down the middle so that A_l=A[1..n//2] and A_r=[n//2+1..n].</p>
<p>Input: A[1..n]</p>
<p>if len(A) == 2 and A[0] &lt; A[1]: return 1</p>
<p>return recurse(A[1..n//2]) + recurse(A[n//2..n]) + 1</p>
<p>&nbsp;</p>",1.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Sihan Wang,517432,UW995Z371,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 01:58:49 UTC,00:25:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = Theta(1) when n&lt;5</p>
<p>T(n) = 3T(n/5)+ Theta(1) when n &gt;= 5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0) = d, T(1) = d</p>
<p>T(k) = T(k/2)+c for k&gt;=2</p>",1.0,Graded,18157,essay,"<p>T(1) = d = Theta(1), T(0) = d = Theta(1)</p>
<p>T(k) = T(k/2) + c &lt;= T(k/4)+2c &lt;= ... &lt;= T(1) + c*(log2 k)</p>
<p>T(k) = T(1) + c*(log2 k) = Theta(log k)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>findK(a, b):</p>
<p>if a == 1: return 0</p>
<p>if a == b: return 1</p>
<p>c=isqrt(a)</p>
<p>if c*c == a:</p>
<p>return 2*findK(c,b)</p>
<p>else:</p>
<p>t = a/b</p>
<p>d = isqrt(t)</p>
<p>sub = findK(d,b)</p>
<p>return 2*sub + 1</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Ethan Zhuang,549595,UW105A092,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 19:34:51 UTC,00:30:00,1,18054,essay,"<p>T(n) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> 3T(n/2) + cn ; T(1) = 1</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n) + O(1) ; T(1) = 1</p>,0.0,Graded,18157,essay,"<p>n.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</p>
<p>|</p>
<p>n/2&nbsp; &nbsp; &nbsp; &nbsp;1</p>
<p>|</p>
<p>n/4&nbsp; &nbsp; &nbsp; &nbsp; 1</p>
<p>Work done by each level of the recurrence is 1 so T(n) &lt;= <img class=""equation_image"" title=""\sum_{i=0}^k"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255Ek?scale=1"" alt=""LaTeX: \sum_{i=0}^k"" data-equation-content=""\sum_{i=0}^k"" data-ignore-a11y-check=""""> 1 = (k + 1)(1) = k + 1</p>
<p>1 = <img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check=""""> --&gt; k = log_2 n.</p>
<p>log n + 1 = O(log n), which is the solution.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>if a = b: Return b</p>
<p>if b &lt; isqrt(a): return ALG(isqrt(a), b)) + 1&nbsp;</p>
<p>if b &gt; isqrt(a): return ALG(isqrt(a) * b, b) - 1</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Kevin Park,513446,UW099X348,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 18:02:19 UTC,00:18:31,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = O(1) if n &lt;= 2</p>
<p>T(n) = 2T(2n/3) + O(1) if n &gt; 2</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: T(0) = O(1)</p>
<p>For k &gt;= 1: T(k) = T(k/2) + O(1).</p>",1.0,Graded,18157,essay,"<p>Unfold: T(k) = T(k/2) + c</p>
<p>=T(k/2^2) + 2c</p>
<p>=....</p>
<p>=T(1) +c*(log_2k)</p>
<p>Since T(1) = O(1), this gives T(k) = O(log k).</p>
<p>For the lower bound, each level does atleast a constant amount of work and there are (log_2 k)levels, so T(k) = omega(log k)</p>
<p>Therefore. T(k) = O(log k).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Use isqrt(a) to get b^(k/2)</p>
<p>If squaring it equals a, then k is even, so recurse on that value and double the result.</p>
<p>If not, then k is odd. recurse and return twice the result + 1.</p>
<p>Each step halves the exponent, giving O(log k) , faster than O(k)</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Krish Patel,517214,UW980M571,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:03:15 UTC,00:04:28,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>Let T(n) = time to run SuperMax on an array size n</p>
<p>makes 2 recurrsive calls, each on arrays of size n/3</p>
<p>and then it performs a for loop over the first third of A, which will take (n/3) = (n)</p>
<p>T(n) = 2T(n/3) + (n)</p>",2.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"",0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"",0.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.0
Meha Porwal,513258,UW009G377,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:42:17 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n)= n + 1 + T(n/2) + T(n/4) + T(n/4)&nbsp;</p>,2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(k) = T(k/2) + 1(work done for isqrt) + 1(work done to perform final multiplication and addition operation to find k)</p>,1.0,Graded,18157,essay,<p>T(k) = (sum from 1 or 0 to logn ) 1 = log k</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>2 cases, k = 2j, or k = 2j + 1.<br><br>we can have 2 base cases:<br>base case 1 = k = 0. so in this case isqrt(a) will return 1.<br>base case 2 = k=1, and in this case isqrt(a) will return b.<br><br></p>
<p>Divide:<br>isqrt(A) is the divide step, where instead of b^k, we get b^k/2<br><br>Conquer:</p>
<p><br>We know if k = 2j, when we half it we end up with a whole number. an integer ^ integer results in a whole number. If it isn't an integer, then k isn't 2j, and it is an odd number.&nbsp;<br><br>In the case that isqrt performs integer division during k/2, eg 3/2 = 1, we can simply check if k is odd or even by squaring the result of isqrt(a). if the square is equal to a, then it is even, if it is not, then it is odd. In the case that it is odd, we use another variable to keep track of this, and increment the value of that variable by 1 everytime we know that the k value is odd. eg k=3. so after isqrt, k =1. . In the end, to find k value, we multiply 1*2^(num of times isqrt was called -1 ) and add the sum of the number of times we came across an odd value of k. in the case of my example, we do 1*2 + 1 = 3.<br>We can simply count how many times K has been halved(how many times i sqrt has been called till base case has been reached), or subtracted one from, and based on that find the value of k.&nbsp;</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Joseph Prei,502286,UW946S168,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 18:02:57 UTC,00:27:49,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>Where n = the length of A, T(n) = T(n/2) + 2T(n/4) + n.</p>",2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = 2T(k) + 1,&nbsp; &nbsp; for k &gt;= 0</p>
<p>T(1) = 0</p>
<p>T(0) = 0</p>",0.0,Graded,18157,essay,"<p>T(k) = 2T(k/2) + 1 &lt;= 2(2T(k/4) + 1) + 1 &lt;= 2(2(2T(k/8) + 1) + 1) + 1 &lt;= 2^j * T(k/2^j) + j * 1.</p>
<p>Now we need to find when we reach T(1), this happens when k / 2^j = 1 --&gt; k = 2^j --&gt; log(k) = j.</p>
<p>If we plug everything in, we get 2^log(k) * T(k/2^log(k)) + log(k) * 1 --&gt; k*T(1) + log(k) --&gt; k * 0 + log(k) --&gt; O(log(k)).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Algorithm: Power(n, k)</p>
<p>if k = 0, return 1</p>
<p>if k = 1, return n</p>
<p>if k is odd, return Power(n, (k + 1) / 2) * Power(n, k - ((k + 1) / 2))</p>
<p>if k is even, return Power(n, k / 2) * Power(n, k / 2)</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Samantha RABY,481941,UW971G825,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 19:57:25 UTC,00:29:32,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(2n/3) + O(1), T(1) = 1, T(2) = 2</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + O(1), T(0) = 1</p>",0.0,Graded,18157,essay,"<p>T(n) = 2T(n/2) + O(1), T(0) = 1</p>
<p>T(n) = 2(2T(n/4) + O(1)) + O(1)</p>
<p>T(n) = 2(2(2T(n/8) + O(1)) + O(1)) + O(1)</p>
<p>n/2<sup>k</sup> = 1 is the total work at each level</p>
<p>n = 2<sup>k</sup> , k = log<sub>2</sub> (n). This means that T(n) solves to log<sub>2&nbsp;</sub>(n) + O(1), so T(n) is O(log(n)).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Same inputs as the brute force algorithm, same bounds.</p>
<p>Output is the overall power, or n<sup>k</sup></p>
<p>base case: if k = 0: return 1</p>
<p>if k | 2, return n * n * algo(n, (k/2) - 1) * algo(n, (k/2) - 1)</p>
<p>else return n * (algo(n, (k-1)/2) * algo(n, (k-1),/2)</p>
<p>end</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Peter Ranchero,431551,UW936E196,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 16:59:56 UTC,00:25:10,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>Recurrence: <img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2}\right)+2T\left(\frac{n}{4}\right)+\Theta\left(n\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252B2T%255Cleft(%255Cfrac%257Bn%257D%257B4%257D%255Cright)%252B%255CTheta%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2}\right)+2T\left(\frac{n}{4}\right)+\Theta\left(n\right)"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2}\right)+2T\left(\frac{n}{4}\right)+\Theta\left(n\right)"" data-ignore-a11y-check=""""></p>
<p>Runtime: O(nlog(n))</p>",2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: T(x) = O(1)</p>
<p>Recursive case: T(x) = T(x/2) + O(1)</p>",1.0,Graded,18157,essay,"<p>T(x) = <img class=""equation_image"" title=""T\left(\frac{x}{2^k}\right)+ek"" src=""/equation_images/T%255Cleft(%255Cfrac%257Bx%257D%257B2%255Ek%257D%255Cright)%252Bek?scale=1"" alt=""LaTeX: T\left(\frac{x}{2^k}\right)+ek"" data-equation-content=""T\left(\frac{x}{2^k}\right)+ek"" data-ignore-a11y-check=""""></p>
<p>stop when <img class=""equation_image"" title=""\frac{x}{2^k}=0"" src=""/equation_images/%255Cfrac%257Bx%257D%257B2%255Ek%257D%253D0?scale=1"" alt=""LaTeX: \frac{x}{2^k}=0"" data-equation-content=""\frac{x}{2^k}=0"" data-ignore-a11y-check=""""> when k = <img class=""equation_image"" title=""\log_2x"" src=""/equation_images/%255Clog_2x?scale=1"" alt=""LaTeX: \log_2x"" data-equation-content=""\log_2x"" data-ignore-a11y-check=""""></p>
<p>then T(x) = T(0) + e <img class=""equation_image"" title=""\log_2x"" src=""/equation_images/%255Clog_2x?scale=1"" alt=""LaTeX: \log_2x"" data-equation-content=""\log_2x"" data-ignore-a11y-check=""""> = <img class=""equation_image"" title=""\Theta\left(1\right)+\Theta\log x=\Theta\left(\log x\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)%252B%255CTheta%255Clog%2520x%253D%255CTheta%255Cleft(%255Clog%2520x%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)+\Theta\log x=\Theta\left(\log x\right)"" data-equation-content=""\Theta\left(1\right)+\Theta\log x=\Theta\left(\log x\right)"" data-ignore-a11y-check=""""></p>
<p>&nbsp;</p>
<p>lower Bound: T(x) = elog(x) , there is a constant at each level</p>
<p>Bound: T(x) = <img class=""equation_image"" title=""\Theta\log x"" src=""/equation_images/%255CTheta%255Clog%2520x?scale=1"" alt=""LaTeX: \Theta\log x"" data-equation-content=""\Theta\log x"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"<p>1. Base case: if the exp = 0 then return 1.</p>
<p>2. Recursuve case:&nbsp;</p>
<ul>
<li>if x is even, first compute <img class=""equation_image"" title=""e^{\frac{x}{2}}"" src=""/equation_images/e%255E%257B%255Cfrac%257Bx%257D%257B2%257D%257D?scale=1"" alt=""LaTeX: e^{\frac{x}{2}}"" data-equation-content=""e^{\frac{x}{2}}"" data-ignore-a11y-check=""""> recursivly. Then square the results at the end. (<img class=""equation_image"" title=""e^x=\left(e^{\frac{x}{2}}\right)^2"" src=""/equation_images/e%255Ex%253D%255Cleft(e%255E%257B%255Cfrac%257Bx%257D%257B2%257D%257D%255Cright)%255E2?scale=1"" alt=""LaTeX: e^x=\left(e^{\frac{x}{2}}\right)^2"" data-equation-content=""e^x=\left(e^{\frac{x}{2}}\right)^2"" data-ignore-a11y-check="""">)</li>
<li>if x is odd, compute <img class=""equation_image"" title=""e^{\frac{x}{2}}"" src=""/equation_images/e%255E%257B%255Cfrac%257Bx%257D%257B2%257D%257D?scale=1"" alt=""LaTeX: e^{\frac{x}{2}}"" data-equation-content=""e^{\frac{x}{2}}"" data-ignore-a11y-check=""""> recursivly. Then square the results and then multiply by e again at the end. (<img class=""equation_image"" title=""e^x=\left(e^{\frac{x}{2}}\right)^2\cdot e"" src=""/equation_images/e%255Ex%253D%255Cleft(e%255E%257B%255Cfrac%257Bx%257D%257B2%257D%257D%255Cright)%255E2%255Ccdot%2520e?scale=1"" alt=""LaTeX: e^x=\left(e^{\frac{x}{2}}\right)^2\cdot e"" data-equation-content=""e^x=\left(e^{\frac{x}{2}}\right)^2\cdot e"" data-ignore-a11y-check="""">)</li>
</ul>
<p>return result</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Aditya Rawat,521444,UW999E790,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:22:00 UTC,00:17:40,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=2T\left(\frac{n}{3}\right)+O\left(n\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253D2T%255Cleft(%255Cfrac%257Bn%257D%257B3%257D%255Cright)%252BO%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=2T\left(\frac{n}{3}\right)+O\left(n\right)"" data-equation-content=""T\left(n\right)=2T\left(\frac{n}{3}\right)+O\left(n\right)"" data-ignore-a11y-check=""""> for <img class=""equation_image"" title=""n>2,T\left(n\right)=O\left(1\right)"" src=""/equation_images/n%253E2%252CT%255Cleft(n%255Cright)%253DO%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: n>2,T\left(n\right)=O\left(1\right)"" data-equation-content=""n>2,T\left(n\right)=O\left(1\right)"" data-ignore-a11y-check="""">&nbsp;for <img class=""equation_image"" title=""n\le2"" src=""/equation_images/n%255Cle2?scale=1"" alt=""LaTeX: n\le2"" data-equation-content=""n\le2"" data-ignore-a11y-check=""""></p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""T(n)=T\left(\frac{n}{2}\right)+O\left(1\right)"" src=""/equation_images/T(n)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252BO%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T(n)=T\left(\frac{n}{2}\right)+O\left(1\right)"" data-equation-content=""T(n)=T\left(\frac{n}{2}\right)+O\left(1\right)"" data-ignore-a11y-check="""">, <img class=""equation_image"" title=""T\left(1\right)=O\left(1\right)"" src=""/equation_images/T%255Cleft(1%255Cright)%253DO%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(1\right)=O\left(1\right)"" data-equation-content=""T\left(1\right)=O\left(1\right)"" data-ignore-a11y-check=""""></p>",1.0,Graded,18157,essay,"<p>Unroll: <img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2}\right)+c=T\left(\frac{n}{4}\right)+2c=T\left(\frac{n}{8}\right)+3c"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252Bc%253DT%255Cleft(%255Cfrac%257Bn%257D%257B4%257D%255Cright)%252B2c%253DT%255Cleft(%255Cfrac%257Bn%257D%257B8%257D%255Cright)%252B3c?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2}\right)+c=T\left(\frac{n}{4}\right)+2c=T\left(\frac{n}{8}\right)+3c"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2}\right)+c=T\left(\frac{n}{4}\right)+2c=T\left(\frac{n}{8}\right)+3c"" data-ignore-a11y-check=""""></p>
<p>After k steps: <img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2^k}\right)+kc"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%255Ek%257D%255Cright)%252Bkc?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2^k}\right)+kc"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2^k}\right)+kc"" data-ignore-a11y-check=""""></p>
<p>Stopping when <img class=""equation_image"" title=""\frac{n}{2^k}=1\to2^k=n\to k=\log_2\left(n\right)"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D%253D1%255Cto2%255Ek%253Dn%255Cto%2520k%253D%255Clog_2%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: \frac{n}{2^k}=1\to2^k=n\to k=\log_2\left(n\right)"" data-equation-content=""\frac{n}{2^k}=1\to2^k=n\to k=\log_2\left(n\right)"" data-ignore-a11y-check=""""></p>
<p>Finally, <img class=""equation_image"" title=""T\left(n\right)=T\left(1\right)+c\log_2\left(n\right)=\Theta\left(\log\left(n\right)\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(1%255Cright)%252Bc%255Clog_2%255Cleft(n%255Cright)%253D%255CTheta%255Cleft(%255Clog%255Cleft(n%255Cright)%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(1\right)+c\log_2\left(n\right)=\Theta\left(\log\left(n\right)\right)"" data-equation-content=""T\left(n\right)=T\left(1\right)+c\log_2\left(n\right)=\Theta\left(\log\left(n\right)\right)"" data-ignore-a11y-check=""""></p>
<p>Thus, the algorithm runs in <img class=""equation_image"" title=""\Theta\left(\log\left(n\right)\right)"" src=""/equation_images/%255CTheta%255Cleft(%255Clog%255Cleft(n%255Cright)%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(\log\left(n\right)\right)"" data-equation-content=""\Theta\left(\log\left(n\right)\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Input: A[1...n]</p>
<p>begin</p>
<p style=""padding-left: 40px;"">low = 1, high = n - 1</p>
<p style=""padding-left: 40px;"">while low &lt; high:</p>
<p style=""padding-left: 80px;"">mid = (low + high + 1) // 2</p>
<p style=""padding-left: 80px;"">if A[mid] &lt; A[mid + 1]:</p>
<p style=""padding-left: 120px;"">low = mid</p>
<p style=""padding-left: 80px;"">else if A[mid] &gt; A[mid + 1]:</p>
<p style=""padding-left: 120px;"">high = mid - 1</p>
<p style=""padding-left: 80px;"">end</p>
<p style=""padding-left: 40px;"">end</p>
<p style=""padding-left: 40px;"">return low</p>
<p>end</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Benjamin Russell,483805,UW977A311,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 22:44:50 UTC,00:28:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(N) = T(n/5) + T(4n/5) + T(3n/5) + n<br>T(5) = 1</p>,1.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + 1</p>
<p>T(0) = 1&nbsp;</p>",1.0,Graded,18157,essay,"<p>Given T(n) = T(n/2) + 1, then means we get one child at each level of n/2 size with constant work being done on each of those levels.&nbsp;<br>Levels: root exp size of n (same as x)&nbsp;<br>level 1: n/2 + c&nbsp;&nbsp;<br>level 2: 1 more child of n/4&nbsp;<br>level 3: another child of n/8&nbsp;<br>....&nbsp;<br>level k : n/2^k with constant work&nbsp;<br><br>height h : n/(2^h) = 1 -&gt; n = 2^h -&gt; h = log2(n)&nbsp;&nbsp;<br><br>Total run time = amount of levels x work per level&nbsp;<br>log2(n) levels * c work per level&nbsp;<br>= clog2(n) -&gt; O(clog(n) -&gt; cO(logn) -&gt; O(logn)&nbsp;</p>",2.0,Graded,25540,essay,"<p>def func e_exponent (x) : <br>&nbsp;input x: Exponent x &gt;= 0.&nbsp;<br>Output: exp: the value of e^x<br>begin:&nbsp;</p>
<p># base<br>base case: if x = 0:&nbsp;</p>
<p>return 1&nbsp;<br># divide<br>recursive case:&nbsp;<br>mid = e_exponent(x // 2)&nbsp;<br>if x % 2 == 0 :&nbsp;</p>
<p>return mid * mid&nbsp;<br>else: # meaning x is odd&nbsp;<br>return e * mid * mid</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Leonardo Schiro,425226,UW931T420,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:25:34 UTC,00:25:55,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>A(n) = A(1n/5) + (3n/5) + (4n/5) + n<sup>3</sup>&nbsp; &nbsp; &nbsp; &nbsp;Base case: length(A) &lt; 5 = A(n).&nbsp;</p>,0.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>A(n) = 2A(n/2) + n. Base case: A(1) = 1.&nbsp;</p>,0.0,Graded,18157,essay,"<p>A(n) = 2A(n/2) + n. This means we start with n/2, and unroll by a factor of n. Each time we unroll, we double the layer from before. This makes the reccurence O(n).&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Base case: n = 1, return A[1]</p>
<p>Divide: Divide A[i] into two list, L and R. Check if the last element in L is less than K. If false, divide L again and continue this until you find L[i] &lt; K. If true, check if the first element in R is &gt; K. If false, divide R again and continue until you find R[i] &gt; K.</p>
<p>Merge: We must continue searching both L and R until finding the maximum value greater than K.</p>
<ul>
<li>If the rightmost element in L &lt; K, check R.</li>
<li>If the rightmost element&nbsp; in L &gt; K, divide L again into L1, L2,...Ln until finding the rightmost element &gt; K.</li>
<li>If the last element in L &lt; K, check R, and see if the leftmost value in R &lt; K. If so, continue dividing R until the leftmost value &gt; K.</li>
</ul>
<p>Return the rightmost value in L &gt; K - 1 if checking L, return R &gt; K - 1 if checking R.</p>",1.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.5
Caden Schmear,481210,UW916K922,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 03:48:05 UTC,00:28:50,1,18054,essay,"<p>T(n) = 3T(n/2) + 2cn + d &lt; 3T(n/2) + kn</p>
<p>T(1) = 1</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(<img class=""equation_image"" title=""\lfloor\frac{n}{2}\rfloor"" src=""/equation_images/%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor?scale=1"" alt=""LaTeX: \lfloor\frac{n}{2}\rfloor"" data-equation-content=""\lfloor\frac{n}{2}\rfloor"" data-ignore-a11y-check="""">) + c</p>
<p>T(0) = 1</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n) = T(n/4) + c + c</p>
<p>T(n) = T(n/8) + c + c + c</p>
<p>T(1) occurs when 1 = n/(2^k), with k being the recursion depth, therefore to reach T(1), we must recurse logn + 1 times. When T(1) is reached, it will always take one additional recusion to reach T(0) because DivideExp(1) will always call DivideExp(0) due to 1 being odd. Therefore, we have recursed logn + 2 times, and each recursion has a cost of c, except the final T(0) recusion, which has a cost of 1. Thus,</p>
<p>T(n) = (logn + 1)c + 1 = clogn + c + 1 = O(logn)</p>",2.0,Graded,25540,essay,"<p>Algorithm: DivideExp</p>
<p>Input: x: Exponent x &gt;= 0</p>
<p>Output: exp: The value e^x</p>
<p>If x equals 0, return 1</p>
<p>If x is even:</p>
<p>&nbsp; &nbsp; half = DivideExp(x/2)</p>
<p>&nbsp; &nbsp; return half * half</p>
<p>endif</p>
<p>if x is odd:</p>
<p>&nbsp; &nbsp; half = DivideExp((x-1)/2)</p>
<p>&nbsp; &nbsp; return half*half*e</p>
<p>endif</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Anthony Sestito,503629,UW980U453,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 18:35:29 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=2T\left(\frac{n}{4}\right)+"" src=""/equation_images/T%255Cleft(n%255Cright)%253D2T%255Cleft(%255Cfrac%257Bn%257D%257B4%257D%255Cright)%252B?scale=1"" alt=""LaTeX: T\left(n\right)=2T\left(\frac{n}{4}\right)+"" data-equation-content=""T\left(n\right)=2T\left(\frac{n}{4}\right)+"" data-ignore-a11y-check=""""> <img class=""equation_image"" title=""c"" src=""/equation_images/c?scale=1"" alt=""LaTeX: c"" data-equation-content=""c"" data-ignore-a11y-check="""">; <img class=""equation_image"" title=""T\left(\left|A\right|<4\right)=0"" src=""/equation_images/T%255Cleft(%255Cleft%257CA%255Cright%257C%253C4%255Cright)%253D0?scale=1"" alt=""LaTeX: T\left(\left|A\right|<4\right)=0"" data-equation-content=""T\left(\left|A\right|<4\right)=0"" data-ignore-a11y-check=""""></p>",2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2}\right)+c;T\left(k\right)=0"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252Bc%253BT%255Cleft(k%255Cright)%253D0?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2}\right)+c;T\left(k\right)=0"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2}\right)+c;T\left(k\right)=0"" data-ignore-a11y-check="""">, where k=number returned from base case.&nbsp;</p>",1.0,Graded,18157,essay,"<p>The input for the recurrence follows the pattern of <img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check=""""> since each input is dividing that half into another half. This pattern causes the runtime of <img class=""equation_image"" title=""O\left(\log n\right)"" src=""/equation_images/O%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: O\left(\log n\right)"" data-equation-content=""O\left(\log n\right)"" data-ignore-a11y-check="""">. Since the only other work outside of recurrences we have to do is comparisons (which are constant time operations), then the final asymptotic solution is <img class=""equation_image"" title=""O\left(\log n\right)"" src=""/equation_images/O%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: O\left(\log n\right)"" data-equation-content=""O\left(\log n\right)"" data-ignore-a11y-check=""""></p>
<p>&nbsp;</p>
<p><img class=""equation_image"" title=""\sum_{i=0}^n\frac{n}{2^i}=\log_2n=O\left(\log n\right)"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255En%255Cfrac%257Bn%257D%257B2%255Ei%257D%253D%255Clog_2n%253DO%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: \sum_{i=0}^n\frac{n}{2^i}=\log_2n=O\left(\log n\right)"" data-equation-content=""\sum_{i=0}^n\frac{n}{2^i}=\log_2n=O\left(\log n\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>The divide and conquer algorithm for this problem will be like a binary search.</p>
<p>Divide: Take a list of n points that are sorted in increasing numerical order and split it in half</p>
<p>Conquer: Start at the middle value of the whole list, and then recurse either on the middle of the left half or the middle of the right half depending on the result of the comparison. If the higher half will get you an A and the lower half will also get you an A, then recurse on the lower half (left). If the higher half will get you an A and the lower half will not get you an A, then recurse on the higher half (right). Keep comparing and recursing unitl you hit the base case where the lower half won't get you an A and the higher half will but your current choice also gets you an A.&nbsp;&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
JACKSON SPRENGER,417971,UW877B153,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 22:26:55 UTC,00:23:22,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = T (n/2) + 2 * T(n/4) where T(1) = O(n)</p>,1.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(log(n)) + cn where T(1) = 1</p>,0.0,Graded,18157,essay,<p>T(log(n))+ cn --&gt; T(T( log(n)/2 + (cn)/2) + cn --&gt; T(T(T( log(n)/4 + (cn)/4) + cn where 1 = log(n)/2^k&nbsp; -&gt; 2^k = log(n) -&gt; k = log(log(n)) which gives us the formula: T(log(n)) + kcn -&gt; log(log(n))cn + log(n) which gives us O(log(n)).&nbsp;</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>r = 0</p>
<p>while&nbsp; GetsService(r) == False do</p>
<p>&nbsp; &nbsp; &nbsp;r = (n - r)/2&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;end</p>
<p>&nbsp; &nbsp; &nbsp;return r</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Jaan Srimurthy,570924,UW106E865,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 21:45:42 UTC,00:22:22,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>T(n) = cn (linear search) + d (swap) + T(n/2) (shuffling second half) + T(n/4) (shuffle first quarter) + T(n/4) (shuffle second quarter); T(1) = k (conditional statement);</p>
<p>Or T(n) = T(n/2) + 2T(n/4) + cn + d; T(1) = k;</p>",3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = c (ifs, arithmetic operations). T(n) = T(n/2) (each run of the while loop cuts the searchable array in half) + d(ifs, arithmetic operations)</p>",1.0,Graded,18157,essay,<p>T(n) = T(n/2) + d = T(n/4) + 2d = ... = T(n/2^{log_2 n}) + (log_2 n)d = T(1) + (log_2 n)d = c + (log_2 n)d = O(log n)</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Let r be the ideal range. Then A[1...r] = True (your friend is happy), A[r+1 ... n] = False (he does not get reception).</p>
<p>Also WLOG let A[n + 1] = False so that the algorithm can index it and so I do not have to do base case stuff.</p>
<p>This does not affect r since A[n + 1] is False and A[r] = True</p>
<p>&nbsp;</p>
<p>low = 1, high = n</p>
<p>while(low &lt;= high) {</p>
<p>&nbsp; i = (low + high)//2</p>
<p>&nbsp; if (A[i] = True and A[i + 1] = False) { return i; } // i is the ideal range</p>
<p>&nbsp; else {</p>
<p>&nbsp; &nbsp; if (A[i] = True) { low = i; } // A[i + 1] must also be true, so we increase the lower bound, since r &gt; i</p>
<p>&nbsp; &nbsp; else { high = i; } // A[i] is False, so we decrease the upper bound since r &lt; i</p>
<p>&nbsp; }</p>
<p>}</p>
<p># Since low &lt;= high, low &lt;= i = (low + high)//2 &lt;= high</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Benjamin Stroeher,360495,UW971U187,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 02:19:55 UTC,00:12:45,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>T(n) = 2*T(⅔) + 1</p>
<p>&nbsp;</p>",2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2*T(n/2) + 1</p>,0.75,Graded,18157,essay,"<p>T(1) = 2*T(n/2) + 1</p>
<p>T(2) = 2*(T(n/4) + 1) + 1</p>
<p>T(3) = 4*(T(n/8)+ 1) + 3</p>
<p>T(n) = 2*T(n/2) + 7</p>
<p>Therefore T(n) = O(log(n))</p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>length(A[1...n]){</p>
<p>&nbsp; &nbsp; &nbsp;if(A[n/2] &lt; A[n/2 + 1] &amp;&amp; A[n/2 + 1] &gt; A[n/2 + 2]){</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return n/2;</p>
<p>&nbsp; &nbsp; }&nbsp;</p>
<p>&nbsp; &nbsp; else if(A[n/2] &lt; A[n/2 + 1] &amp;&amp; A[n/2 + 1] &lt; A[n/2 + 2]){</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return(n/2 + Length(A[n/2...n]);</p>
<p>&nbsp; &nbsp; &nbsp;} else{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return(n/2 - Length(A[1,n/2]);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>",2.5,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.75
Yoshi SUZUKI,517639,UW102V506,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 12:33:28 UTC,00:29:59,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) &lt;= T(n/2) + 2T(n/4) + cn</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) &lt;= 2T(n/2) + c, T(k) = c where k is the optimized distance.&nbsp;</p>",0.75,Graded,18157,essay,"<p>Recurrence relation can be divided into constant part (cn) and recursive part(2T(n/2) ).&nbsp;</p>
<p>So by creating tree, we see that there will be binary tree with the sum of each layer have the running time of constant.&nbsp;</p>
<p>we know that tree will have log(2) n&nbsp; layers.&nbsp;</p>
<p>There for T(n) &lt;= log(2) n * cn = O(logn)</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>&nbsp;</p>
<p>Algorithm (i, n): where n is the number defined in problem.&nbsp;</p>
<p>r&nbsp; = (i + n) / 2</p>
<p>if(GetsService(r) == True&nbsp;<strong>AND</strong> GetsService(r - 1) == False): return r.</p>
<p>if (GetsService(r) == false): call Algorithm(n/2, n)</p>
<p>if(GetsService(r) == True): call Algorithm(0, n/2)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Call Algorithm(0, n)</p>
<p>&nbsp;</p>
<p>Idea: since the problem can be seen as finding the kth value of integer list 1 to n. We can use bubble search like algorithm. But to make sure we find the optimized distance, we need to check if the r - 1 is false, which takes constant time.&nbsp;<br><br></p>",2.5,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.25
Max ZEAMAN,502153,UW876V320,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 20:35:14 UTC,00:23:45,1,18054,essay,<p>T(N) = T(n/2) + T(n/2) + A</p>,0.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: T(1) = 1</p>
<p>T(N) = T(n/2) + T(n/2) + 3</p>",0.0,Graded,18157,essay,"<p>T(1)= 0</p>
<p>T(2) = 3</p>
<p>T(4) = 3 + 6</p>
<p>T(8) = 3 + 20</p>
<p>T(N) = O(3n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>recursiveMultiple (int base, int power) {</p>
<p>&nbsp; &nbsp; &nbsp;if (power == 0) return 1;</p>
<p>&nbsp; &nbsp; &nbsp;if (power == 1) return base;</p>
<p>&nbsp; &nbsp; else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; int midPoint = power /2;&nbsp; &nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return recursiveMultiple(base, midPoint)&nbsp; &nbsp; *&nbsp; &nbsp; recursiveMultiply(base, power - midPoint)</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>}</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Ryan Unruh,570553,UW107F070,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 21:10:02 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2(2n/3) + n, T(1) = 1</p>",1.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + 1, T(1) = 1</p>",1.0,Graded,18157,essay,"<p>Recurrence Tree</p>
<p>First level 1, total cost c</p>
<p>Second level two 1/2, total cost c</p>
<p>Thrid level four 1/4, total cost c</p>
<p>kth level 2^k-1 1/2^k, total cost c</p>
<p>Summation from i = 0 to k for1/2^i</p>
<p>k is treelength which is log base 2 of n in this case</p>
<p>Asymptoic solution is O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Let A be a sorted array with all possible point values</p>
<p><span style=""font-family: inherit; font-size: 1rem;"">MergeTester(A)</span></p>
<p>Basecase: If there is only 1 value left in A return that value</p>
<p>Divide: If A[A.length/2] returns negative call MergeTest on the second half of A</p>
<p>If A[A.length/2] returns postive call MergeTest on the first half of A and store in n</p>
<p>Merge: Call&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.0
Tony WEI,521203,UW099Y117,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 20:28:45 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(<img class=""equation_image"" title=""\frac{2n}{3}"" src=""/equation_images/%255Cfrac%257B2n%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{2n}{3}"" data-equation-content=""\frac{2n}{3}"" data-ignore-a11y-check="""">) + cn, T(1) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> c</p>",1.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>We split into 2 halves, so n/2.</p>
<p>Worst case: the last element is the the first (index = 1) or last (index = n) element of A.</p>
<p>T(n) = T(n/2) + T(n/2^n) + cn, T(2) &lt;= c</p>",0.0,Graded,18157,essay,"<p>n/2^k + n</p>
<p>n/2^n = 1</p>
<p>n = 2^n</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Input: A[1 . . . n]</p>
<p>Output: The number of elements in A_1</p>
<p>BC: n = 2, then return A_1 = 1.</p>
<p>Divide: Split the array A into half, L and R, each with sizes n/2.&nbsp;</p>
<p>i = 1</p>
<p>If A[<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">] &lt; A[<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">+1], then the last element of A_1 is in R, so we call the algorithm recursively on R.</p>
<p>If A[<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">] &gt; A[<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check=""""> + 1], then the last element of A_1 is in L, so we call the algorithm recursively on L.</p>
<p>Like that, we recursively find the last element of A_1. The number of elements in A_1 is then the index of the last element.</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.5
Aaron Wenninger,517322,UW988H189,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 20:30:41 UTC,00:20:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2T(n/3) + c*(n/3)</p>
<p>T(1) = c</p>",2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>T(1) = O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c = T(n/4) + 2c = T(n/8) + 3c = T(n/2^k) + kc</p>
<p>n/2^k = 1&nbsp; -&gt; k = log2(n)</p>
<p>T(n) = T(1) + c*log2(n)</p>
<p>T(n) = O(log n) + O(1) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<ul>
<li>Set two integer variables, low = 0 and high = n, representing the current search interval. Also set a variable result n which will store the smallest range found so far that gives service</li>
<li>get the midpoint of low and high and run GetService(mid) to check whether the friend recieves a signal at that range</li>
<li>run a binary search where if the result is true we search the left half and if it is false we search the right half</li>
<li>go until low is &gt;= to high and result will contain the smallest vallue of r for which GetService(r) is true</li>
<li>return result</li>
</ul>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
William Wong,521432,UW998D080,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 16:43:10 UTC,00:17:48,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>Base Case: T(n) = O(1)&nbsp;</p>
<p>Recurrence: T(n) = T(n/2) + 3T(n/4) + O(n)&nbsp;</p>",1.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Here we can use a divide and conquer algorithm such as a binary search implementation which has a O(logn) time complexity --&gt; faster than O(n) :</p>
<p>Function(A, low, high):</p>
<p>// Then within the function we have:&nbsp;</p>
<p>if low == high {</p>
<p>&nbsp; &nbsp;return low;</p>
<p>}</p>
<p>mid = (low + high) / 2</p>
<p>if the routine here runs in under 1 second on the middle cores {</p>
<p>then we can return the function with (A, low, high)</p>
<p>} else {</p>
<p>we can return the function with (A, middle + 1, high)</p>
<p>}</p>",3.0,Graded,18156,essay,"<p>Here the base case is: T(n) = O(1)&nbsp;</p>
<p>Recurrence Relation is: T(n/2) + O(1)&nbsp;</p>",1.0,Graded,18157,essay,<p>What we can do here is we know that the recurrence relation is T(n/2^k) + O(1). We wnat to keep recursively unwinding the tree such that n/2^k = 1. Here we get n = 2^k. And k = log2n. Since k = log2n we know that the answer to the recurrence relation is O(logn).&nbsp;</p>,1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.5
Haozhe Yang,254319,UW853M254,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 03:33:31 UTC,00:45:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,<p>T(n) = 2T(n/3) + O(n)</p>,2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) +O(1)&nbsp;</p>,0.0,Graded,18157,essay,"<p>T(n) = T(n/2) +O(1)</p>
<p>&nbsp; &nbsp; &nbsp;=&nbsp; T(n/4) + 2 * O(1)</p>
<p>thus this is&nbsp; T(n/2^k) + k* O(1) where k is the height&nbsp;</p>
<p>The first term is constant and the last since k is logn</p>
<p>2^k = n&nbsp; k = logn</p>
<p>thus the running tme is O(logn)</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>the function will return a vallue r</p>
<p>function input a integer which is r as a range of cell tower</p>
<p>Base case: if r = 1 return 1</p>
<p>if friedn can receive the signal :(by using the getserive function to check the true or false r = Service(r/2)&nbsp; every time the input need to be an integer</p>
<p>else&nbsp; r = Servie(3r/4)</p>
<p>return r</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Justin YEUNG,499340,UW923E192,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 21:29:12 UTC,00:29:56,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = 3T(n/5) + O(1)</p>
<p>T(1) = 5</p>
<p>Runtime complexity: O(n<sup>log<sub>3</sub>5</sup>)</p>",2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Runtime: O(log n)</p>
<p>T(n) = T(n/2) + n</p>
<p>T(1) = 1</p>",0.5,Graded,18157,essay,"<p>Runtime: O(log n)</p>
<p>Use Recurrsion tree:</p>
<p>1st level: n</p>
<p>2nd level: n/2,</p>
<p>3rd level: n/4</p>
<p>k level: n/2<sup>k</sup></p>
<p>Total work: n + n/2 + n/4 + n/8 + ... + n/2<sup>k</sup></p>
<p>Sum of work = i = 0 { k - 1 = 2<sup>i&nbsp;</sup>* n/2<sup>k</sup></p>
<p>= 2<sup>i</sup>/2<sup>k&nbsp;</sup>* n</p>
<p>= log n</p>
<p>Therefore, the runtime of this algo is O(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>// binary search type algo.</p>
<p>Algo: BinarySearch(low, high)</p>
<p>Input: A, k</p>
<p>begin</p>
<p>if A[1] &gt; k; return ""None""</p>
<p>else:</p>
<p>mid = (high + low) //2</p>
<p>if A[mid] &lt; k: BinarySearch(mid + 1, high)</p>
<p>if A[mid] &gt; k:&nbsp;</p>
<p>if A[mid - 1] &lt; k: return A[mid - 1]</p>
<p>&nbsp; &nbsp; else: BinarySearch(low, mid - 1)</p>
<p>if A[mid] == k: return A[mid]</p>
<p>return ""None""</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Jake Yun,500187,UW009E285,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:42:44 UTC,00:28:06,1,18054,essay,"<p>For T(n) where n is the length of the array A</p>
<p>T(n) = 3(n/2) + cn, T(1) &lt;= c</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>For an array of length n</p>
<p>T(n) = T(n/2) + c, T(1) &lt;= c</p>",1.0,Graded,18157,essay,"<p>We can use a recurrence tree, which is hard to draw here...</p>
<p>The tree layers are based on the input size, so it will be</p>
<p>n -&gt; n/2 -&gt; n/4 -&gt; ... 1, where there are k layers</p>
<p>For each layer in the recurrence tree, the work done is constant because we are just indexing the array once and comparing once, so the runtime can be represented in sigma notation as&nbsp;</p>
<p><img class=""equation_image"" title=""\sum_{i=1}^kc"" src=""/equation_images/%255Csum_%257Bi%253D1%257D%255Ekc?scale=1"" alt=""LaTeX: \sum_{i=1}^kc"" data-equation-content=""\sum_{i=1}^kc"" data-ignore-a11y-check=""""> = kc = c(logn + 1) = clogn + c</p>
<p>where k = logn + 1 with base two because the input size halves on every recursion.</p>
<p>We can drop the +c since it does not scale with the clogn, and this means the asymptotic solution is O(logn)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>better_algo(A, k) {</p>
<p>if ( A is null or empty or A[n] &lt; k) { return None }</p>
<p>index = bin_search(A, k, 1, n)</p>
<p>return A[index]</p>
<p>}</p>
<p>bin_search(A, k, low, high) {</p>
<p>if (low &gt; high) return low</p>
<p>mid = floor((low + high) / 2)</p>
<p>if (A[mid] &gt;= k) { return bin_search(A, k, low, mid - 1) }</p>
<p>else { return bin_search(A, k, mid + 1, high) }</p>
<p>}</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Yanxin Zhang,578613,UW109O985,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 20:46:56 UTC,00:13:47,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = O(1)&nbsp; &nbsp;n&lt;=2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2T(n/3) + O(n) n&gt;2</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>assume T(k) is the multi times to compute the n^k,</p>
<p>for even k, T(k) = T(k/2) +1&nbsp;</p>
<p>for odd k, T(k) = T([k/2]) +2</p>
<p>so we can know the upper bound is T(k) = T([k/2]) +2</p>
<p>so T(k) is O (log k)</p>",1.0,Graded,18157,essay,"<p>We can solve this by repeated expansion:</p>
<p>T(k) &lt;= T(k/2) +2</p>
<p>&lt;= T(k/4)+2 + 2</p>
<p>...</p>
<p>&lt;= T(1) +2 log2(k)</p>
<p>Assuming T(1) = 1, we obtain T(k) &lt;= 1 + 2 log2(k) =O(logk)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Input: n, k</p>
<p>Output: n*k</p>
<p>begin</p>
<p>&nbsp; if k == 0 then return 1</p>
<p>&nbsp; else if k is even then temp &lt;- power (n, k/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return temp * temp</p>
<p>&nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp &lt;- power (n, [k/2])</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return n * temp *temp</p>
<p>end</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Zhibo Zhang,428731,UW933T246,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 20:52:37 UTC,00:29:28,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>Let T(n) be the run time on an array of size n.</p>
<p>Work per call: scan to find max = O(n); one swap = O(1)</p>
<p>Recursive subcalls on sizes <img class=""equation_image"" title=""\frac{n}{2},\frac{n}{4}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D%252C%255Cfrac%257Bn%257D%257B4%257D?scale=1"" alt=""LaTeX: \frac{n}{2},\frac{n}{4}"" data-equation-content=""\frac{n}{2},\frac{n}{4}"" data-ignore-a11y-check="""">, and <img class=""equation_image"" title=""\frac{n}{4}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B4%257D?scale=1"" alt=""LaTeX: \frac{n}{4}"" data-equation-content=""\frac{n}{4}"" data-ignore-a11y-check=""""></p>
<p>so the recurrense is<img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2}\right)+2T\left(\frac{n}{4}\right)+O\left(n\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252B2T%255Cleft(%255Cfrac%257Bn%257D%257B4%257D%255Cright)%252BO%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2}\right)+2T\left(\frac{n}{4}\right)+O\left(n\right)"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2}\right)+2T\left(\frac{n}{4}\right)+O\left(n\right)"" data-ignore-a11y-check="""">, Base case <img class=""equation_image"" title=""T\left(1\right)=O\left(1\right)"" src=""/equation_images/T%255Cleft(1%255Cright)%253DO%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(1\right)=O\left(1\right)"" data-equation-content=""T\left(1\right)=O\left(1\right)"" data-ignore-a11y-check=""""></p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Let T(n) be the running time on size n. Each call does O(1) work and recurses on at most [<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">]</p>
<p><img class=""equation_image"" title=""T\left(1\right)=O\left(1\right)"" src=""/equation_images/T%255Cleft(1%255Cright)%253DO%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(1\right)=O\left(1\right)"" data-equation-content=""T\left(1\right)=O\left(1\right)"" data-ignore-a11y-check="""">, and <img class=""equation_image"" title=""T\left(n\right)=T\left(\lfloor\frac{n}{2}\rfloor\right)+\Theta\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor%255Cright)%252B%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\lfloor\frac{n}{2}\rfloor\right)+\Theta\left(1\right)"" data-equation-content=""T\left(n\right)=T\left(\lfloor\frac{n}{2}\rfloor\right)+\Theta\left(1\right)"" data-ignore-a11y-check=""""> for <img class=""equation_image"" title=""n>1"" src=""/equation_images/n%253E1?scale=1"" alt=""LaTeX: n>1"" data-equation-content=""n>1"" data-ignore-a11y-check=""""></p>",1.0,Graded,18157,essay,"<p>Unfold&nbsp;</p>
<p><img class=""equation_image"" title=""T\left(n\right)=T\left(\frac{n}{2}\right)+c=T\left(\frac{n}{4}\right)+2c=\ldots=T\left(1\right)+c\log_2n"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252Bc%253DT%255Cleft(%255Cfrac%257Bn%257D%257B4%257D%255Cright)%252B2c%253D%255Cldots%253DT%255Cleft(1%255Cright)%252Bc%255Clog_2n?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\frac{n}{2}\right)+c=T\left(\frac{n}{4}\right)+2c=\ldots=T\left(1\right)+c\log_2n"" data-equation-content=""T\left(n\right)=T\left(\frac{n}{2}\right)+c=T\left(\frac{n}{4}\right)+2c=\ldots=T\left(1\right)+c\log_2n"" data-ignore-a11y-check=""""></p>
<p>Since <img class=""equation_image"" title=""T\left(1\right)=\Theta\left(1\right)"" src=""/equation_images/T%255Cleft(1%255Cright)%253D%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(1\right)=\Theta\left(1\right)"" data-equation-content=""T\left(1\right)=\Theta\left(1\right)"" data-ignore-a11y-check="""">, get <img class=""equation_image"" title=""T\left(n\right)=\Theta\left(\log n\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253D%255CTheta%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=\Theta\left(\log n\right)"" data-equation-content=""T\left(n\right)=\Theta\left(\log n\right)"" data-ignore-a11y-check=""""></p>
<p>the algorithm runs in <img class=""equation_image"" title=""\Theta\left(\log n\right)"" src=""/equation_images/%255CTheta%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(\log n\right)"" data-equation-content=""\Theta\left(\log n\right)"" data-ignore-a11y-check="""">, asymptotically faster than the O(n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>LowerBound</p>
<p>Input: A, a sorted strictly increasing, size n arry; k</p>
<p>Output: the smallest x<img class=""equation_image"" title=""\in A"" src=""/equation_images/%255Cin%2520A?scale=1"" alt=""LaTeX: \in A"" data-equation-content=""\in A"" data-ignore-a11y-check=""""> with <img class=""equation_image"" title=""x\ge k"" src=""/equation_images/x%255Cge%2520k?scale=1"" alt=""LaTeX: x\ge k"" data-equation-content=""x\ge k"" data-ignore-a11y-check="""">, or ""None""</p>
<p>if n = 0 then</p>
<p>&nbsp; &nbsp; &nbsp; return ""None""</p>
<p>endif</p>
<p>m<img class=""equation_image"" title=""\longleftarrow"" src=""/equation_images/%255Clongleftarrow?scale=1"" alt=""LaTeX: \longleftarrow"" data-equation-content=""\longleftarrow"" data-ignore-a11y-check=""""><img class=""equation_image"" title=""\lfloor\frac{n}{2}\rfloor"" src=""/equation_images/%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor?scale=1"" alt=""LaTeX: \lfloor\frac{n}{2}\rfloor"" data-equation-content=""\lfloor\frac{n}{2}\rfloor"" data-ignore-a11y-check=""""></p>
<p>if A[m] <img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check=""""> k then</p>
<p>&nbsp; &nbsp; if m =1 or A[m-1] &lt; k then&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return A[m]</p>
<p>&nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return LowerBound(A[1...m-1],k)</p>
<p>&nbsp; &nbsp; endif</p>
<p>else&nbsp;</p>
<p>&nbsp; &nbsp; return LowerBound(A[m+1...n],k)</p>
<p>endif</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Eric Li,513367,UW009Y159,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 09:10:12 UTC,00:27:07,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>Base case: for input size n = 1 or n = 2, the algorithm performs a constant number of operations. Therefore: T(n)=O(1) for n&lt;= 2.</p>
<p>Recursice step: for input sizes n &gt; 2, the algorithm performs:</p>
<p>1. Two recursive calls on subarrays of size approximately n / 3. The time for these call is 2T(n / 3)</p>
<p>2. A loop that iterates through the middle thrid of the array. This loop runs n / 3 times, performing constant work per oteration, contributing O(n) time.</p>
<p>3. Constant time operation for assgnments and the final min call. Therefore: T(n) = 2T(n / 3) + O(n) for n &gt; 2.</p>
<p>T(n) = O(1) if N &lt;= 2, 2T(n / 3) + O(n) if n &gt; 2</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Let T(k) be the number of multiplications for FastPower (n, k).</p>
<p>T(k) = O(1) if k &lt;= 1, <img class=""equation_image"" title=""T\left(\lfloor\frac{k}{2}\rfloor\right)+O\left(1\right)"" src=""/equation_images/T%255Cleft(%255Clfloor%255Cfrac%257Bk%257D%257B2%257D%255Crfloor%255Cright)%252BO%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(\lfloor\frac{k}{2}\rfloor\right)+O\left(1\right)"" data-equation-content=""T\left(\lfloor\frac{k}{2}\rfloor\right)+O\left(1\right)"" data-ignore-a11y-check=""""> if k &gt; 1.</p>
<p>Base case (k&lt;=1): Constant number of operations&nbsp;</p>
<p>Recursive Step (k &gt; 1): One recursive call on an exponent of size<img class=""equation_image"" title=""\lfloor\frac{k}{2}\rfloor:T\left(\lfloor\frac{k}{2}\rfloor\right)"" src=""/equation_images/%255Clfloor%255Cfrac%257Bk%257D%257B2%257D%255Crfloor%253AT%255Cleft(%255Clfloor%255Cfrac%257Bk%257D%257B2%257D%255Crfloor%255Cright)?scale=1"" alt=""LaTeX: \lfloor\frac{k}{2}\rfloor:T\left(\lfloor\frac{k}{2}\rfloor\right)"" data-equation-content=""\lfloor\frac{k}{2}\rfloor:T\left(\lfloor\frac{k}{2}\rfloor\right)"" data-ignore-a11y-check="""">. One or two multipilcations: O(1)</p>",1.0,Graded,18157,essay,"<p>Assuming k = 2^m (m = <img class=""equation_image"" title=""\log_2k"" src=""/equation_images/%255Clog_2k?scale=1"" alt=""LaTeX: \log_2k"" data-equation-content=""\log_2k"" data-ignore-a11y-check="""">):</p>
<p>T(k) = T(k / 2) + c</p>
<p>T(k) = T(k / 4) + 2c</p>
<p>T(k) = T(k / 8) + 3c</p>
<p>...</p>
<p>T(k) = T(k / 2^i) + i * c</p>
<p>Stop when k / 2 ^ i = 1 -&gt; i = <img class=""equation_image"" title=""\log_2k"" src=""/equation_images/%255Clog_2k?scale=1"" alt=""LaTeX: \log_2k"" data-equation-content=""\log_2k"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""T\left(k\right)=T\left(1\right)+\left(\log_2k\right)\cdot c"" src=""/equation_images/T%255Cleft(k%255Cright)%253DT%255Cleft(1%255Cright)%252B%255Cleft(%255Clog_2k%255Cright)%255Ccdot%2520c?scale=1"" alt=""LaTeX: T\left(k\right)=T\left(1\right)+\left(\log_2k\right)\cdot c"" data-equation-content=""T\left(k\right)=T\left(1\right)+\left(\log_2k\right)\cdot c"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""T\left(k\right)=O\left(1\right)+c\log_2k"" src=""/equation_images/T%255Cleft(k%255Cright)%253DO%255Cleft(1%255Cright)%252Bc%255Clog_2k?scale=1"" alt=""LaTeX: T\left(k\right)=O\left(1\right)+c\log_2k"" data-equation-content=""T\left(k\right)=O\left(1\right)+c\log_2k"" data-ignore-a11y-check=""""></p>
<p>Asymptotic solution: <img class=""equation_image"" title=""T\left(k\right)=\Theta\left(\log k\right)"" src=""/equation_images/T%255Cleft(k%255Cright)%253D%255CTheta%255Cleft(%255Clog%2520k%255Cright)?scale=1"" alt=""LaTeX: T\left(k\right)=\Theta\left(\log k\right)"" data-equation-content=""T\left(k\right)=\Theta\left(\log k\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Input: Base n &gt; 0, ingeger exponent k &gt;= 0.</p>
<p>Output: The value n^k.</p>
<p>1. Base case: If k = 0, return 1.</p>
<p>2. Resursive step:</p>
<p>Calculate <img class=""equation_image"" title=""m=\lfloor\frac{k}{2}\rfloor"" src=""/equation_images/m%253D%255Clfloor%255Cfrac%257Bk%257D%257B2%257D%255Crfloor?scale=1"" alt=""LaTeX: m=\lfloor\frac{k}{2}\rfloor"" data-equation-content=""m=\lfloor\frac{k}{2}\rfloor"" data-ignore-a11y-check="""">.</p>
<p>Recursively cpmpute half_power = FastPower(n, m). This solve the subproblem of size roughly k / 2.</p>
<p>Compute power_sq = half_power. This combines results.</p>
<p>3. Combine:</p>
<p>If k is even, the result is <img class=""equation_image"" title=""\left(n^m\right)^2"" src=""/equation_images/%255Cleft(n%255Em%255Cright)%255E2?scale=1"" alt=""LaTeX: \left(n^m\right)^2"" data-equation-content=""\left(n^m\right)^2"" data-ignore-a11y-check="""">. return power_sq.</p>
<p>if k is odd, the result is n*(n^m)^2. Return n * power_sq</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Anna Blaha,481911,UW110K516,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-16 23:18:39 UTC,00:28:15,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2T(n/4) + O(1); T(1) = T(2) = T(3) = T(4) = 1</p>,3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1); T(1) = T(2) = 1</p>,1.0,Graded,18157,essay,"<p>Recursion Tree:</p>
<p>n&nbsp; work = c</p>
<p>n/2&nbsp; work =c</p>
<p>n/2^2 work = c</p>
<p>n/2^3</p>
<p>....</p>
<p>n/2^k work = c</p>
<p>Since n/2^k = 1, k= log 2 (n)</p>
<p>Thus, since we have constant amount of work and log 2(n) levels. We take the sum of 1 from i = 0 to log 2 (n).&nbsp; This will be O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>input: A[1...n]</p>
<p>alg(A):</p>
<p>base case:</p>
<p>m = len(A)/2</p>
<p>if len(A) = 1</p>
<p>&nbsp; &nbsp; return m</p>
<p>if len(A) = 2:</p>
<p>&nbsp; &nbsp; &nbsp; use brute force and return</p>
<p>if ( A[(m-1)/2] &gt; A[m])</p>
<p>&nbsp; &nbsp; &nbsp; alg(first half of A)&nbsp;</p>
<p>else if (A[(m+1)/2] &gt; A[m])</p>
<p>&nbsp; &nbsp; &nbsp;alg( second half of A)</p>
<p>else&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;return m</p>
<p>&nbsp;</p>",2.5,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Arin CHANDRA,484775,UW979E281,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-16 23:15:07 UTC,00:25:48,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = 3T(n/5) + c, for some constant c with O(1) time</p>",2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case is when we reach k = 0. This is a constant lookup of O(1) time.</p>
<p>When we recurse, we only consider half the array. This is a factor of T(k/2). Overall we get the recurrence of T(k/2) + cn for some constant c.&nbsp;</p>
<p>T(k) = T(k/2) + T(1), where T(1) is constant</p>",1.0,Graded,18157,essay,"<p>From the previous problem, we see that the recurrence we must solve is T(k) = T(k/2) + c for some constant c. The base case is when we have an array size of 1. Then we acquire a k value of 0 with our next call.&nbsp;</p>
<p>First, expand the recurrence with unrolling. (T(k) = T(k/4) + c) + c. Then T(k/4) + 2c = T(k). T(k) = T(k/8) + 3c. We acquire a pattern of T(k) = T(k/2^i) + i*c. When we reach the base case, we reach a size of 1. This happens when (k/2^i) = 1 becomes 2^i = k becomes i = log_2(k). We can now substitute T(k) = T(1) + clog_2(k). T(k) = d + clog_2(k). This simplifies to a maximum runtime of O(logk). Therefore, our recurrence solution is O(logk).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Runtime must be O(nlogn). We will implement a modified Merge Sort that considers half of the sample size at a time.</p>
<p>FastMergeSort</p>
<p>if k == 0: return 1 //base case, as any exponent raised by 0 is equal to 1</p>
<p>if k is even:&nbsp;</p>
<p>acquire half = FastMergeSort(n, k/2) //compute n^(k/2) once, square it</p>
<p>return half * half</p>
<p>else:</p>
<p>return n * FastMergeSort(n, k - 1) //base multiplied by result of reduced problem size</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Sohan Alleshwaram,571585,UW106J707,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-16 23:44:44 UTC,00:14:57,1,18054,essay,"","",Not Attempted,18057,essay,"<p>f(n)=2f(2n/3)+2&nbsp; &nbsp; &nbsp; &nbsp;base case: f(2) = 2, f(1) = 1</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>f(n) = f(n/2) + c&nbsp; &nbsp; &nbsp;Base Case: f(1) = c</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>f(n) = f(n/2) + c</p>
<p>Unwind method:</p>
<p>f(n) = (f(n/4) + c) + c</p>
<p>f(n) = ((f(n/8)+c)+c)+c</p>
<p>....</p>
<p>f(n) = f(n/2<sup>k</sup>) + ck&nbsp; &nbsp; &nbsp; where k = tree height</p>
<p>&nbsp;</p>
<p>1 = n/2<sup>k</sup></p>
<p>2<sup>k</sup> = n</p>
<p>k = log<sub>2</sub>(n)</p>
<p>&nbsp;</p>
<p>f(n) = c + ck = c (1+log<sub>2</sub>(n)) = O(log(n))</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Do a binary search on the natural numbers between 1 and n. Whenever an element r is selected by the binary search, call GetsService(r). If true, call the binary search on the numbers less than or equal to r. If false, call the binary search on the numbers greater than r. Once the window of the binary search is 1, return that number. This has performance O(log n) because we are just doing a binary search.</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Quinton Vo,492584,UW985X993,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-16 23:11:31 UTC,00:17:40,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = T(n/2) + T(n/4) + T(n/4) + n + 1 with base case T(1) = 1</p>,3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2T(n/2) + 1 with base case T(1) = 1</p>,0.0,Graded,18157,essay,"<p>T(n) = 2T(n/2) + 1. We know that that each level of the recurrence will divide our problem in half twice until we reach our base case of T(1), where we then return. This means that our recursion tree will have <img class=""equation_image"" title=""\log_2\left(n\right)"" src=""/equation_images/%255Clog_2%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: \log_2\left(n\right)"" data-equation-content=""\log_2\left(n\right)"" data-ignore-a11y-check=""""> levels to it. We also know that the work needed for each level will be constant. We then get <img class=""equation_image"" title=""\sum_{k=0}^{\log_2\left(n\right)}1"" src=""/equation_images/%255Csum_%257Bk%253D0%257D%255E%257B%255Clog_2%255Cleft(n%255Cright)%257D1?scale=1"" alt=""LaTeX: \sum_{k=0}^{\log_2\left(n\right)}1"" data-equation-content=""\sum_{k=0}^{\log_2\left(n\right)}1"" data-ignore-a11y-check=""""> = (tree height + 1) * 1 = <img class=""equation_image"" title=""\log_2\left(n\right)"" src=""/equation_images/%255Clog_2%255Cleft(n%255Cright)?scale=1"" alt=""LaTeX: \log_2\left(n\right)"" data-equation-content=""\log_2\left(n\right)"" data-ignore-a11y-check="""">. Thus we see that our recurrence relation is <img class=""equation_image"" title=""\Theta\left(\log\left(n\right)\right)"" src=""/equation_images/%255CTheta%255Cleft(%255Clog%255Cleft(n%255Cright)%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(\log\left(n\right)\right)"" data-equation-content=""\Theta\left(\log\left(n\right)\right)"" data-ignore-a11y-check="""">.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Our algorithm EXP(n,k) takes in values n and k, the base and exponent respectively. Our base case will check if k = 1 and if it is, we return n. Otherwise, we recurse on values EXP(n, k/2) and EXP (n/k/2) if k is even and EXP(n, k/2+1) and EXP(n, k/2) if k is odd. We then multiply the two recursive calls together and return the value.&nbsp;</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Kane Li,512512,UW100Y507,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-16 23:25:24 UTC,00:21:48,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n)=T(n/5)+T(4n/5)+T(3n/5)+O(1)</p>,2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)=T(n/2)+C</p>
<p>base case T(1)=O(1)</p>
<p>noitce that for T(k), the k here means the value of (b-a) in the function we just defined</p>",1.0,Graded,18157,essay,"<p>from T(n)=T(n/2)+C, T(n)=T(n/2)+C1=T(n/4)+C1+C2=...=T(n/(2^k))+C1+C2+...Ck=C1+C2+....+Clog2(n)=O(logn)</p>
<p>it's very clear that every step we divide the k of T(k) by 2, so there's at most log2(n) times or recursion until k=1, it reaches the base case. And in each layer the time we spent is constant, so we have O(logn) eventually</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>// define the recursion function</p>
<p>test(int a, int b)<br>{</p>
<p>// a&lt;=b</p>
<p>if(a==b) { return a; }</p>
<p>midpoint = (a+b)/2</p>
<p>if(Getservice(midpoint)==False) {return test(midpoint, b)} // try to look in (midpoint, b)</p>
<p>if(Getservice(midpoint)==True) {return test(a, midpoint)} // try to look in (a, midpoint)</p>
<p>}</p>
<p>// call the recursion function</p>
<p>test(0,n)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
JEREMIAH JIN,517587,UW998X108,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 00:47:16 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(N) = 2T(2/3N) + cn</p>
<p>Base Case: T(1) = 1</p>",1.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>by using recursion: as defined, there are a total of n cores, and our goal is to design a divide and conquer algorithm to minimize the number of cores used.</p>
<p><span style=""text-decoration: underline;"">Algorihtm</span>: min_cores (core_num)<br><span style=""font-family: inherit; font-size: 1rem;"">base case: the routine runs under 1 second on 1 core, return 1.<br>mid = n / 2<br></span><span style=""font-family: inherit; font-size: 1rem;"">if with using only mid number of cores, the routine runs more than 1 second:<br></span><span style=""font-family: inherit; font-size: 1rem;"">&nbsp; |&nbsp; take the recurse on the: return (min_cores ( mid + n )) (so then in the next loop it would be in the middle of mid &amp; n as it will be divided by 2 before if statement, trying&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; more number of cores to see if it works)<br></span><span style=""font-family: inherit; font-size: 1rem;"">else if using only mid number of cores, the routine runs under 1 second:<br></span><span style=""font-family: inherit; font-size: 1rem;"">&nbsp; |&nbsp; take the recurse on the: return (min_cores ( mid ))<br>end</span></p>",3.0,Graded,18156,essay,"<p>Base case: T(1) = 1</p>
<p>T(N) = T(N/2) + 1</p>",1.0,Graded,18157,essay,"<p>as T(N) = T(N/2) + 1, the total recurrence is:<br>T(N) &lt;= T(N/2) + 1 &lt;= T(N/2<sup>k</sup>) + k<br>as for the base case T(1) = 1, then N/2<sup>k</sup> = 1, then k = logN</p>
<p>thus T(N) &lt;= T(N/2<sup>logN</sup>) + logN = T(1) + logN = 1 + logN</p>
<p>in conclusion, recurrence is O(logN)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Sameer Kulkarni,521163,UW099G869,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:42:08 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 3T(n/3)+cn, T(1)=c</p>",1.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + cn, T(1)=c</p>",0.0,Graded,18157,essay,"<p>Use tree.&nbsp;</p>
<p>Level one: cn</p>
<p>Level two: 2 of (cn)/2</p>
<p>Level three: 4 of (cn)/2^2</p>
<p>Thus, cost is cn for each level. Solve for i as well by doing the equation n/2^i = 1 =&gt; i (number of levels) is log_2(n)</p>
<p>Therefore, summation of i = 0 to log_2(n) of cn =&gt; cn * summation of i = 0 to log_2(n) of 1.</p>
<p>That is cn * (logn + 1) =&gt; cnlogn + cn which is:</p>
<p>O(nlogn)</p>",0.0,Graded,25540,essay,"<p>exp(x):</p>
<p style=""padding-left: 40px;"">Let exp be e^x.</p>
<p style=""padding-left: 40px;"">if x == 1:</p>
<p style=""padding-left: 80px;"">return e</p>
<p style=""padding-left: 80px;"">&nbsp;</p>
<p style=""padding-left: 40px;"">if x % 2 == 0:</p>
<p style=""padding-left: 80px;"">return exp(x // 2) * exp(x // 2)</p>
<p style=""padding-left: 40px;"">else:</p>
<p style=""padding-left: 80px;"">return e * exp(x - 1)</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.0
Brody Van Eperen,481191,UW913P376,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-16 23:48:19 UTC,00:29:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>Recurrance: T(n) &lt;= 3T(n/5) + c;&nbsp; T(1) = c</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n/2) + c; T(1) = 1</p>,1.0,Graded,18157,essay,<p>Since the work done at each level is c and there are K levels we need to solve for k. This is when n/2<sup>k</sup> = 1. This means that k = log<sub>2</sub>n so we do clog<sub>2</sub>n work which means that we will have a runtime of O(log(n))</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Base Case: If the size of our array is 1 and we will return that element</p>
<p>Recursive: If our size is &gt;1 we will find the middle index of our array and assign this to m. We will then check with our current array if A[m] = k we will return A[m]. If A[m] is less than k this means that x is either on the right side of the array or it is the element in A[m] we will check if k satisfies A[m] &lt; k &lt; A[m +1]. If so we will return A[m] If not we will recurse on A[m+1 ... n]. If A[m] is larger than k this means x is on the left side of our array or element A[m - 1] so we will check if k satisfies A[m -1] &lt; k &lt; A[m] if so we will return A[m - 1]. if not our x must be on the left side so we will recurse on A[0...m-1]</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Akash GOGATE,574807,UW104O081,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 00:16:04 UTC,00:23:30,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) = 2T(n/3) + O(n)</p>,2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>We have one recursive call that splits the input in half each time. Thus we have a T(n) = T(n/2) + O(1). The O(1) comes from having constant time operations in each recursive call.&nbsp;</p>,1.0,Graded,18157,essay,"<p>First we know that if we are solving by a recursion tree method, we have one child each time and we divide by 2 each time go down a layer. Thus the work per layer decreases by half each time. we can figure out the number of layers becuase at the bottom of the recusion tree we have n/2^k cost at that node. so when that is equal to 1, we have the value of our deepest layer. Therefore, we have 2^k = n and k = log(n) (log base 2 in this case). Thus, we have an O(1) work per level and log(n) levels, so our overall complexity becomes O(log(n)).&nbsp; This is the asymptotic solution for the recurrence relation from the algorithm created in part A.&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>&nbsp;</p>
<p>The Idea here is to use a binary search to find the correct square root value. We start at 0 and x as those are the general upper and lower bounds necessary for us to find the possible root of x.&nbsp;</p>
<p>Input: perfect square x&gt;=0</p>
<p>Output: r: the valye sqrt(x)</p>
<p>low = 0</p>
<p>high = x</p>
<p>while(low&lt;=high){</p>
<p>mid = (low + high) /2</p>
<p>if mid*mid == x:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return mid</p>
<p>else if mid*mid &lt; x:</p>
<p>&nbsp; &nbsp; low = mid+1</p>
<p>else:</p>
<p>&nbsp; &nbsp;high = mid-1</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,0,0,0,9.0,8.5
Nagasri Srikakolapu,490481,UW984N311,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 21:11:37 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>Base Case-&gt; E(1)=1</p>
<p>Reccurrence:T(n)=T(n/2)+2T(n/4)+o(n)</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base Case :E(1)=&lt;1</p>
<p>Reccurrence:T(n)=T(n/2)+o(1)</p>",0.0,Graded,18157,essay,"<p>Level 1=n</p>
<p>Level 2 =split into n/2</p>
<p>level 3= split into n/2^2, there will be 4</p>
<p>split levels until you hit n/2^k</p>
<p>Each Level has 1 call</p>
<p>Each level does o(1) work.</p>
<p>n/2^k=log2n</p>
<p>Create a summatation that goes from k=0 to log2n-1, inside the summatation should be o(1), which represents the constant work which represents the constant work that had been done at each level. When you decompose the summatation you get log2n time + (1)-- the 1 comes from the base case which is the extra work done at the last level. So The runtime of this reccurrence relation would be logn time.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>-Since you are given x, call a recursive function to split x in half</p>
<p>-For each split check if the new r times r equals the original x, if so store this new r in an another variable</p>
<p>-Keep splitting until you hit the base case equals &lt;1</p>
<p>-If you hit the base case just return the new r</p>",1.0,Graded,0,0,0,9.0,4.0
Selina SUNG,447206,UW974C086,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 01:07:54 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>T(n) = T(n/5)+ T(4n/5) + T(3n/5) + c</p>
<p>T(1) = 1</p>",2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + O(1).</p>
<p>T(1) = 1</p>",0.0,Graded,18157,essay,"<p>using tree method:</p>
<p>&nbsp;</p>
<p>level 0:&nbsp;</p>
<p>input size :n, total work c (1)</p>
<p>input size: n/2 total work 2*c</p>
<p>input size: n/4, totalwork 2 ^2&nbsp; *c</p>
<p>input size: n/2^3, total work 2^3 *c</p>
<p>n/2^k = 1 where k is the height of the tree</p>
<p>k = log base 2 (n) -&gt; number of levels</p>
<p>work per level -&gt; constant&nbsp;</p>
<p>total work: c * log base 2 n is&nbsp; O(log base 2 n)</p>
<p>&nbsp;</p>
<p>Each level has 2^k * c work</p>
<p>height of tree is n/2^k = 1 - &gt; k = log base 2 n</p>
<p>total work: summation from i=0 to log base 2 n of 2^i = 2^(log base 2 n) =n</p>
<p>&nbsp;</p>
<p>&nbsp;is O(n)</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Base case: k=1: return base</p>
<p>Divide: Divide k by 2 so you have n^(k/2) and n^(k/2). If k is odd, the left recursive call will do the n^floor of (k/2), and right recursive call will do n^ceiling of (k/2).</p>
<p>Conquer: recursively solve for for each n ^ (k/2)</p>
<p>merge: multiply the values returned by two recursive calls and return the result.</p>
<p>&nbsp;</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
AMIRUL AZMI,565465,UW111G643,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 05:48:49 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>T(n) = 3T(n/2) + O(n),&nbsp; &nbsp;O(1) = 1</p>",1.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + c , O(0) = 1</p>",0.25,Graded,18157,essay,"<p>T(n) = Sum of k from i = 0 ; n*(1/2)<sup>i</sup><sup>&nbsp;</sup>= 1 - (1/2)<sup> log n + 1 </sup>/ 1 - (1/2)&nbsp;&nbsp;</p>
<p>T(n) = O(log n)&nbsp;</p>",0.0,Graded,25540,essay,"<p>CalcExponent(e, x) -&gt; return exp, e^x value</p>
<p>If x == 0, return 1.</p>
<p>else if x is even , mid = CalcExponent(e, x/2) and we return mid*mid</p>
<p>else, mid = CalcExponent(e, x-1/2) and we return e *mid*mid</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.75
Zach BLIXT,430140,UW935L173,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 00:12:44 UTC,00:28:54,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) = T(n/3) + cn</p>,1.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + cn</p>,0.0,Graded,18157,essay,"<p>T(n) = T(n/2) + cn</p>
<p>T(n) = T(n/2^k) + kcn</p>
<p>k = logn</p>
<p>n/2^k = 1&nbsp;</p>
<p>T(n) = c +logn x c&nbsp;</p>
<p>T(n) = c(logn + 1)</p>
<p>O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>MinDistance(r):</p>
<p>If GetsService(r) == True</p>
<p>return r&nbsp;</p>
<p>Else&nbsp;</p>
<p>mid = floor(r/2)</p>
<p>split_left = 0</p>
<p>If GetService(split_left) == True</p>
<p>return split_left</p>
<p>else</p>
<p>split_left = split_left + 1</p>
<p>MinDistance(split_left)</p>
<p>split_right = mid + 1&nbsp;</p>
<p>If GetService(split_right) == True</p>
<p>return split_right</p>
<p>else</p>
<p>split_right = split_right + 1</p>
<p>MinDistance(split_right)</p>
<p>return min(split_left, split_right)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Daphne Han,517567,UW997S297,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 00:21:43 UTC,00:29:59,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>S(1) = O(1). Swap takes constant time. Denote n = length(A):</p>
<p>S(n) = S(1/5) + S(4/5) + S(3/5) + c</p>",2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: O(1). 1 recursive call, each of size n/2. The partitioning and if condition checks are O(1).&nbsp;&nbsp;</p>
<p>A(n) = A(n/2) + c</p>",1.0,Graded,18157,essay,<p>A(n) = \sum_{i = 0}^k&nbsp; (k+1)* (n/2^i). Our base case is A(1) so solving for k gives k = log_2. Plugging this in gives A(n) = (a constant) *log_2n A(1) + c. Hence A(n) = \theta(log n)</p>,1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Name: Alg; Input: Array A, number k; Output: smallest number in A &gt;= k</p>
<p>Base Case: If |A| = 1, return ""None"" if A[0] &lt; k else return A[0]&nbsp;</p>
<p>Partition A down the middle into a left, L, and right, R, array. We check if the largest element in L is greater than or equal to k. If so, we recurse in L. If not, we recurse in R.</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Ryan Khalloqi,507376,UW102Y795,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 00:27:17 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>Base case:</p>
<p>T(1) = c&nbsp; <img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check=""""></p>
<p>T(2) =&nbsp; <img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check=""""></p>
<p>&nbsp;</p>
<p>Recurrence:&nbsp;</p>
<p>T(n) = 3T(<img class=""equation_image"" title=""\frac{2n}{3}"" src=""/equation_images/%255Cfrac%257B2n%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{2n}{3}"" data-equation-content=""\frac{2n}{3}"" data-ignore-a11y-check="""">) + <img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check=""""></p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case:&nbsp;</p>
<p>T(1) = c = O(1)</p>
<p>&nbsp;</p>
<p>Recurrence:</p>
<p>T(n) = T(<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">) + c</p>
<p>T(n) = T(<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">) + O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c = T(n/2^2) + 2c = T(n/2^3) + 3c = T(<img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check="""">) + <img class=""equation_image"" title=""kc"" src=""/equation_images/kc?scale=1"" alt=""LaTeX: kc"" data-equation-content=""kc"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""\frac{n}{2^k}=1"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D%253D1?scale=1"" alt=""LaTeX: \frac{n}{2^k}=1"" data-equation-content=""\frac{n}{2^k}=1"" data-ignore-a11y-check="""">&nbsp; &nbsp; &nbsp;=&gt; &nbsp; &nbsp;<img class=""equation_image"" title=""k=\log_2n"" src=""/equation_images/k%253D%255Clog_2n?scale=1"" alt=""LaTeX: k=\log_2n"" data-equation-content=""k=\log_2n"" data-ignore-a11y-check=""""></p>
<p>&nbsp;</p>
<p>T(n) = T(1) + <img class=""equation_image"" title=""c\log_2n"" src=""/equation_images/c%255Clog_2n?scale=1"" alt=""LaTeX: c\log_2n"" data-equation-content=""c\log_2n"" data-ignore-a11y-check=""""></p>
<p>T(n) = <img class=""equation_image"" title=""\Theta\left(\log_2n+1\right)"" src=""/equation_images/%255CTheta%255Cleft(%255Clog_2n%252B1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(\log_2n+1\right)"" data-equation-content=""\Theta\left(\log_2n+1\right)"" data-ignore-a11y-check=""""></p>
<p>T(n) = <img class=""equation_image"" title=""\Theta\left(\log_2n\right)"" src=""/equation_images/%255CTheta%255Cleft(%255Clog_2n%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(\log_2n\right)"" data-equation-content=""\Theta\left(\log_2n\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>A = A[1...n]</p>
<p>initial boundaries: low = 1, high = n</p>
<p>&nbsp;</p>
<p>function F(A, low, high):</p>
<p>&nbsp; &nbsp; if low == high: return low</p>
<p>&nbsp; &nbsp; mid = low + high</p>
<p>&nbsp; &nbsp; if A[mid] &lt; A[mid + 1]:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return F(A, mid + 1, high)</p>
<p>&nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return F(A, low, mid)</p>
<p>end</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Dev Menon,587407,UW106G822,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 01:07:51 UTC,00:29:29,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,<p>T(n) = 2T(n/3) + 1<br>T(1) = 1</p>,1.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + 1<br>T(1) = 1</p>,1.0,Graded,18157,essay,<p>T(1) = 1<br>n/2^k = 1<br>k = log(n)<br><br>T(n) &lt;= T(cn/2) + c<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;= T(T(cn/4) + c) + c<br>&nbsp; &nbsp; &nbsp; &nbsp; ...<br>&nbsp; &nbsp; &nbsp; &nbsp; &lt;= T(cn/2^k) + kc<br>&nbsp; &nbsp; &nbsp; &nbsp; = T(c) + clog(n)<br>&nbsp; &nbsp; &nbsp; &nbsp; = O(log(n))</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Input: a, b which are natural numbers including 0 where a = b^k<br>Output: k in a = b^k<br>Base Case: If a equals b return 1.<br>Divide: Calculate isqrt(a) and let that be x. If x*x is equal to a let y be 1, else let y be 2. Call the function recursively on the input (x, b) and return the answer to that plus y.</p>",2.5,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,7.0
Henry Chen,516794,UW099P378,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 01:10:27 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>Base Case: T(1) = 1</p>
<p>Recurrence: T(n) = T(n/2) + 2T(n/4) + cn</p>",3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base Case: T(0) = 1</p>
<p>Recurrence: T(n) = T(n/2) + c</p>",1.0,Graded,18157,essay,"<p>Recurrence Tree</p>
<p>Levels: T(n) -&gt; T(n/2) -&gt; T(n/4) -&gt; T(n/8) -&gt; T(n/2^i)</p>
<p>Work:&nbsp; c,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c</p>
<p>Base Case when n/2^k. n/2^k = log2k = O(logn)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Exponent(n, k):</p>
<p>if(n == 0):</p>
<p>&nbsp; &nbsp; &nbsp; return 1</p>
<p>divided = Exponent(n, k/2)</p>
<p>if(divided % 2 = 0):</p>
<p>&nbsp; &nbsp; &nbsp;return divided * divided</p>
<p>else if (divided % 2 != 0):</p>
<p>&nbsp; &nbsp; &nbsp;return n * divided * divided</p>",2.5,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Ethan SHAO,433520,UW101P598,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 01:05:45 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>T(1) = 1</p>
<p>T(n) = T(n) + n</p>",1.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = 1</p>
<p>T(n) = T(n/2) + 1</p>",0.0,Graded,18157,essay,<p>O = log(n)</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>FindK(A)</p>
<p>&nbsp; &nbsp;base case:</p>
<p>&nbsp; &nbsp; &nbsp; if (k == 1) return;</p>
<p>&nbsp; &nbsp;else if k is odd</p>
<p>&nbsp; &nbsp; &nbsp; k -= 1</p>
<p>&nbsp; &nbsp;else</p>
<p>&nbsp; &nbsp; &nbsp; k = k // 2</p>
<p>&nbsp; &nbsp; &nbsp; c++</p>
<p>&nbsp; &nbsp; &nbsp;FindK(isqrt(A))</p>
<p>K == 2^c</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Abhijeet Beedikar,548281,UW104H137,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 01:50:38 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(n) = 3*T(2n/3) + c</p>,2.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + 1</p>,0.75,Graded,18157,essay,"<p>T(n) =T(n/2) + 1 = T(n/4) + 2 =...= T(n/2<sup>k</sup>) + k</p>
<p>Since termination occurs when the size of the input list is 1 (i.e. n1 = n2) n/2<sup>k</sup> = 1 at termination</p>
<p>Thus 2<sup>k</sup> = n thus k = logn</p>
<p>Thus we have that T(n) = T(1) + logn = 1 + logn = O(logn)&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>BinarySearch(n1,n2): #n1 is the starting index of a list and n2 is the last index of a list</p>
<p>&nbsp; &nbsp; &nbsp;if n2 &lt; n1: return ""Cannot get an A""</p>
<p>&nbsp; &nbsp; &nbsp;else if n1 == n2 and n1 gets us an A: return n1</p>
<p>&nbsp; &nbsp; &nbsp;else if floor((n1+n2)/2) does not get us an A: return BinarySearch(floor((n1+n2)/2)+1,n2)</p>
<p>&nbsp; &nbsp; &nbsp;else if floor((n1+n2)/2) gets us an A: return BinarySearch(n1,floor((n1+n2)/2))</p>
<p>&nbsp; &nbsp; &nbsp;return ""Cannot get an A""</p>
<p>&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.25
Tyler Grim,417957,UW877A129,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 01:53:35 UTC,00:29:55,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p># recurrences = 2</p>
<p>size of each recurrence = n/4</p>
<p>work for each recurrence = O(1)</p>
<p><strong>T(n) = 2T(n/4) + c; T(1) = T(2), T(3) = 1; T(4) = c'</strong></p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p># recurrences = 2</p>
<p>size of each rec = ceiling(x/2) or floor(x/2), call this (x/2) (since the +1 and -1 for ceiling and floor) are constants</p>
<p>work done each rec = c (assuming multiplication is constant)</p>
<p><strong>T(n) &lt;= 2(x/2) + c; T(0) = T(1) &lt;= c</strong></p>",0.0,Graded,18157,essay,"<p>Unwind T(x) &lt;= 2T(x/2) + c; T(1) = c</p>
<p>= 2(2T(x/4) + c) + c</p>
<p>= 2(2(2T(x/8) + c) + c) + c</p>
<p>...</p>
<p>= 2<sup>k</sup>T(x/2<sup>k</sup>) + kc</p>
<p>Find x/2<sup>k&nbsp;</sup>= 1, solve for k: x = 2<sup>k</sup> log<sub>2</sub>x = k</p>
<p>... = xT(1) + c * log x =<strong> x + c * log x =</strong> <strong>O(log x)</strong></p>",0.0,Graded,25540,essay,"<p>DCAlg(x):</p>
<p>Input: Exponent x &gt;= 0</p>
<p>Output e^x</p>
<p>BC: if x = 0, return 1, if x = 1, return e</p>
<p>Rec: // x &gt;= 2</p>
<p>mid = ceiling (x/2) (to cover odd cases)</p>
<p>left = DCAlg(mid)</p>
<p>right = DCAlg(x - mid)</p>
<p>return left * right;</p>
<p>&nbsp;</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Rae Dong,488240,UW980Y115,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 02:29:35 UTC,00:28:24,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n)=T(n/2)+n</p>
<p>Base case: T(1)=1, T(2)=1</p>",1.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)=T(n/2)+c, T(1)=1</p>",0.0,Graded,18157,essay,"<p>T(n), i=0, c&nbsp;</p>
<p>T(n/2), i=1, c</p>
<p>T(n/2^2), i=2, c</p>
<p>T(n/2^i), i=i, d</p>
<p>so the total sum of each level is: <img class=""equation_image"" title=""\sum_{i=0}^{\log_2n}"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog_2n%257D?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log_2n}"" data-equation-content=""\sum_{i=0}^{\log_2n}"" data-ignore-a11y-check=""""> c = clog2n +c</p>
<p>so <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>because a = b<sup>k</sup>, and k is nonnegative integer, a&gt;=k. so we can search from 0 to a to simplified the question. We can first find middle value of 0 to a. Because a is a postitive integers and, so there must exist a j, such that a=2j if a is even, or a=2j+1 if a is odd. then test if b<sup>j</sup>=a. (base case )if it is, return the value. if doesn't and b^j is larger than a, find the middle value from the lower part: 0 to j. If b^j is larger than a, find the middle value of the upper part: j+1 to a. And continue these step (recursive call) until we found b^j=a</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.0
Paul KIM,517169,UW980E721,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:23:51 UTC,00:29:11,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(n) = 3T(2n/3) + n</p>
<p>T(1) = 1&nbsp;</p>",1.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + n&nbsp;</p>
<p>T(1) = 1</p>",0.0,Graded,18157,essay,"<p>T(n) = 2T(n/2) + n</p>
<p>2^i * (n / 2^i)&nbsp; = n for each level of work, the total number of levels of work is log2(n), so the total runtime is the work for each level times the total number of levels which is n * log2(n) = so the overall complexity is O(nlogn) which is faster than O(n^2)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>input: take the inputs of a and b&nbsp;</p>
<p>take the input of a and divide by 2.&nbsp;</p>
<p>if the result is even take the result and call it&nbsp;</p>
<p>else take the input of a and subtract one and than divide by 2&nbsp;</p>
<p>if the result is odd call it&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,1.5
Hongzheng LI,565591,UW119P452,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 04:18:56 UTC,00:25:32,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(2n/3) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(2) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1),</p>
<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1).</p>",1.0,Graded,18157,essay,"<p>We know that <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) is constant time. Let c be that constant. Then, we have T(n) = T(n/2) + c = (T(n/4) + c) + c = ((T(n/8) + c) + c) + c = ... = T(n/2<sup>k</sup>) + k * c.</p>
<p>When k = log<sub>2</sub> n, we have T(n) = T(1) + c * log<sub>2 </sub>n. By part B, we know that T(1) is a constant, and so is c. Hence, T(n) = O(log n).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>func Obvious(A, k):</p>
<p>&nbsp; &nbsp; let n = len(A)</p>
<p>&nbsp; &nbsp; if n == 0 || A[1] &gt; k: return ""None""</p>
<p>&nbsp; &nbsp; let low = 1, high = n, ans = A[1]</p>
<p>&nbsp; &nbsp; while low &lt; high:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; let mid = (low + high) / 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if A[mid] &lt;= k:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans = A[mid]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;low = mid + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hi = mid - 1</p>
<p>&nbsp; &nbsp; return ans</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Adams Deng,584202,UW109A205,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 03:10:05 UTC,00:29:13,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(N) = O(1)&nbsp; when (N &lt; 5)<br>T(N) = 3T(N/5) + O(1) when (N&gt;5)<br><br></p>,3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"<p>Algorithm findMin</p>
<p>Base case : lo = hi, return lo;</p>
<p>while lo &lt; hi</p>
<p>&nbsp; let mid = (lo + hi)/2<br>&nbsp; if(P(mid) = true): hi = mid&nbsp;</p>
<p>&nbsp; else : lo = mid +1&nbsp;</p>
<p>return lo</p>",3.0,Graded,18156,essay,<p>T(N) = T(N/2) + C</p>,0.75,Graded,18157,essay,"<p>T(N) = T(N/2) + C = T(N/4) + 2C = T(N/8) + 3C =...... = T(N/2^t) +t*C.<br>The base case is that T(1) = C, so it ends at N/2^t= 1;</p>
<p>Thus it is T (N) = t*C + log2N, T(N) = O(logN)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.75
Ananya Virmani,450758,UW102A587,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 03:24:29 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>T(n) = 2T(<img class=""equation_image"" title=""\frac{2}{3}"" src=""/equation_images/%255Cfrac%257B2%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{2}{3}"" data-equation-content=""\frac{2}{3}"" data-ignore-a11y-check="""">n) + O(1)</p>
<p>T(n) = O(1) for n &lt; 3</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">) + O(1)</p>
<p>T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(1) = 1</p>
<p>T(n) = T(n/2) + O(1)</p>
<p>&nbsp;</p>
<p>Assume O(1) to be a constant c</p>
<p>&nbsp;</p>
<p>T(n/2) = T(n/4) + c</p>
<p>T(n) = T(n/4) + c + c</p>
<p>T(n) = T(n/2^k) + kc</p>
<p>&nbsp;</p>
<p>n/2^k = 1</p>
<p>k = log n</p>
<p>&nbsp;</p>
<p>T(n) = T(n/2^log n) + c(log n)</p>
<p>T(n) = T(1) + c(log n)</p>
<p>T(n) = 1 + c(log n)</p>
<p>T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Input: Sorted Array A in increasing order, number k</p>
<p>Output: Smallest value fo x that is &gt;= k</p>
<p>Base Case: If length of the array A is 1, if A[0] &gt;= k, return A[0] else ""None""</p>
<p>Divide: Divide the input array into two equal halves left and right, where mid = len(A) // 2.</p>
<p>Conquer: If A[mid] &gt;= k, search the left half A[ : mid]. If the left recursive call returns None, return A[mid] else if not none, return the answer that the left recursive call returned. If A[mid] &lt; k, recurse on the right half. Return the value if found else None</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Sunghoon Lee,473690,UW974C499,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 03:34:10 UTC,00:25:23,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(2n/3) + O(1)</p>
<p>Base Case: T(1) = O(1), T(2) = O(1)</p>
<p>&nbsp;</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>Base Case: T(1) = O(1)</p>",1.0,Graded,18157,essay,"<p>Level 0: T(n) = cn</p>
<p>Level 1: T(n/2) = cn</p>
<p>Level 2: T(n/4) = cn</p>
<p>Level 3: T(n/8) = cn</p>
<p>.....</p>
<p>Level k: T(n/2^k) = cn</p>
<p>So the recursion stops when n/2^k = 1, k = log_2 (n).</p>
<p>Therefore, number of levels: log_2 (n) + 1</p>
<p>Cost per level: c</p>
<p>So total: c * (log_2 (n) + 1) = O(log n)</p>
<p>&nbsp;</p>
<p>So T(n) = <img class=""equation_image"" title=""\theta"" src=""/equation_images/%255Ctheta?scale=1"" alt=""LaTeX: \theta"" data-equation-content=""\theta"" data-ignore-a11y-check="""">(log n)</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>FindLength(A[1...n]):</p>
<p>&nbsp; &nbsp; &nbsp;if n == 0:</p>
<p>&nbsp; &nbsp; &nbsp;return 0</p>
<p>&nbsp; &nbsp; &nbsp;mid = n/2</p>
<p>&nbsp; &nbsp; &nbsp;if A[mid] &lt; A[mid + 1]:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return FindLength(A, mid + 1, right)</p>
<p>&nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return FindLength(A, left, mid)</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
HAZIM SHAH MOHAMED SIDEK,565869,UW110U636,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 16:20:31 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n)=2T(2n/3)+1</p>
<p>Base Case = T(1)=1</p>",2.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c</p>
<p>Base Case = T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(n)=T(n/2)+c<br>=T(n/4)+c+c<br>=T(n/8)+c+c+c<br>= ...<br>= T(n/2<img class=""equation_image"" title=""^k"" src=""/equation_images/%255Ek?scale=1"" alt=""LaTeX: ^k"" data-equation-content=""^k"" data-ignore-a11y-check="""">)+kc</p>
<p>n/2<img class=""equation_image"" title=""^k"" src=""/equation_images/%255Ek?scale=1"" alt=""LaTeX: ^k"" data-equation-content=""^k"" data-ignore-a11y-check="""">=1<br>k=log2(n)<br><br>T(n)=log(n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>BinarySearch, want to find peak that divide A1, A2</p>
<p>Divide: Divide the input array into two and compute mid=<img class=""equation_image"" title=""\lfloor"" src=""/equation_images/%255Clfloor?scale=1"" alt=""LaTeX: \lfloor"" data-equation-content=""\lfloor"" data-ignore-a11y-check="""">n/2</p>
<p>Conquer: Compare mid and mid+1:<br>If mid&lt;mid+1, peak is at right of array. Recurse on [mid+1, n]<br>If mid&gt;mid+1, peak is at left of array. Recurse on [1, mid]</p>
<p>Base Case: array=[1], return 1</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Natalie Utomo,517618,UW999F418,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:45:00 UTC,00:29:40,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n)=2T(n/4)+n; T(1)=1</p>,1.5,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + n; T(1)=1</p>,1.0,Graded,18157,essay,"<p><img class=""equation_image"" title=""\sum_{k=0}^h\frac{n}{2^k}=n\sum_{k=0}^h\frac{1}{2^k}=O\left(\log n\right)"" src=""/equation_images/%255Csum_%257Bk%253D0%257D%255Eh%255Cfrac%257Bn%257D%257B2%255Ek%257D%253Dn%255Csum_%257Bk%253D0%257D%255Eh%255Cfrac%257B1%257D%257B2%255Ek%257D%253DO%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: \sum_{k=0}^h\frac{n}{2^k}=n\sum_{k=0}^h\frac{1}{2^k}=O\left(\log n\right)"" data-equation-content=""\sum_{k=0}^h\frac{n}{2^k}=n\sum_{k=0}^h\frac{1}{2^k}=O\left(\log n\right)"" data-ignore-a11y-check=""""></p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>(binary search?)</p>
<p>p = number of points on the final</p>
<p>n = total points on the final<br>p = 1</p>
<p>minPoints(p, n):<br>Base Case: if p will get an A, return p<br>Divide: Split points n to earn in 2<br>Merge:&nbsp;<br>if p will not get an A, p = minPoints(p+((n-p)/2), n)<br>if p will get a A, p = minPoints(p-(n-p)/2), n)<br><br></p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.5
REECE NAZRUL IRWAN,507394,UW107P454,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 03:38:36 UTC,00:14:33,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n) = T(n/5) + T(4n/5)+T(3n+5)+O(1)</p>,2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) =<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>",0.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c for some constant c</p>
<p>Expand T(n/2)</p>
<p>T(n) = [T(n/4) + c] + c = T(n/4) + 2c</p>
<p>Expand again:</p>
<p>T(n) = T(n/8) + 3c</p>
<p>After k expansion:</p>
<p>T(n) = T(n/2<sup>k</sup>) + kc</p>
<p>&nbsp;</p>
<p>Find the stopping point</p>
<p>recursion stops when n/2<sup>k</sup> = 1</p>
<p>so, k = log<sub>2</sub>n</p>
<p>&nbsp;</p>
<p>Substitute the base case</p>
<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1), say T(1) = d</p>
<p>So, T(n) = d + c log<sub>2</sub>n</p>
<p>&nbsp;</p>
<p>Simplify:</p>
<p>T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>
<p>&nbsp;</p>
<p>Final answer:</p>
<p>T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) = T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Algorithm type: Binary Search(divide and conquer)</p>
<p>Recurrence: T(n) = T(n/2)+O(1)</p>
<p>Asymptotic runtime: O(log n)</p>
<p>Improvement: faster than the given O(n) algorithm</p>",1.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
WONJUN JUNG,382996,UW903D956,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 04:02:32 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>Base Case : T(n) = O(1) for n&lt;=2</p>
<p>Recursion calls : For n &gt; 2, the algorithm makes two recursive calls. Each call is on a distinct sub-array of size one-third of the original array. This contributes to 2T(n/3).</p>
<p>Work per step : Outside of recursive calls, the dominant operation is the for-loop. This loop runs n/3 times and each iteration performs in a constant amount of time. Thus the work per step is O(n)</p>
<p>Combining these, T(n) = 2T(n/3) + O(n)</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = O(1) if n =1 T(n) =T(n/2) + O(1) if n&gt;1</p>
<p>This is because at each step, the algorithm performs a constant amout of time to calculate the midpoit and compare two elements. It then makes a single recursive call on a subproblem of size n/2</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2)+c</p>
<p>T(n) = (T(n/4) + c) + c = T(n/4) + 2c</p>
<p>T(n) = (T(n/8) + c) + 2c = T(n/8) + 3c</p>
<p>after i iterations:</p>
<p>T(n) = T(n/(2^i)) + i * c</p>
<p>The recurstion stops when n/(2^i) = 1. i =log2n</p>
<p>Thus,</p>
<p>T(n) = T(1) + (log2n) *c</p>
<p>Since T(1) is constant base case, the running time is dominated by the logarithmic term. Thus,&nbsp; T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Return Value : the total number of element in A1, which is the index of the last element in A1</p>
<p>Base Case: The recursion terminates when the search space is reduced to a single element (low= high). This single index represents the location of the peak which is the length of A1</p>
<p>Divide : Current search range [low, high] is partitioned into two halves by calculating the midpoint index mid.</p>
<p>Conquer : We determine the location of the peak relative to mid with a single comparison : A[mid] &lt; A[mid+1]</p>
<p>If A[mid] &lt; A[mid+1], the peak will be in the right half of the array, so recurse on the range [mid + 1, high]</p>
<p>If A[mid] &gt; A[mid +1], the peak is either at the mid or the left half of the array, so recurse on the range [low, mid]</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Eirfann Danish Bin Farul Muzri,500200,UW107U347,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 03:59:53 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>If length (A) &lt; 4: return 0 (constant work) : O(1)</p>
<p>If length (A) &gt; 4:</p>
<p>there are 2 recursive call: one on first quarter of A (size = n/4). the other on second quarter. then add the last element</p>
<p>Let T(n) be the runtime:</p>
<p>Base Case: O(1)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if n &lt; 4</p>
<p>T(n) : O(1) if n&lt;4</p>
<p>T(n) = 2T(n/4) + O(1)&nbsp; &nbsp;for n &gt;=4</p>",2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>Let T(n) be the number of score checks</p>
<p>Base Case: O(1) for n&lt;=1</p>
<p>T(n): T[n/2] + O(1)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>Recurrence: T(n) : T(n/2) + O(1)</p>
<p>Recursion tree:</p>
<p>first level : T(n) = T(n/2) + c</p>
<p>Second level: T(n/2) = T(n/4)&nbsp; + 2c</p>
<p>Third level: T(n/4) = T(n/8) + 3c</p>
<p>after k steps:</p>
<p>T(n) = T(n/2^k) + kc</p>
<p>&nbsp;</p>
<p>when reach base case = 1</p>
<p>n/2^k = 1</p>
<p>k = log2 n</p>
<p>T(n) = T(1) + c log2n</p>
<p>Since T(1) = O(1)</p>
<p>T(n) = O(log n)</p>
<p>runtime is O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Divide : Split the search in range [0,n] in haf by choosing the midpoint m = [ (L+R) /2) ]. (choose lower to mid)</p>
<p>Recurse: Check if a score of m gives an A.</p>
<p>if yes, then the answer lies in the left half [L,m]. Recurse here minPointA(low,mid).</p>
<p>if no, then the answer lies in the right half [m+1, R], Recurse here minPointA(m+1, high)</p>
<p>Merge: the merge is trivial, we just return the first score that yields an A. No combining is needed beyond selecting the correct half to continue with</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Andrew Calamug,488312,UW983Y279,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 04:14:52 UTC,00:21:19,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>Let T(n) be the running time on array n</p>
<p>Base case gives n&lt;5 for T(n) = Big Theta (1)&nbsp;</p>
<p>If you swap the first and last elements, it's Big theta (1), the rest of the calls are recursive only</p>
<p>The first second third shuffles give array sizes n/5, 4n/5, 3n/5 respectively.&nbsp;</p>
<p>The shufflle calls are 3 consecutive recursive calls made on subarrays of sizes n/5, ,4n/5, and 3n/5.&nbsp;</p>
<p>T(n) = Big Theta(1) for n &lt; 5</p>
<p>T(n/5) + T(3n/5) + T(4n/5) + Big Theta(1) for n &gt;= 5</p>",3.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Unrolling:</p>
<p>T(k) = Big Theta(1) + Big Theta(1) + ... Big Theta(1) # log_2 k times</p>
<p>= BigTheta(logk)</p>
<p>T(k) = T(k/2) + c</p>
<p>T(k) = c + c + ... + c_k # this is log_2 k times</p>
<p>T(k) = clog_2k + O(1)</p>
<p>T(k) = Big Theta(log k)</p>
<p>&nbsp;</p>
<p>T(k) = Big Theta(1) for k &lt;= 1</p>
<p>T(k/2) + BigTheta(1) for k &gt; 1</p>",1.0,Graded,18157,essay,"<p>T(k) = T(k/2) + c</p>
<p>= T(k/4) + c ) + c</p>
<p>= T(k/4) + 2c</p>
<p>= T(k/8) + c) + 2c</p>
<p>= T(k/8) + 3c</p>
<p>...</p>
<p>T(k) = T(k/2^i) + i * c</p>
<p>&nbsp;</p>
<p>k/2^i = 1 -&gt; 2^i = k =&gt; i = log_2 k</p>
<p>Sub back in</p>
<p>T(k) = T(1) + c*log_2k since T(1) = BigTheta(1)</p>
<p>T(k) = BigTheta(1) + c*log_2k</p>
<p>T(k) = BigTheta(logk)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>if a = b^k</p>
<p>When k is even, a = (b^(k/2))^2</p>
<p>When k is odd, a = b * (b^(k-1)/2)^2</p>
<p>&nbsp;</p>
<p>Algo(a,b):</p>
<p>Input: positive ints a, b s.t. a=b^k for some nonegative int k</p>
<p>Output: k</p>
<p>if a == 1: return 0</p>
<p>if a == b: return 1</p>
<p>&nbsp;</p>
<p>c = sqrt(a)&nbsp;</p>
<p># case 1 - if c is exact sqrt</p>
<p>if c * c == a: j = Algo(c, b)</p>
<p>return 2 * j</p>
<p>else: j = Algo(a/b, b)</p>
<p>return 2*j+1</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Kishore Rajan,425990,UW972C800,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:29:59 UTC,00:29:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>Base case: if n &lt; 5, complexity is T(n) = O(1)</p>
<p>Recursive case: T(n) = O(1) + T(n/5) + T(4n/5) + T(3n/5)</p>",3.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: If len(A) = 1, complexity = O(1)</p>
<p>Recursive case: T(n) = T(n/2) + cn = T(n/2) + O(1)</p>",1.0,Graded,18157,essay,"<p>Given recurrence is T(n) = T(n/2) + cn. T(n/2) = T(n/4) + n/4c + nc. At the last recursion, this equation is T(n) = T(1) + k*c&nbsp;&nbsp;<br>The number of recursions is equivalent to when n/2 reduces to 1. Let k be the number of recursion. <br>Therefore, n/(2^k) = 1, k = log2(n)<br>Therefore T(k) = T(1) + log2(n)*c<br>= O(1) + O(log2(n))<br>=O(log2 (n))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Inputs: array A, Array A size = n</p>
<p>Base case: If len(A) = 1, return 1</p>
<p>Divide: Let m be the midpoint of A, such that m = n/2, where m is the floor of n/2.</p>
<p>Conquer: So, left half contains elements from the range (0, m - 1) and right half contains elements from range (m, n). Let t = A(m - 1).&nbsp;<br>&nbsp;If t &lt; A(m), then recurse on the right half.<br>else if t &gt; A(m), then recurse on the left half.</p>
<p>Return: m - 1 such that A(m - 1) is the max value in A where A(m-1) &lt; A(m).</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Michael YANG,559244,UW104I306,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 04:51:57 UTC,00:18:33,1,18054,essay,"<p>T(n) = 3T(n/2) +&nbsp; O(n), T(1) = O(1)</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + O(1) , T(1) = O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n) = T(n/4) + 2c</p>
<p>T(n) = T(n/8) + 3c</p>
<p>after k times, we will have: T(n) = T(n/2^k) + kc</p>
<p>end when: n/2^k = 1</p>
<p>n = 2^k</p>
<p>log base 2 of n = k</p>
<p>T(n) = T(1) + c*(log base 2 of n)</p>
<p>T(1) is just constant.&nbsp;</p>
<p>Finally we get: T(n) = O(logn)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>We can use binary search to solve.&nbsp;</p>
<p>Check to see if the middle score gives you an A.</p>
<p>two cases:</p>
<p>1. it does give you A:&nbsp; the minimum score is less than or equal to this number so we search the lower half.</p>
<p>2. it does not give you A: the minimum score is more than this number so we search the uppper half.&nbsp;</p>
<p>we repeat this process until there is only one number left. essentially keep on cutting the search range by half each time until one number is left.&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Sahar Arora,512160,UW117N051,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 21:29:01 UTC,00:29:53,1,18054,essay,"","",Not Attempted,18057,essay,"<p>let T(n) be the cost. We make 2 recursive calls. Cost to divide and merge is O(n). Input shrinks by 2/3rds each time. 3 for the base case.&nbsp;</p>
<p>T(n) =&nbsp; 2T(n/(2/3))+ O(n) + 3</p>",0.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Because A is sorted, it takes O(n) time to sort through each of the halves, aL and aR. We make 2 recursive calls, one for aL and one for aR. and the problem size decreases by at least half on each run.&nbsp;</p>
<p>So, T(n) = 2T(n/2)+O(n).</p>",0.0,Graded,18157,essay,<p>We can unroll the reccurance solution.&nbsp;</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Base Case: Same, if A[n] &lt; k, return none</p>
<p>First Split in half and we get two arrays: Array left and right, call then aL and aR. We also get the point in the middle (pivot).&nbsp;</p>
<p>Check if k &gt; pivot point, if so then discard aL and now conisder only aR. If k &lt; pivot point same logic and move to aL. If k = pivot point we are done.&nbsp;</p>
<p>From here we can call run findX(aL) and findX(aR) (ie. two recursive calls) to find x s.t x &gt;= k. We continue by starting with the pivot and checking if we have a match and then keep going until we have a match.</p>
<p>Once a match is found, we can merge aL and aR back together and we are done.&nbsp;</p>",1.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Anthony Chen,568514,UW107Y284,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 17:26:25 UTC,00:19:37,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>Let n be the length of the array A</p>
<p>Base case: A(0) = O(1)</p>
<p>Reccurence: A(n) = A(2n/3) + A(2n/3) + O(1)</p>",2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: E(0) = O(1)</p>
<p>Recurrence: E(n) = E(n / 2) + O(1)</p>",1.0,Graded,18157,essay,"<p>Each layer of the recurrence tree has to do a constant amount of work c, n halves itself every layer so there are log_2(n) total layers, and the final layer also has a constant amount of work. Thus, the total amount of work is log_2(n) * c + c' = O(log(n)).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>function Exp(n,k):</p>
<p>if k = 0:</p>
<p>&nbsp; &nbsp; return 1</p>
<p>else if k is even:</p>
<p>&nbsp; &nbsp; x = Exp(n, k / 2)</p>
<p>&nbsp; &nbsp; power = x * x</p>
<p>else:</p>
<p>&nbsp; &nbsp; x = Exp(n, (k-1) / 2)</p>
<p>&nbsp; &nbsp; power = x * x * n</p>
<p>return power</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Bobby TANG,578989,UW110Q108,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 18:14:23 UTC,00:19:19,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) = 2 T(n / 3) + \theta(n) = 2 T(n / 3) + O(n)</p>,2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + \theta(1) = T(n/2) + O(1)</p>,0.75,Graded,18157,essay,"<p>the basecase is T(1) = \theta(1)</p>
<p>each time, the recursive call discards half of the array and does O(1) extra work</p>
<p>after t comparison, we have t discards, the length we consider is L(t+1) &lt;= n / 2**t</p>
<p>the loop ends when length is &lt; 1, n / 2**t &lt; 1 =&gt; t &gt; log2 n</p>
<p>and the recurrence is T(n) = T(n/2) + O(1)</p>
<p>thus, T(n) is obviously = \theta(logn) = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>func(A, k, l, r):</p>
<p>if l &gt; r:</p>
<p>return None</p>
<p>m = (l + r) // 2</p>
<p>if A[m] &lt;= k:</p>
<p>t = func(A, k, m + 1, r)</p>
<p>return A[m] if t == None else t</p>
<p>else:</p>
<p>return func(A, k, l, m - 1)</p>
<p>&nbsp;</p>
<p>it is faster than brute force, we just need to call func(A, k, 1, n)</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.25
Andyphuoc Nguyen,501268,UW099B471,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 08:57:42 UTC,00:28:01,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>The algorithm splits into two overlapping pieces that are already 2/3 of the original size when teh array has n elements we make 2 recursive calls on the arrays of size 2n/3 and the base case happens when the arrray has less than 3 elements so we just print out the array and stop the only work outside of teh recursive calls is printing one element which takes contant time this gives us the recurrence&nbsp; 2T(2n/3)+o(1) and this means that two recursive calls the 2n/3 is the size od each subproblem and it is o(1) when it comes to work each level</p>,2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n)+ (n/2) + C<br>the algorithm uses binary search so at each step we only look at half of the remaining array. we check the middle element and decide whether to search the left or right half which means that we only make one recursive call on the problem of in this case size n/2 the work we do at each step is just comparing which conditions which takes the constant time or o(1) and the base case is when we find the boundary or have just one element left which takes o(1) overall it is o(log n)</p>,0.75,Graded,18157,essay,<p>Starting at n elements and cut the problem in half each time we divide by 2 repeatedly so at each level we do o(1) work and the number times we can divide by 2 until we get to 1 is o(log n) since we do constant work at each o(log n ) levels the total time will be o(log n) and this proves that the algotihm is better than brute force which produces o(n)</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,<p>Use binary search t find where A1 ends and where A2 stars with this check the middle element of the array and if the element to its right is smaller than it then we found the boundary and the length of A1 is the middle position if the middle element is incresing thent he next boundary is further right so keep searching right once we find where the increasing stops and decreasing begins that position is the length of A1 the runtime is O(Log n) because of binary search</p>,2.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.25
Khang Lam,513731,UW100V043,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 11:45:25 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,<p>T(n) = 2T(2n/3)+ O(1); T(m) = O(1) if n&lt;=2</p>,3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2)+c; T(m)&nbsp; = 0(1)</p>
<p>T(n) = T(n/2)+c &lt;= T(n/2^2)+ 2c &lt;= ...&lt;= T(n/2^k) +kc (k &gt;= log2(n))</p>
<p>therefore, T(n) &lt;= T(1) + c.log2(n) = O(logn)</p>
<p>In lower bound omega(logn), at each step the interval is divided by at most a factor if 2, so after k step, interval size is at kease k &gt;= log2n step.</p>
<p>as T(n) = O(logn) and T(n) = omega(logn), combine both give 0(logn)</p>",1.0,Graded,18157,essay,"",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>FindMinRange(n):</p>
<p>&nbsp; &nbsp; begin</p>
<p>&nbsp; &nbsp; low = 0;</p>
<p>&nbsp; &nbsp; high = n;</p>
<p>&nbsp; &nbsp; r = 0;</p>
<p>&nbsp; &nbsp; while(low &lt;= high) :</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; mid = [(low + high) / 2] ( floor of (low + high)/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if getService(mid) == true { ans = mid; high = mid -1;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; else { low = mid + 1;}</p>
<p>&nbsp; &nbsp; end while</p>
<p>&nbsp; &nbsp; return ans;</p>
<p>end</p>
<p>Since it halve the space after each step, its complexity if O(logn)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Thomas Mazza,482703,UW973N562,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 16:32:06 UTC,00:27:26,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(n) = 3T(n/3) + cn, T(1) = 1. Both base cases, length(A) being 1 or 2, have only 1. Meanwhile, the recursive tree splits into three branches on each recursion level, which leads to <img class=""equation_image"" title=""3^k"" src=""/equation_images/3%255Ek?scale=1"" alt=""LaTeX: 3^k"" data-equation-content=""3^k"" data-ignore-a11y-check="""">.</p>",0.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + cn, T(1) = 1.&nbsp; (O(logn))</p>",1.0,Graded,18157,essay,"<p>By unrolling, we have T(n) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> (T(n/<img class=""equation_image"" title=""2^2"" src=""/equation_images/2%255E2?scale=1"" alt=""LaTeX: 2^2"" data-equation-content=""2^2"" data-ignore-a11y-check="""">) + (n/2)) + cn. We can continue unrolling until we are left with <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> <img class=""equation_image"" title=""2^k"" src=""/equation_images/2%255Ek?scale=1"" alt=""LaTeX: 2^k"" data-equation-content=""2^k"" data-ignore-a11y-check="""">(<img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">n) + c. This leaves us with the algorithm's asymptotic runtime case of O(<img class=""equation_image"" title=""\log n"" src=""/equation_images/%255Clog%2520n?scale=1"" alt=""LaTeX: \log n"" data-equation-content=""\log n"" data-ignore-a11y-check="""">).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>We already have n, which is the tower's maximum range. We set up an algorithm with two variables that start at the middle between 0 and n, and at n. Each time, we check if either variable is in range. If neither are, we halve the distance of each variable (In the case of this first change, the first variable would be at a quarter between 0 and n, and the second variable would be at the middle between 0 and n). If/when the first variable is in range, the second variable halves the distance between itself and the first variable, and we alternate this halving recursively until we have our two variables as neighboring integers, where the first is the smallest range and the second is not in range.</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Humza Pasha,574246,UW104N391,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 15:32:32 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(2n/3) + cn ; T(1) = 1, T(2) = 1</p>",2.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c ; T(1) = 1<br>c is a constant<br><br></p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c<br><br>Calls:&nbsp;<br><br>n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;=.&nbsp; &nbsp;c<br>n/2&nbsp; &nbsp; &nbsp;=.&nbsp; &nbsp; c<br>n/4&nbsp; &nbsp; &nbsp; =.&nbsp; &nbsp;c<br>.<br>.<br>.<br>n/2^i for some ith iteration = c<br><br>The ending iteration is when the n/2^i = 1 per the base case. Thus<br>n=2^i<br>log_{2}(n) = i<br><br>The total number of operations is the sum of the number of operations on each iteration. Thus:<br><br><img class=""equation_image"" title=""\sum_{i=0}^{log_{2}n} c = clog_{2}n = O(log_{2}(n))"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257Blog_%257B2%257Dn%257D%2520c%2520%253D%2520clog_%257B2%257Dn%2520%253D%2520O(log_%257B2%257D(n))?scale=1"" alt=""LaTeX: \sum_{i=0}^{log_{2}n} c = clog_{2}n = O(log_{2}(n))"" data-equation-content=""\sum_{i=0}^{log_{2}n} c = clog_{2}n = O(log_{2}(n))"" data-ignore-a11y-check=""""><br><br>Thus our algorithm is O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Algorithm: BetterObvious<br>Input: Array A of size n with elements in sorted increasing order and has unique elements , some integer k<br>Output: The lowest a_i in A such that a_i &gt;= k<br>if length of A = 1<br>&nbsp; &nbsp; &nbsp; &nbsp;return A[0]<br>end-if</p>
<p>else:<br>&nbsp; &nbsp; &nbsp; middle = floor(length of A/2)<br>&nbsp; &nbsp; &nbsp; middle_value = a at index middle in A<br>&nbsp; &nbsp; &nbsp; if middle_value &gt;= k<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return BetterObvious(left half of passed in list A starting from 0 to middle_value of A inclusive, k)<br>&nbsp; &nbsp; &nbsp; end-if<br>&nbsp; &nbsp; &nbsp; &nbsp;return BetterObvious(right half of passed in list A starting after middle_value to end of A , k)<br><br></p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
Yogev Rachbuch,559958,UW104R231,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 14:05:26 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>T(n) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> 2T(n/4) + T(n/2) + cn</p>
<p>T(1) = NIL cant shuffle array of length one</p>",2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> T(n/2) + c</p>
<p>T(2) = 1</p>",1.0,Graded,18157,essay,"<p><img class=""equation_image"" title=""T\left(n\right)\le T\left(\frac{n}{2}\right)+c\le T\left(\frac{n}{2^2}\right)+c+c\le T\left(\frac{n}{2^k}\right)+kc"" src=""/equation_images/T%255Cleft(n%255Cright)%255Cle%2520T%255Cleft(%255Cfrac%257Bn%257D%257B2%257D%255Cright)%252Bc%255Cle%2520T%255Cleft(%255Cfrac%257Bn%257D%257B2%255E2%257D%255Cright)%252Bc%252Bc%255Cle%2520T%255Cleft(%255Cfrac%257Bn%257D%257B2%255Ek%257D%255Cright)%252Bkc?scale=1"" alt=""LaTeX: T\left(n\right)\le T\left(\frac{n}{2}\right)+c\le T\left(\frac{n}{2^2}\right)+c+c\le T\left(\frac{n}{2^k}\right)+kc"" data-equation-content=""T\left(n\right)\le T\left(\frac{n}{2}\right)+c\le T\left(\frac{n}{2^2}\right)+c+c\le T\left(\frac{n}{2^k}\right)+kc"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""\frac{n}{2^k}=2\longleftrightarrow n=2^{k+1}\longleftrightarrow\log_2\left(n\right)=k+1\longleftrightarrow k=\log_2\left(n\right)-1"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D%253D2%255Clongleftrightarrow%2520n%253D2%255E%257Bk%252B1%257D%255Clongleftrightarrow%255Clog_2%255Cleft(n%255Cright)%253Dk%252B1%255Clongleftrightarrow%2520k%253D%255Clog_2%255Cleft(n%255Cright)-1?scale=1"" alt=""LaTeX: \frac{n}{2^k}=2\longleftrightarrow n=2^{k+1}\longleftrightarrow\log_2\left(n\right)=k+1\longleftrightarrow k=\log_2\left(n\right)-1"" data-equation-content=""\frac{n}{2^k}=2\longleftrightarrow n=2^{k+1}\longleftrightarrow\log_2\left(n\right)=k+1\longleftrightarrow k=\log_2\left(n\right)-1"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""T\left(2\right)+c\log_2\left(n\right)\in O\left(\log\left(n\right)\right)"" src=""/equation_images/T%255Cleft(2%255Cright)%252Bc%255Clog_2%255Cleft(n%255Cright)%255Cin%2520O%255Cleft(%255Clog%255Cleft(n%255Cright)%255Cright)?scale=1"" alt=""LaTeX: T\left(2\right)+c\log_2\left(n\right)\in O\left(\log\left(n\right)\right)"" data-equation-content=""T\left(2\right)+c\log_2\left(n\right)\in O\left(\log\left(n\right)\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>We define an algorithm FindLength(A,n) where n = |A|</p>
<p>Input: Array A which is a concatenation of <img class=""equation_image"" title=""A_1"" src=""/equation_images/A_1?scale=1"" alt=""LaTeX: A_1"" data-equation-content=""A_1"" data-ignore-a11y-check=""""> and <img class=""equation_image"" title=""A_2"" src=""/equation_images/A_2?scale=1"" alt=""LaTeX: A_2"" data-equation-content=""A_2"" data-ignore-a11y-check=""""></p>
<p>Output: Length of array <img class=""equation_image"" title=""A_1"" src=""/equation_images/A_1?scale=1"" alt=""LaTeX: A_1"" data-equation-content=""A_1"" data-ignore-a11y-check=""""></p>
<p>Base Case: if |A| = 2 then |<img class=""equation_image"" title=""A_1"" src=""/equation_images/A_1?scale=1"" alt=""LaTeX: A_1"" data-equation-content=""A_1"" data-ignore-a11y-check="""">| = 1 since both of the arrays are non empty</p>
<p>Recursive case: We first check the middle element where we define mid = <img class=""equation_image"" title=""\lceil\frac{n}{2}\rceil"" src=""/equation_images/%255Clceil%255Cfrac%257Bn%257D%257B2%257D%255Crceil?scale=1"" alt=""LaTeX: \lceil\frac{n}{2}\rceil"" data-equation-content=""\lceil\frac{n}{2}\rceil"" data-ignore-a11y-check=""""> if <img class=""equation_image"" title=""A\left\lbrack mid\right\rbrack>A\left\lbrack mid+1\right\rbrack"" src=""/equation_images/A%255Cleft%255Clbrack%2520mid%255Cright%255Crbrack%253EA%255Cleft%255Clbrack%2520mid%252B1%255Cright%255Crbrack?scale=1"" alt=""LaTeX: A\left\lbrack mid\right\rbrack>A\left\lbrack mid+1\right\rbrack"" data-equation-content=""A\left\lbrack mid\right\rbrack>A\left\lbrack mid+1\right\rbrack"" data-ignore-a11y-check=""""> then <img class=""equation_image"" title=""\left|A_1\right|=n-mid"" src=""/equation_images/%255Cleft%257CA_1%255Cright%257C%253Dn-mid?scale=1"" alt=""LaTeX: \left|A_1\right|=n-mid"" data-equation-content=""\left|A_1\right|=n-mid"" data-ignore-a11y-check=""""> now we consider the other case which is if the middle element is smaller then the one after it in that case we make the recursive call FindLength(A[mid + 1..n],n/2) we then get the end element of the array from the recursive call&nbsp; by keeping track of the reduction in size which we can use to find the length with constant time operations</p>",1.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.5
Haoran Lin,517429,UW995Z188,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 16:50:13 UTC,00:22:32,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) &lt;= 2T(n/3) + cn</p>
<p>T(1) &lt;= c, T(2) &lt;= c</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n/2) + c; T(1) &lt;= c</p>,1.0,Graded,18157,essay,"<p>Unwinding:</p>
<p>T(n) &lt;= T(n/2) + c &lt;= (T(n/4) + c) + c &lt;= ... &lt;= T(n/2^k) + kc</p>
<p>Stop at base case n/2^k = 1, then k = log_2 (n)</p>
<p>So T(n) &lt;= T(1) + c * log_2 (n) &lt;= c + clogn &lt;= clogn = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Algorithm: DC(start, end):</p>
<p>if start &gt;= end, return start</p>
<p>mid = (start + end) / 2</p>
<p>if GetsService(mid) == True:</p>
<p>&nbsp; &nbsp; &nbsp;return DC(start, mid)</p>
<p>else:</p>
<p>&nbsp; &nbsp; return DC(mid + 1, end)</p>
<p>&nbsp;</p>
<p>Function call: DC(0, n)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Holly Croke,483409,UW975Y223,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 14:51:08 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2) + 2T(n/4) + O(n)&nbsp; &nbsp; T(1) = O(1)</p>,3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1)&nbsp; &nbsp;T(1) = O(1)&nbsp; &nbsp;sum of i=0 to log2n 1 will equate to logn using recursive tree method of O(logn)</p>,1.0,Graded,18157,essay,<p>O(logn) sum of i=1 to logn of 1 will equat to O(logn) b</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>iFindR()</p>
<p>f min=max return min</p>
<p>result = GetsService((min+max)/2)</p>
<p>if reult = true</p>
<p>&nbsp; &nbsp; min = FindR(min, (min+max)/2)</p>
<p>else&nbsp;</p>
<p>&nbsp; &nbsp;min = FindR((min+max)/2, max)</p>
<p>return min</p>
<p>Start by calling FindR(0,n)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Tongzhou Li,517544,UW110X557,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 14:59:44 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2)+T(n/4)+T(n/4)+O(1)</p>,1.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1)&nbsp;</p>,0.75,Graded,18157,essay,"<p>T(n) = T(n/2) + O(1) = T(n/4) +&nbsp; c&nbsp; +c ... = T(n/2^k) + kc</p>
<p>1 = n/2^k</p>
<p>k = log(n)</p>
<p>T(n) = T(1) + log(n)c = O(log(n))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>base case: when the k = 1 return n</p>
<p>divide: divide the k into two parts both with k/2</p>
<p>conquer: same as binary search, recursively find the number of n^(k/2). For merge both side, n^k = (n^(k/2))^2</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.25
William Cleary,481120,UW882Z566,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 21:00:18 UTC,00:50:00,1,18054,essay,<p>T(n) =&nbsp; 3T(n/2)+cn+1</p>,2.5,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2T(x/2) + 1</p>,0.0,Graded,18157,essay,"<p>2^k(n/k^2) + k,&nbsp;</p>
<p>with a height of k = log2(n)&nbsp;</p>
<p>thus the resulting soltuion is log2(n)</p>",0.0,Graded,25540,essay,"<p>The algorithm shown above has one addtional operation (that of esp = 1*e), making it have x multiplcation operations. We can instead aim for the minimal required number of multiplications.</p>
<p>Base case: x =1, return e; x = 0, return 1.</p>
<p>Recursive call: take e^x and divide it in two, e^floor(x/2) and e^ceiling(x/2), recurse on these splitting them in half over and over until you reach the base case of x = 1.</p>
<p>Merge Step: take the return values of each prior subproblem and multiply the two resulting values together, and return that value.</p>
<p>EX: e^4</p>
<p>e*e*e*e</p>
<p>e*e | e*e</p>
<p>e | e | e | e</p>
<p>&nbsp;\/&nbsp; &nbsp; &nbsp; \/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;+2</p>
<p>e^2 | e^2</p>
<p>&nbsp; &nbsp; &nbsp;\/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; +1</p>
<p>&nbsp; &nbsp; e^4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;resulting in 3 total multiplications for an x of 4</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Noah Petersen,441896,UW876B288,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 15:51:55 UTC,00:29:54,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2 * T(n/4) + c where T(0) = 0</p>,2.5,Graded,18155,essay,"<p>Aim for O(log n) solution: Recurse into one side only<br>Base Case: if n = 1, return 1 cores for time<br>Recursive Case:<br>Split the list of n cores into two from 1 to n/2 and n/2 + 1 to n.<br>Average the two sides and compare the two<br>If one side has an average lower than the other, recurse into that side</p>",1.0,Graded,18156,essay,<p>T(n) = T(n/2) + n where T(1) = 1</p>,0.0,Graded,18157,essay,"<p>n - n/2 - n/4 ... n/2^k where each cost of the tree is n time for averaging<br><br>n/2^k = 1, which simplifies to k = log sub 2 of n<br><br>(n/2^log sub 2 of n + n) simplifies to (log sub 2 of n + n) which is O( n log n )<br><br>Couldn't figure out the O (log n) solution but this correlates to my actual algorithm</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Sipeng Chen,566342,UW117Q063,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 20:04:52 UTC,00:15:19,1,18054,essay,"","",Not Attempted,18057,essay,"<p>Let T(n） be the running time on an input array of length of n</p>
<p>Base cases T(1) =a, T(2) = b where a and b are constants.</p>
<p>for n&gt;= 3(no copying when taking subarrays):</p>
<p>T(n) = 2*T(ceil(2n/3)) +c , where c is a constant for the one compare.</p>
<p>if taking ""first two thirds"" and ""second two thirds"" actually copies elements:</p>
<p>T(n) = 2*T(ceil(2n/3)) + c*n</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>MinCores(n):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo &lt;- 1, hi &lt;- n</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while lo &lt; hi:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid &lt;- floor((lo + hi)/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if OK(mid):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hi&lt;-mid</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo &lt;- mid + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return lo</p>",3.0,Graded,18156,essay,"<p>Let T(n) be the number of experiments the algo performs on an input with n available cores.</p>
<p>Base case: T(1) = c0 for some constant c0</p>
<p>For n&gt;1: each step does one experiment and recurses on at most half the range:</p>
<p>T(n) = T(ceil(n/2)) + c1, where c1 is a constant.</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c1 = T(n/4) + 2*c1&nbsp; = T(n/8) + 3*c1&nbsp; ............&nbsp; = T(n/2^K) +K*c1</p>
<p>Stop when n/2^k = 1 then k = log2 n. Then</p>
<p>T(n) = T(1) + c1 * log2 n = c0 + c1 * log2 n</p>
<p>So the algo uses a number of experiments proportional to log2 n&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Joshua Moon,551405,UW105I034,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 21:30:24 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = T(n/3) + T(2n/3) + c</p>
<p>T(1) = c</p>
<p>T(2) = c<br>(c is a constant O(1))</p>",1.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = T(k/2) + c</p>
<p>T(1) = c</p>",1.0,Graded,18157,essay,"<p>Using the recursion tree we see that k -&gt; k/2 ... k/2^i. For i to reach the base case, we get i = log2(k) we get c* <img class=""equation_image"" title=""\sum_{i=0}^{\log2\left(k\right)}"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog2%255Cleft(k%255Cright)%257D?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log2\left(k\right)}"" data-equation-content=""\sum_{i=0}^{\log2\left(k\right)}"" data-ignore-a11y-check="""">1 for some constant c, and the expression is &lt;= c * log2(k), which means that it is O(logk)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Assume that the algorithm uses integer division (so 1/2 returns 0, 3/2 returns 1, etc.)</p>
<p>Input: integers n, k (algorithm is poweralg(n, k))</p>
<p>Output: the value n^k</p>
<p>Base case: if k== 0: return 1</p>
<p>Divide/recursive step:&nbsp;</p>
<p>x= poweralg(n, k/2)</p>
<p>if k is even:</p>
<p>return x*x</p>
<p>if k is odd:</p>
<p>return n*x*x</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Sean Shrader,499328,UW919P259,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 15:40:38 UTC,00:27:49,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) &lt;= 2T(n/4) + c; T(4) = A[0] + A[1] + A[3]; T(&lt;4) = 0</p>,2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(x) &lt;= T(x - 1) + T(x/2) + 1; T(0) = 1; T(1) = e</p>,0.0,Graded,18157,essay,"<p>Our recurrence tree gives us <img class=""equation_image"" title=""\sum_0^k\left(\frac{3^ix}{2^i}\right)"" src=""/equation_images/%255Csum_0%255Ek%255Cleft(%255Cfrac%257B3%255Eix%257D%257B2%255Ei%257D%255Cright)?scale=1"" alt=""LaTeX: \sum_0^k\left(\frac{3^ix}{2^i}\right)"" data-equation-content=""\sum_0^k\left(\frac{3^ix}{2^i}\right)"" data-ignore-a11y-check="""">, which can then be rewritten as <img class=""equation_image"" title=""x\cdot\sum_0^k\left(\frac{3}{2}\right)^i"" src=""/equation_images/x%255Ccdot%255Csum_0%255Ek%255Cleft(%255Cfrac%257B3%257D%257B2%257D%255Cright)%255Ei?scale=1"" alt=""LaTeX: x\cdot\sum_0^k\left(\frac{3}{2}\right)^i"" data-equation-content=""x\cdot\sum_0^k\left(\frac{3}{2}\right)^i"" data-ignore-a11y-check="""">. We then need to find our base case where x = 0 or x = 1, which gives us log(x). This means our given recurrence is an asymptotic tight solution up to constant factors of <img class=""equation_image"" title=""O\left(\log\left(x\right)\right)"" src=""/equation_images/O%255Cleft(%255Clog%255Cleft(x%255Cright)%255Cright)?scale=1"" alt=""LaTeX: O\left(\log\left(x\right)\right)"" data-equation-content=""O\left(\log\left(x\right)\right)"" data-ignore-a11y-check="""">.</p>",0.0,Graded,25540,essay,"<p>exponent(x)</p>
<p>begin</p>
<p>if x = 0</p>
<p>&nbsp; &nbsp; return 1</p>
<p>if x = 1</p>
<p>&nbsp; &nbsp; return e</p>
<p>if x is even</p>
<p>&nbsp; &nbsp; exp = exponent(x/2)</p>
<p>&nbsp; &nbsp; return exp * exp</p>
<p>if x is odd</p>
<p>&nbsp; &nbsp; exp = exponent(x - 1) * e</p>
<p>&nbsp; &nbsp; return exp</p>
<p>end</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.5
Mark Stanley,521181,UW099M859,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 15:27:46 UTC,00:12:16,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n)=3T(n/5)+c<br>base case n=5 (T(5)=1)<br><br>(I am assuming the swap is just some constant)</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n)=2T(n/2) + n base case T(1)=1. The work done at any recurrence level will be just the min of all indices. This is n operations.&nbsp;</p>,0.0,Graded,18157,essay,"<p>This recurrence solves to O(n log n). This is exactly from a homework problem. However, we can make a tree, which will have nodes n, n/2, ..., n/2^i and 2^i nodes, meaning each level will sum to n. We solve for the base case of T(1)=1, and we solve for n/2^k=1 which yields log n. Then, we do this n times so we get O(n log n). The textbook also simply verifies this as the sums are stable and non-decreasing.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>This can be a binary search-like algorithm, as the array is sorted.</p>
<p>Divide: Split the array in half</p>
<p>For each recursion, return i of the smallest x in that partition such that x \ge k.<br>Base Case: len(array)== 1. Then, we just return that index if the single value is greater than or equal to k.<br>The merge step is easy, we just return the smallest index (as the array is sorted).</p>",1.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Jerry LUO,548301,UW104H146,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 15:50:55 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>Base case: T(1) = 1 as getting the first or second element of an array is constant time. Returning the minimum of one element verus another is also constant time.</p>
<p>Recursive case: We have T(n/3) + T(n/3) as in the recursive case we branch out and recurse on the first and last third of A. We muust also add n/3 to the runtime as the middle third is run in a for loop n/3 times, and because we assume that computing min(a3, A[i]) while both variables are known is O(1) the recursive case can be written as T(n)=2T(n/3) + n/3</p>",2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>I think that an appropriate input size for this case is k. For the base cases of k = 0&nbsp; and k = 1we return 0 and 1 respectively in constant time so T(0), T(1) are both O(1).&nbsp;</p>
<p>In the recursive case we find the exponent for an a (in this case c) that is approximately half the exponent size of b, so k is approximately n/2. We also compare at the end which adds constant time to the recursive call. So we can write the recurrence as T(n)=T(n/2) + c</p>",1.0,Graded,18157,essay,"<p>T(n)=T(n/2)+c&nbsp;</p>
<p>= (T(n/4) + c) + c = T(n/2^2) + 2c</p>
<p>= ((T(n/8) + c) + c) + c = T(n/2^3) + 3c</p>
<p>...</p>
<p>=T(n/2^k)+ck, let n/2^k = 1, k = log(n).</p>
<p>Approximately clog(k) or log(k) time</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Algorithm: RecSqrt</p>
<p>Input: a, b</p>
<p>//base case</p>
<p>if a == 1 return 0</p>
<p>if a == b return 1</p>
<p>else:</p>
<p>//recursive case</p>
<p>c = isqrt(a) //gets b^{floor(k/2)} //if k is odd then a = c^(2+1)=c^2*c, if k is even a = c^2</p>
<p>d = RecSqrt(c, b)</p>
<p>if a == b^(2j) return 2j //k is even</p>
<p>else return 2j+1 //k is odd</p>
<p>&nbsp;</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Benjamin Fleckenstein,506957,UW998C932,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 16:04:16 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(1)=T(2)=T(3)=1, T(4)=3, T(n)=2T(n/4)+2</p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1)=1, T(n)=2T(n/2)+2</p>",0.25,Graded,18157,essay,"<p>Recurrence tree:<br>T(n)=2<br>2T(n/2)=2*2<br>4T(n/4)=4*2<br>...<br>2^kT(n/2^k)=2^k*2<br>1=n/2^k<br>k=log_2(n)<br><img class=""equation_image"" title=""\sum_{i=0}^{\log_2n}2^i2=\frac{2(1-2^{log_2n})}{1-2}\in O(\text{log } n)"" src=""/equation_images/%255Csum_%257Bi%253D0%257D%255E%257B%255Clog_2n%257D2%255Ei2%253D%255Cfrac%257B2(1-2%255E%257Blog_2n%257D)%257D%257B1-2%257D%255Cin%2520O(%255Ctext%257Blog%2520%257D%2520n)?scale=1"" alt=""LaTeX: \sum_{i=0}^{\log_2n}2^i2=\frac{2(1-2^{log_2n})}{1-2}\in O(\text{log } n)"" data-equation-content=""\sum_{i=0}^{\log_2n}2^i2=\frac{2(1-2^{log_2n})}{1-2}\in O(\text{log } n)"" data-ignore-a11y-check=""""></p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>You can solve this problem with a binary search type of solution. Start at n/2 and if that grade is lower than an A then recursively call your algorithm in the interval [n/2+1,n]. If the grade is at least an A, then recursively call your algorithm at [1, n/2]. Base case: interval reaches a size of 1, in which you return that number of points.</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.25
Alex Wu,500125,UW009B329,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 16:11:34 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>F(n) = 2F(2n/3) + 1, base cases are F(1) =1 and F(2) = 1</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>F(n) = F(n/2) + 1, base case is F(1) = 1</p>",1.0,Graded,18157,essay,<p>F(n) will unravel to F(n/(2^i) + i at level i and will stop when n/(2^i) = 1. So log_2(n) = i. Then F(n) = 1 + log_2(n) and asymptoticly it is Theta(log(n))</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>if x == 0 return 0</p>
<p>low = 1</p>
<p>high = x</p>
<p>while (low &lt;= high)</p>
<p>&nbsp; &nbsp; mid = (high - low) / 2 + low</p>
<p>&nbsp; &nbsp; if (mid * mid == x) return mid</p>
<p>&nbsp; &nbsp; elif mid * mid &lt; x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; low = mid + 1</p>
<p>&nbsp; &nbsp; elif mid * mid &gt; x</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; high = mid - 1</p>
<p>return -1 // not found</p>
<p>basically binary search for square root</p>
<p>&nbsp;</p>",3.0,Graded,0,0,0,9.0,9.0
Danny YIN,433604,UW117L069,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 16:41:39 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,<p>T(n) = 2T(2n/3) + cn</p>,1.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + 1, T(2) = 1;</p>",0.25,Graded,18157,essay,"<p>T(n) = 2(2(T(n/4) + 1) +1 = n + 1 + 2 + ... + n, O(n + (2n+1)n/2) = O(n^2);</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>input: A(i, j)</p>
<p>output: min_score in the number array to pass</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if (j = i +1 &amp;&amp; ( i not sufficient &amp;&amp; j sufficient) ) return j;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ( (i+j)/2 sufficient, retrun&nbsp;findMin(A(i, (i+j)/2);</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; else return findMin(A((i+j)/2 + 1, (i+j));</p>
<p>&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.75
Viet Luong,498988,UW102G920,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 16:47:57 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>Call n is the number of array A&nbsp;</p>
<p>T(n) = 2 * T(n/4) + T(n/2) + c if n &gt; 4&nbsp;&nbsp;</p>
<p>T(n) = theta(1) if n &lt;= 4 because the base case are contanst operation</p>",1.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>Call n is the range</p>
<p>T(n) = T(n/2) + c</p>
<p>T(1) = theta(1) with n == 1</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) = .. = T(n/2^k) + ck</p>
<p>n/2^k = 1 =&gt; k = log2(n)&nbsp;</p>
<p>T(n) = theta(1) + c * log2(n) =&gt; O(log(n))&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Algorithm:&nbsp;</p>
<p>FindRange(low = 0, high = n):&nbsp;</p>
<p>input n is the maximum range</p>
<p>if low &lt;= high:</p>
<p>&nbsp; &nbsp;return low</p>
<p>&nbsp;mid = (low&nbsp; + high) /2&nbsp;</p>
<p>if GetsService(mid) == True:&nbsp;</p>
<p>&nbsp; &nbsp;return FindRange(0, mid)</p>
<p>else:&nbsp;</p>
<p>&nbsp; return FindRange(mid + 1, high)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Nico Hurtado Castro,451381,UW965R898,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 16:34:38 UTC,00:24:35,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(1) = O(1)</p>
<p>T(2) = O(1)</p>
<p>T(n) = 2T(2n/3) + O(1)<br><br></p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0) = O(1), T(1) = O(1)<br>T(n) = T(n/2) + O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n) = (T(n/4) + c) + c = T(n/(2^2) + 2c<br>.<br>.<br>.<br>T(n) = T(n/(2^k)) + kc</p>
<p>n/(2^k) = 1, n = 2^k, k = logn</p>
<p>T(n) = T(1) + logn * c = O(1) + O(logn) = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Exp(n,k)</p>
<p>begin</p>
<p>&nbsp; &nbsp; &nbsp; if k is 0</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1</p>
<p>&nbsp; &nbsp; &nbsp; else if k is 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return n</p>
<p>&nbsp; &nbsp; &nbsp; else if k is even</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x = Exp(n, k/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return x * x</p>
<p>&nbsp; &nbsp; &nbsp; else if k is odd</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;x = Exp(n, (k-1)/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return n * x * x</p>
<p>end</p>
<p>&nbsp;</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Minghao Yang,579438,UW998G253,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 16:44:55 UTC,00:29:43,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>T(n) = 2*T(2n/3) + c, n &gt;= 3</p>
<p>T(0) = 1</p>
<p>T(1) = 1</p>
<p>T(2) = 1</p>",3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) &lt;= T(n/2) + c, T(1) = 1</p>",1.0,Graded,18157,essay,"<p>T(n) &lt;= T(n/2) + c &lt;= (T(n/4) + c) + c = T(n/4) + 2c &lt;= T(n/2^h) + hc</p>
<p>where n/2^h = 1, when h = lg(n)</p>
<p>thus T(n) &lt;= T(1) + lg(n)*c &lt;= O(lg(n))</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Algorithm: Find</p>
<p>Input: A, k: Array A, number k, l: left(low) index in A, r: right(high) index in A</p>
<p>Output: the largest number x where x in A and x &lt;= k, or None if such x don't exist</p>
<p>Basecase:</p>
<p>if l &gt; r, return None</p>
<p>Inductive Step:</p>
<p>m = (l + r) // 2</p>
<p>if A[m] &lt;= k:, # x is on right side of A[m]</p>
<p>&nbsp; &nbsp; temp = Find(A, k, m+1, r)</p>
<p>&nbsp; &nbsp; if temp == None, return A[m]</p>
<p>&nbsp; &nbsp; else, return temp</p>
<p>else: # x is on left side of A[m]</p>
<p>&nbsp; &nbsp; return Find(A, k, l, m-1)</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Shixuan Wang,535397,UW995Q286,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:24:04 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2T(n/4) + cn</p>,1.5,Graded,18155,essay,"<p>tryMid</p>
<p>&nbsp; Let A be the set to hold the n cores.</p>
<p>&nbsp; if n = 1, then: return 1</p>
<p>&nbsp; m: = n/2</p>
<p>&nbsp; if the routine runs in under 1 second on m cores then&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; tryMid(front-half of A)</p>
<p>&nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; tryMid(front-half of A)</p>",3.0,Graded,18156,essay,<p>T(n) = T(n/2) + cn; T(1) = c;</p>,0.5,Graded,18157,essay,"<p>T(n)=T(n/2) + cn = T(T(n/4)+cn/2) + cn = ... = T(n/2<sup>k</sup> ) + cn(1+ 1/2+ ... + 1/2<sup>k</sup> )</p>
<p>When n/2^k = 1; n = 2^k</p>
<p>T(n) = T(1) + cn (1-(1/2)<sup>logn</sup> )/(1/2) = O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.0
Sandeep Kapugamage,505269,UW995K622,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 20:13:33 UTC,00:29:33,1,18054,essay,"<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(n) = 3T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(n)</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(k) = T(k/2)+<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",1.0,Graded,18157,essay,"<p>T(k) = T(k/2) +c2</p>
<p>T(k) = [T(k/4)+c2] = c2 = T(k/4) +2c2</p>
<p>T(k) = [(T(k/8)+c2+2c2 = T(k/8) +3c2</p>
<p>&nbsp;</p>
<p>T(k) = T(k/2^i)+i*c2</p>
<p>&nbsp;</p>
<p>stop when k/2^i = 0</p>
<p>happens when 2^i =k</p>
<p>i = log base 2 k</p>
<p>T(k) = T(1) + log base2(k) * c2</p>
<p>T(k) = c1 + c2*log base2(k)</p>
<p>T(k) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(logk)</p>
<p>lower bound: each level reduced k to k/2 and does at least one multiplication.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>input: base n&gt;0 , exponent k &gt;= 0&nbsp;</p>
<p>output: power : the value n^k</p>
<p>begin</p>
<p>&nbsp; &nbsp; if k == 0 then</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 1&nbsp;</p>
<p>&nbsp; &nbsp; halfPower = fastPower(base, k/2)</p>
<p>&nbsp; &nbsp; if k is even then</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return halfPower * halfPower&nbsp;</p>
<p>&nbsp; &nbsp; else&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return halfPower * halfPower * base&nbsp;</p>
<p>end</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Eugene Park,350761,UW893A979,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 17:23:03 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>Base case: length(A)&lt;5, the algorithm returns immediately. Runtime is constant O(1)</p>
<p>when n is greather than or equal to 5, the algorithm does a constant amount of work to swap the first and last elements, the algorithm makes a recursive call on the subarrays are 1/5 size of the original array&nbsp;<br>T(n) = 3T(1/5n) + O(1)</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: n=1,&nbsp;</p>
<p>the algorithm compares n=1 to k and returns, thus base case holds</p>
<p>T(1) =&nbsp;</p>
<p>Recurrence relation We have the recurrrence T(n) = T(n/2) + c where T(1) = x, we can use a recursion tree and at each level it we are multiplying the input by 1/2. At the root of the tree which is of size n, the next level being n/2, the third level being n/2^2. At each level of the tree the costs are n, n, n respectively which is constant. (n/2^k) which we get k = log2n levels since we half the input each time. Therefore the runtime of the algorithm is O(logn)</p>",1.0,Graded,18157,essay,<p>We have the recurrence relation: T(c) = T(n/2) + c</p>,1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>divide: half the sorted array by checking the middle value</p>
<p>conquer: if the middle value is less than or equal to k, we can store it as a possible answer and continue searching the right half to find a larger valid value. if the middle value that's checked is greater than k, the algorithm searches the left half since all the elements on the right side are too big. This algorithm will keep splitting the array in half until there is one value or element left.&nbsp;</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Abel Tesfaye,488822,UW984A422,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 19:11:02 UTC,00:17:08,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2*T(n/4) + O(1)&nbsp;<br>base case when n &lt; 4 T(n) = O(1)</p>,2.5,Graded,18155,essay,<p>I would implement a binary search instead of checking every index from first to last. I would have to sort and then check the middle number if it runs with under 1second with mid cores i would check the left half. else i would search the right half and then keep repeating this algorithim. this would ultimatly be faster than brute force since we are not checking every index</p>,3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>Base Case = O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>T(n/2) = T(n/4) + O(1)</p>
<p>keep going by diving by 2 and then stop</p>
<p>T(n) = O(n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.5
Roland Sellman,486746,UW980N119,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 17:10:43 UTC,00:29:55,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = T(n/2) + 2T(n/4) + n</p>,2.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(1)=1<br>T(n) = T(a^(k-1)) + c</p>,0.0,Graded,18157,essay,<p>By recursion tree: each level has c operations ~ O(c) for each level. The total levels are log2(n) ~ log(n) so we have log(n)*O(c) total time complexity. Thus the total running time is O(log n)</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Algorithm(a,b)</p>
<p>Base Cases: If a=1 return 0. If a=b return 1.<br>Recursive Case: By cases:<br>Case 1: If isqrt(b^k)^2 &lt; a, then return 2*Algorithm(a/isqrt(b^k),b)+1<br>Case 2: Otherwise, return 2*Algorithm(a/isqrt(b^k),b)<br><br></p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,5.5
Nicholas Beahm,535311,UW103H046,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 17:41:48 UTC,00:44:49,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>T(n) = 2T(2n/3) + cn</p>,1.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"",0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>To calculate the value of k, we would first recursively divide the input a by the input b until a = b. You would then call isqrt(a) with the new value of a.&nbsp;</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Junnan Li,566037,UW110A258,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 17:10:55 UTC,00:13:12,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = 3T(n/5)+O(1) for n &gt;=5</p>
<p>base case: T(n) = O(1) if n &lt; 5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + O (1), N &gt;=2</p>
<p>base case: T(1) = O(1), N&nbsp; == 1</p>",1.0,Graded,18157,essay,"<p>total depth: logn</p>
<p>work at one layer O(1)</p>
<p>total work: T(n) = logn * O(1) = O(logn)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>begin findSmallestRange(n):</p>
<ul>
<li>&nbsp;set low = 0 and high = n, ans =n</li>
<li>while low &lt;= high:
<ul>
<li>mid &lt;- (high + low ) // 2</li>
<li>if GetsService(mid) == True:
<ul>
<li>ans &lt;- mid, high &lt;- mid -1</li>
</ul>
</li>
<li>else:
<ul>
<li>low &lt;- mid+1</li>
</ul>
</li>
</ul>
</li>
<li>return ans</li>
</ul>
<p>end</p>
<p>&nbsp;</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Mukhriz Hazli Bin Mohamad,507355,UW103R118,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 17:29:29 UTC,00:29:37,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n)= 3T(n/5) +1</p>
<p>T(n) =1 for n &lt;5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)= T(n/2) + 1</p>
<p>T(1)=1</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) = T(n/4) = T(n/8)</p>
<p>(n/2^k) =1</p>
<p>Log2 n = k</p>
<p>T(n) = log2n + 1 = <img class=""equation_image"" title=""\theta"" src=""/equation_images/%255Ctheta?scale=1"" alt=""LaTeX: \theta"" data-equation-content=""\theta"" data-ignore-a11y-check=""""> (log n)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Instead of checking every possible score from 1 to n brute force, we will use binary search strategy. It tests the midpoint of the current range of possible scores to see if that score gives an A. If it does, the algorithm continues searching the lower. If it doesn't, it search the upper half. Repeat this process until the smallest score is giving an A is found. Each step cuts the range in half and does one check per step. This reduces the runtime to log n</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Yanna KEOHANE,485577,UW979J515,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 17:34:08 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(n) = 3*T(2/3) while n&gt;2</p>,1.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = 1</p>
<p>T(n) = T(sqrt(n))</p>",0.0,Graded,18157,essay,<p>O(log(n))</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Input a, b</p>
<p>func find(a, b)</p>
<p>count = 0</p>
<p>if a = 1</p>
<p>return 1</p>
<p>else</p>
<p>num = isqrt(a)</p>
<p>return find(num, b) + 1</p>
<p>&nbsp;</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Yuxiang Wu,449617,UW110P881,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:05:38 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>T(n) = 5 T(n/5) + 4</p>
<p>BaseCase; T(1) = 4</p>",1.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>BaseCase : T(1) = 1</p>
<p>T(n) = 2T(n/2) + 1</p>",0.25,Graded,18157,essay,"<p>T(n) = 2T(n/2) + 1 = 4T(n/4) + 3 = 2<sup>k</sup>T(n/2<sup>K</sup>) + 2<sup>K</sup> - 1</p>
<p>Since k = log<sub>2</sub> n, , therefore T(n) = O(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Split A from mid to two part L and R</p>
<p>Compare the rightmost of L (l) and leftmost of R (r)</p>
<p>if l&lt;r, than move to right part</p>
<p>if l&gt;r, than move to left part</p>
<p>redo split and compare until the array size become 1</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.25
Steven Zhuo,365552,UW890T956,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:07:14 UTC,00:27:58,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(n) = 3T ( 2n/3) +1&nbsp;<br>T(1) = 1&nbsp;</p>,2.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>so since each step is constant and then we are also dividing it in half&nbsp;<br><br>the recurrence is&nbsp;<br><br>T(n) = T(n/2) + 1<br>T(1) = 1</p>,1.0,Graded,18157,essay,"<p>so for T(n) = T(n/2) + 1 , T(1) = 1<br>we know that each step gets cut in half&nbsp; and does not rely on n as it only gets cut once each step&nbsp;</p>
<p>so at step 1 its n/2 and then in step 2 its n/4 and so on right so we keep doing that until we reach the base case after log n steps and since each level does constant work(we know it does constant work because all it does is split it in half) , we know that the total is T(n) = O(logn)&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>so we can make a quicker algo using DnC.&nbsp;<br><br>so first we should instead of testing all possible cases for score from 1 to n, we can just split it in half and test the middle to see if that middle is enough to get the A.&nbsp;<br>From here we now have the upper half and lower half right so after here we can check if the score is enough to get A then we can disregard the upperhalf but if it is then we can take a look at the lower half. from there we keep searching and splitting till we get the minimum number to get the A&nbsp; in the class. So in this case since we are cutting it in half the runtime is O(log n ) compared to the brute force strat where u go from 1-n which the runtime is O(n)&nbsp;<br><br>so because O(logn) &gt; O(n) we have designed a divide and conquer algo that is faster in performance than the brute force option.&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Amrita Sundaram,489307,UW984D662,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 20:38:39 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 3T(n/3) + c</p>
<p>*c : small arbitrary constant</p>",0.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: The size of A is 1 or 2 elements. Return a length of 1 for A[1] since that's the only point. For 2 elements, it will be split in half.</p>
<p>T(n) = 2T(n/2) + c</p>
<p>c is a constant factor to account for the run time of the base cases.</p>",0.0,Graded,18157,essay,"<p>First, the recursive part of the algorithm accounted for by the (n/2) would be O(log n) because we are splitting each section in half and searching for the changing point. Since we do this for both halves, we have to multiply this by 2. Finally, we add the constant factor to create a asymptotic run time of:</p>
<p>2 * O(log n) + O(1)</p>
<p>Since 2 and the O(1) are just constant factors, we can drop it to make the run time O(log n).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Divide: Split the concatenated array into two halves, A1 and A2. Recursively binary search each half.</p>
<p>Conquer: At each recursion, compare the value at index x to see if it is greater/less than the previous value and less/greater than the next value. Once A[x] &lt; A[x -1] and A[x] &gt; A[x + 1], save x-2 for the last index of A1. Return x + 1 for the list length.&nbsp;</p>",1.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Anurag Ghadge,443978,UW943E942,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 17:47:45 UTC,00:20:25,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>So first let T(n) be the running time on an array length for example say m. The base case would be a couple of comparisons / optional swap to constant time. T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1). T(2) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1). Recursive cases would be 3 recursive calls each on the first or second two-thirds of the array so basically size <img class=""equation_image"" title=""\lceil\frac{2n}{3}\rceil"" src=""/equation_images/%255Clceil%255Cfrac%257B2n%257D%257B3%257D%255Crceil?scale=1"" alt=""LaTeX: \lceil\frac{2n}{3}\rceil"" data-equation-content=""\lceil\frac{2n}{3}\rceil"" data-ignore-a11y-check=""""> plus constant overhead. so T(n) = 3T(<img class=""equation_image"" title=""\lceil\frac{2n}{3}\rceil"" src=""/equation_images/%255Clceil%255Cfrac%257B2n%257D%257B3%257D%255Crceil?scale=1"" alt=""LaTeX: \lceil\frac{2n}{3}\rceil"" data-equation-content=""\lceil\frac{2n}{3}\rceil"" data-ignore-a11y-check="""">)+<img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check="""">, n &gt;= 3. So 3 recursive calls.</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>So let T(n) be the running time so the number of score checks for an interval of size say n. T(1) = <img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check=""""> T(n) = T(<img class=""equation_image"" title=""\lfloor\frac{n}{2}\rfloor"" src=""/equation_images/%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor?scale=1"" alt=""LaTeX: \lfloor\frac{n}{2}\rfloor"" data-equation-content=""\lfloor\frac{n}{2}\rfloor"" data-ignore-a11y-check="""">) + <img class=""equation_image"" title=""\Theta\left(1\right)"" src=""/equation_images/%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(1\right)"" data-equation-content=""\Theta\left(1\right)"" data-ignore-a11y-check="""">. This is the tight upper bount recurrence in the previous part and final bound would be T(n) = O(logn)</p>",1.0,Graded,18157,essay,"<p>So each recursive call halves the problem size and adds a constant amount of extra work essentially. So T(n) = T(n/2)+c = (T(n/4) + c) + c = T(n/4) + 2c = T(n/8) + 3c = T(n/2^k)+kc. So we stop when the subproblem size becomes a so n / 2^k = 1 =&gt; k&nbsp; which = <img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">n. So Substitute back and T(n) = T(1) + c<img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""> and since T(1) is constant, T(n) = <img class=""equation_image"" title=""\Theta\left(\log n\right)"" src=""/equation_images/%255CTheta%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: \Theta\left(\log n\right)"" data-equation-content=""\Theta\left(\log n\right)"" data-ignore-a11y-check="""">.&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>So: Algorithm minPoints(1, r):&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if 1 == r:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m &lt;- floor((1+r) / 2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if hasA(m):&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return minPoints(1, m)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return minPoints(m + 1, r)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Call minPoints(0, n)</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Sai Karthikeya Cherukuru,493228,UW988D822,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:11:01 UTC,00:26:34,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = 3*T(n/3) + n</p>,1.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>find_under_one(prev = 0, n):</p>
<p>&nbsp; &nbsp; left = prev&nbsp;</p>
<p>&nbsp; &nbsp; right = n&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; if left == right:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return left</p>
<p>&nbsp; &nbsp; mid = (left + right) // 2</p>
<p>&nbsp; &nbsp; &nbsp;if routine runs when using mid number of cores then return find_under_one(left, mid)</p>
<p>&nbsp; &nbsp; &nbsp;else if it doesn't run then return find_under_one(mid + 1 ,n)</p>",3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + O(10)</p>
<p>T(n) = T(n/2) + O(1)</p>",0.75,Graded,18157,essay,"<p>T(n/2)+O(1)</p>
<p>T(n/2) = O(log2(n)) + O(1)</p>
<p>O(log(n)) is the final answer and the asymptotic solution&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.75
Chupeng Xiong,441608,UW093W476,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 18:39:49 UTC,00:12:37,1,18054,essay,<p>T(n) = 2(T(n)) + n<br>T(1) = 1</p>,1.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,<p>Check if routine can run on n/2 cores<br>if can:<br>run algo on the lower half<br>if can't:<br>run algo on upper half<br>stop until routine cannot run under 1 second for any lower amount of cores</p>,3.0,Graded,18156,essay,"<p>T(n) = T(n/2)</p>
<p>T(1) = 1</p>",0.5,Graded,18157,essay,"<p>T(1) = 1<br>T(2) = n/2<br>T(3) = n/2^2<br>T(K) = n/2^k</p>
<p>O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.5
Henry Wong,517346,UW988S999,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 18:46:34 UTC,00:16:04,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>T(n) = T(2n/3) + n&nbsp;</p>
<p>T(1) = 1</p>",0.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + n</p>,0.0,Graded,18157,essay,"<p>T(n) = T(n/2) + 1</p>
<p>T(n/2) = T(n/2^2) + 1</p>
<p>T(n/2^2) = T(n/2^3) + 1</p>
<p>n= 2^k =&gt; k = log2n</p>
<p>T(n) = log2n + O(n)</p>
<p>T(n) = O(logn) + O(n) = O(nlogn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Sort: Sort the scores into ascending order</p>
<p>Divide: Recursively divide the potential scores into sub groups (lows and highs)</p>
<p>Conquer: For each sub group of scores, determine wether the right most (high) of that subgroup gives you an A. If it does, recursively split and repeat. If not, do not return any of the scores in that subgroup</p>
<p>Merge: Merge scores that were kept in the divide and conquer process.</p>",1.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Akshay Veeragandham,521419,UW995E227,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:25:39 UTC,00:15:36,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>The code is a recursive sort that sorts the first 2/3, the last 2/3, and then the first 2/3 again</p>
<p>Let T(n) be the running time on the array of length n</p>
<p>Base cases: T(1) = O(1), T(2) = O(1). They have constant time</p>
<p>Recursive case: each call makes three recursive calls on size[2n/3] and does O(1) extra work</p>
<p>T(n) = 3T([2n/3]) +O(1) for n &gt;= 3; T(1) = O(1), T(2) = O(1)</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0) = O91), T(1) = O(1), T(x) = T([x/2]) + O(1)</p>
<p>-x/2 is in a lower bound</p>",1.0,Graded,18157,essay,"<p>T(x) &lt;= T(lower bound(x/2))+c</p>
<p>&lt;= T(lowerbound(x/2^2)+kx</p>
<p>...</p>
<p>&lt;= T(lowerbound(x/2^k))+kc</p>
<p>Choose k = upperbound(log2(x)) so that x/2^k &lt;= 1. Using the base case T(1) = O(1),</p>
<p>T(x) &lt;= T(1) + c(upperbound(log2(x))) = O(log(x))</p>
<p>Lower bound is similar, so</p>
<p>T(x) = O(log(x))</p>
<p>which matches the fact that exponentiation by squaring does a logarithmnic number of multiplications.</p>",2.0,Graded,25540,essay,"<p>PowE(x):</p>
<p>&nbsp; if x == 0: return 1</p>
<p>&nbsp; if x == 1: return e</p>
<p>&nbsp; t = PowE([x/2])</p>
<p>&nbsp; t2 = t*t</p>
<p>&nbsp; if x is even:</p>
<p>&nbsp; &nbsp; return t2</p>
<p>&nbsp; else:</p>
<p>&nbsp; &nbsp; return t2*e</p>
<p>O(log x) multiplications instead of O(x)</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Tyler BELES,502366,UW960E196,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 18:06:39 UTC,00:21:25,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>T(n) = 2T(2n/3) + c</p>,2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>DC(n)</p>
<p>&nbsp; &nbsp; if n==1:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;return 1</p>
<p>mid = n / 2</p>
<p>left = DC(mid)</p>
<p>right = DC(n - mid)</p>
<p>&nbsp;if the routine runs for under 1 second on the&nbsp; left core then</p>
<p>&nbsp; &nbsp; &nbsp;return left</p>
<p>&nbsp;if the routine runs for under 1 second on the right core then&nbsp;</p>
<p>&nbsp; &nbsp; return right</p>
<p>return n&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,18156,essay,<p>T(n) = T(n/2) + c. The base case T(n) = 1</p>,0.0,Graded,18157,essay,"<p>Solve using recurrence tree. Top layer n. second layer n/2 and n/2. Third layer n/4, n/4, n/4, n/4 all the way to T(1). Thus we have n/2^k =1 which equals log2n = k. Therefore for our recurrence relation it is T(n) = T(1) + c * log2(n) which is asymptotic bounded by O(logn).&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Blake Pingel,434968,UW931P217,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 18:22:55 UTC,00:25:01,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n) = T(n/5) + T(4n/5) + T(3n/5) + c&nbsp; ; T(n) = O(1) n&lt;5</p>,3.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c; T(n) = O(1) n = 1</p>,1.0,Graded,18157,essay,"<p>1st level: c</p>
<p>2nd level 2 branches = n/2</p>
<p>3rd level 2 branches for each 2nd level branch = n/2^2</p>
<p>kth level = n/2^k</p>
<p>base case =1 so 1 = n/2^k -&gt; k = log2(n) plugging that back in we get c log2(n) = O( log n )</p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>algo( A[1....n])</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;i = 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;high = n</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;while i &lt; high:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle = (i + high/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if A[middle] &lt; A[middle + 1]:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = i + 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = middle</p>
<p>&nbsp; &nbsp; return i - 1</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>",2.5,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Aaron Dunk,488665,UW981B995,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 18:25:10 UTC,00:26:22,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>S(n) = S(n/2) + 2*S(n/4) + cn</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Let C start as list from 1 to n representing the amount of cores that could be used.&nbsp;</p>
<p>Input: list C</p>
<p>Output: the smallest number of cores that can run the routine in under 1 second</p>
<p>If C only has one element, return that element as the smallest number of cores that can run the routine in &lt;1 second</p>
<p>Let m be be the middle element in C, n\2 (or (n+1)\2 if m is odd).</p>
<p>If the routine runs in under 1 second on C[m] cores:</p>
<p>remove all elements in C that are greater than C[m]</p>
<p>call the algorithm again with this new C and return the output.</p>
<p>If the routine doesn't run in under 1 second on C[m] cores:</p>
<p>remove all elements in C that are less than or equal to C[m]</p>
<p>call the algorithm again with this new C and return the output.</p>
<p>&nbsp;</p>",3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + c; T(1) = 1</p>
<p>n is the size of the list C.</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c; T(n/2) = T(n/4) +c</p>
<p>T(n) = (T(n/4) + c) + c; T(n/4) = T(n/2^3) + c</p>
<p>T(n) = T(n/2^3) + c) +c +c</p>
<p>After k interations,&nbsp;</p>
<p>T(n) = T(n/2^k) + ck</p>
<p>Thinking about a recursion tree, each layer has only 1 call, and each of those layers run in constant time. So the sum of those layers is c times the number of layers. Let d be the number of layers when the algorithm reaches the base case. Using the base case, 1 = n\(2^d), and thus d = log_2(n). Therefore, the sum of all layers is c * log_2(n), which is O(log(n)).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Patrick Sun,426098,UW933V821,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 18:32:38 UTC,00:28:47,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 2(n/3) + O(n), and the base case is when the length of A is 1 or 2 and the runtime for base case is O(1)</p>",2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1) the base case in this situation would be O(1)</p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(n /4) + 2 * c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;= T(n / 8) + 3 * c</p>
<p>......</p>
<p>after k times breaking the recurrence relation:</p>
<p>T(n) = T(n / (2&nbsp; ^ k)) + k * c. in order for T to reach to the base case. k = log2n. So we have</p>
<p>T(n) = T(1) + c * log2n. Since T(1) = O(1) we have T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Divide and conquer algorithm would be as follow,&nbsp;</p>
<p>set left = 1, right = n and largest_x = None.</p>
<p>while left &lt;= right:</p>
<p>&nbsp; &nbsp; mid = bottom of (left + right) / 2</p>
<p>&nbsp; &nbsp; if A[mid] &lt;= k:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; largest = A[mid]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; set left = mid + 1 (this aims at searching the right side of the sorted list to seek for larger number)</p>
<p>&nbsp; &nbsp; else (A[mid] &lt; k):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; set right = mid - 1</p>
<p>return largest</p>
<p>this algorithm is dividing the array into half and recursively asking the range to shrink by half having the O(log n) runtime which fits with the requirement of divide and conquer, and if the array does not have a fitting largest x, then the algorithm would just return none.&nbsp;</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Ethan Pan,565547,UW988Z338,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:45:00 UTC,00:28:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>Base Case: if the array is smaller than 3, we simply return, the time complexity is O(1), a constant for this step</p>
<p>Induction Steps: We devided the entire array A into two sub part wich is the first 2/3 and second 2/3. Notice that there's an overlap. The complaxity for each layer will be T(n) = 2n(n(2/3)^2)+c, the layer is similar to merge sort, log 2/3 k.&nbsp;</p>
<p>Therefore the total complaxity will be O(log n)</p>",1.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>we have log n layer accoridng to the recursive tree, each layer we have 2 terms and run time for one is O(1), so the total run time complexity will be O(log n)</p>",0.0,Graded,18157,essay,<p>T(n) = log(n) * 2(O(1))</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Divide: For number k,</p>
<p>start wiuth j = 1&nbsp;</p>
<p>each time we apply on k = 2j and k = 2j+1, j++, untile a/b^i = 1 return</p>
<p>base case ka/b^i = 1 return i.&nbsp;</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Anwell Meng,501939,UW099Q776,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 20:06:14 UTC,00:20:56,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = 3T(n/5) + O(1)</p>
<p>Base case: T(n) = O(1) for n &lt; 5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>Algorithm does work in constant time for each run, and every run through cuts the work in half (n/2).&nbsp;</p>
<p>Base Case: T(1) = O(1) when n = 1.</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n/2) = T(n/4) + c, substituting this back in gives us:&nbsp; T(n) = T(n/4) + 2c. Substituting again gives us T(n/8) + 3c</p>
<p>Repeating this process we get: T(n) = T(n/ (2^k) ) + kc</p>
<p>We arrive at the base case when n/2^k = 1, which occurs when k = log2(n)</p>
<p>At this time T(n) = T(1) + clog2(n)</p>
<p>Since T(1) is constant, and c is constant, T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log2(n)).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>faster(N):</p>
<p>low = 1</p>
<p>high = N&nbsp;</p>
<p>answer = N</p>
<p>while low &lt;= high:</p>
<p>&nbsp; &nbsp; &nbsp;mid = (low + high) / 2</p>
<p>&nbsp; &nbsp; &nbsp;<span style=""font-size: 12pt;"">if GetService(mid):</span></p>
<p><span style=""font-size: 12pt;"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; answer = mid</span></p>
<p><span style=""font-size: 12pt;"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid - 1</span></p>
<p><span style=""font-size: 12pt;"">&nbsp; &nbsp; &nbsp;else:</span></p>
<p><span style=""font-size: 12pt;"">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + 1</span></p>
<p><span style=""font-size: 12pt;"">return answer</span></p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Ting Chang,521363,UW979H483,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 18:46:44 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = {c if n &lt; 4; 2T(n/4)+c if n&gt;=4} where c is a constant</p>,2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=T\left(\lceil\frac{n}{2}\rceil\right)+\Theta\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Clceil%255Cfrac%257Bn%257D%257B2%257D%255Crceil%255Cright)%252B%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\lceil\frac{n}{2}\rceil\right)+\Theta\left(1\right)"" data-equation-content=""T\left(n\right)=T\left(\lceil\frac{n}{2}\rceil\right)+\Theta\left(1\right)"" data-ignore-a11y-check=""""></p>",0.75,Graded,18157,essay,"<p><img class=""equation_image"" title=""T\left(n\right)\le T\left(\lfloor\frac{n}{2}\rfloor\right)+c"" src=""/equation_images/T%255Cleft(n%255Cright)%255Cle%2520T%255Cleft(%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor%255Cright)%252Bc?scale=1"" alt=""LaTeX: T\left(n\right)\le T\left(\lfloor\frac{n}{2}\rfloor\right)+c"" data-equation-content=""T\left(n\right)\le T\left(\lfloor\frac{n}{2}\rfloor\right)+c"" data-ignore-a11y-check=""""></p>
<p>apply repeatedly:</p>
<p><img class=""equation_image"" title=""T\left(n\right)\le\left(T\left(\lfloor\frac{n}{2}\rfloor\right)+c)+c\right)=T\left(\lfloor\frac{n}{2^2}\rfloor\right)+2c"" src=""/equation_images/T%255Cleft(n%255Cright)%255Cle%255Cleft(T%255Cleft(%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor%255Cright)%252Bc)%252Bc%255Cright)%253DT%255Cleft(%255Clfloor%255Cfrac%257Bn%257D%257B2%255E2%257D%255Crfloor%255Cright)%252B2c?scale=1"" alt=""LaTeX: T\left(n\right)\le\left(T\left(\lfloor\frac{n}{2}\rfloor\right)+c)+c\right)=T\left(\lfloor\frac{n}{2^2}\rfloor\right)+2c"" data-equation-content=""T\left(n\right)\le\left(T\left(\lfloor\frac{n}{2}\rfloor\right)+c)+c\right)=T\left(\lfloor\frac{n}{2^2}\rfloor\right)+2c"" data-ignore-a11y-check=""""> ... <img class=""equation_image"" title=""T\left(n\right)\le T\left(\lfloor\frac{n}{2^k}\rfloor\right)+kc"" src=""/equation_images/T%255Cleft(n%255Cright)%255Cle%2520T%255Cleft(%255Clfloor%255Cfrac%257Bn%257D%257B2%255Ek%257D%255Crfloor%255Cright)%252Bkc?scale=1"" alt=""LaTeX: T\left(n\right)\le T\left(\lfloor\frac{n}{2^k}\rfloor\right)+kc"" data-equation-content=""T\left(n\right)\le T\left(\lfloor\frac{n}{2^k}\rfloor\right)+kc"" data-ignore-a11y-check=""""></p>
<p>we would re</p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>We would use binary search to locate the index where the array switches from increasing to decreasing, this is where <img class=""equation_image"" title=""A_1"" src=""/equation_images/A_1?scale=1"" alt=""LaTeX: A_1"" data-equation-content=""A_1"" data-ignore-a11y-check=""""> meets <img class=""equation_image"" title=""A_2"" src=""/equation_images/A_2?scale=1"" alt=""LaTeX: A_2"" data-equation-content=""A_2"" data-ignore-a11y-check="""">:</p>
<p>if A[middle] &lt; A[middle + 1]:</p>
<p>&nbsp; &nbsp; search right half</p>
<p>else:</p>
<p>&nbsp; &nbsp; search left half</p>
<p>return index of peak. This is the index to the last element of <img class=""equation_image"" title=""A_1"" src=""/equation_images/A_1?scale=1"" alt=""LaTeX: A_1"" data-equation-content=""A_1"" data-ignore-a11y-check="""">, which we could use to calculate the length (+1 if index starts at 0)</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.25
Camilla Liu,433416,UW113P251,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 18:45:00 UTC,00:24:54,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n)=1 for n&lt;4</p>
<p>and T(n)=2T(n/4)+1 for n4</p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)=1 for n1</p>
<p>T(n) = T(n/2)+1 for n&gt;1</p>",1.0,Graded,18157,essay,"<p>T(n)= T(n/2)+c = T(n/4)+2c = T(n/8)+3c = T(n/2^k)+kc</p>
<p>Base case: n/2^k=1, so k = <img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">n</p>
<p>Since T(1) is constant, T(n)= C + c<img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">n, so T(n)=logn</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>FindLargest(A,k):</p>
<ol style=""list-style-type: decimal;"">
<li>if A is empty: return none;</li>
<li>mid = length(A)/2;</li>
<li>If A[mid]==k; return A[mid];</li>
<li>if A[mid] &lt; k<br>
<ul style=""list-style-type: disc;"">
<li>result = FindLargest(first half of A, k)</li>
<li>if result = None: return A[mid]</li>
<li>else: return result</li>
</ul>
</li>
<li>else: return FindLargest(second half of A, k)</li>
</ol>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Caleb Cho,326710,UW850E318,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 20:24:11 UTC,00:27:15,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>Recurrence : 3T(2n/3)+ 0(n)</p>
<p>where 0 = big O notation<br><br>Base case: T(1) = 0(1)</p>",1.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>Recurence = T(n/2) + 0(n)<br>where 0 =&nbsp; big 0 notation<br><br>Base case: T(1) = O(1)</p>,0.5,Graded,18157,essay,<p>first (t(n/2) +0(n)<br>second (t(n/2^2) + ...<br>third t(n/2^4) + ...<br><br>n/2^k + ...<br><br>fininte geometric series<br>1/2(n) ^ k<br>1/2log(n) &lt;= 1<br><br>0(log n)</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>BSearch(n, r)</p>
<p>if( left = right){<br>return left;<br>}<br>mid = divide(n /2) by left and right;<br>if(GetsService(mid)){<br>return BSearch(left, mid);<br>}<br>else{</p>
<p>return( mid, right + 1);</p>
<p>}</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.0
Haosen Kang,521211,UW103B182,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 18:48:47 UTC,00:25:59,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" width=""13"" height=""16"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(2) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(n) = 3T(2n/3) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)&nbsp; &nbsp; (n&gt;2)</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",1.0,Graded,18157,essay,"<p>c means constant&nbsp;</p>
<p>T(n) = T(n/2) + c</p>
<p>=T(n/4) + 2c</p>
<p>=T(n/8)+3c</p>
<p>..... = T(1) +c <img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">n&nbsp;</p>
<p>Since T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) we get T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(<img class=""equation_image"" title=""\log n"" src=""/equation_images/%255Clog%2520n?scale=1"" alt=""LaTeX: \log n"" data-equation-content=""\log n"" data-ignore-a11y-check="""">)</p>
<p>runs in <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>We use a DC binary search to find the smallest x <img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check=""""> k , Algorithm :&nbsp;</p>
<p>LowerBound(A,K):</p>
<p>&nbsp; &nbsp; &nbsp;if A[n] &lt; k:&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return ""None""</p>
<p>&nbsp; &nbsp; &nbsp; lo <img class=""equation_image"" title=""\leftarrow"" src=""/equation_images/%255Cleftarrow?scale=1"" alt=""LaTeX: \leftarrow"" data-equation-content=""\leftarrow"" data-ignore-a11y-check=""""> 1</p>
<p>&nbsp; &nbsp; &nbsp; hi <img class=""equation_image"" title=""\leftarrow"" src=""/equation_images/%255Cleftarrow?scale=1"" alt=""LaTeX: \leftarrow"" data-equation-content=""\leftarrow"" data-ignore-a11y-check=""""> n</p>
<p>&nbsp; &nbsp; &nbsp; ans &lt;-&nbsp; ""None""</p>
<p>&nbsp; &nbsp; &nbsp;while lo <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> hi :</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mid <img class=""equation_image"" title=""\leftarrow"" src=""/equation_images/%255Cleftarrow?scale=1"" alt=""LaTeX: \leftarrow"" data-equation-content=""\leftarrow"" data-ignore-a11y-check=""""> floor((lo+hi)/2)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if A[mid] <img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check=""""> k :</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans <img class=""equation_image"" title=""\leftarrow"" src=""/equation_images/%255Cleftarrow?scale=1"" alt=""LaTeX: \leftarrow"" data-equation-content=""\leftarrow"" data-ignore-a11y-check=""""> A[mid]</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hi <img class=""equation_image"" title=""\leftarrow"" src=""/equation_images/%255Cleftarrow?scale=1"" alt=""LaTeX: \leftarrow"" data-equation-content=""\leftarrow"" data-ignore-a11y-check=""""> mid -1&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo <img class=""equation_image"" title=""\leftarrow"" src=""/equation_images/%255Cleftarrow?scale=1"" alt=""LaTeX: \leftarrow"" data-equation-content=""\leftarrow"" data-ignore-a11y-check=""""> mid +1</p>
<p>&nbsp; &nbsp; &nbsp; return ans&nbsp;</p>
<p>&nbsp; Each of my recursive step divide the problem size by 2, and each step cost O(1) work to do</p>
<p>&nbsp;</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Annabelle Zhang,208732,UW812Q322,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 21:29:39 UTC,00:25:49,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>3T(2n/3) + c, T(1) = 0</p>",2.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>2T(n/2) + cn, T(1) = 0</p>",0.0,Graded,18157,essay,"<p>Using substitution:</p>
<p>T(n) = 2T(n/2) + cn = 2(2T(n/4) + n) + n = 2<sup>3</sup>T(n/2<sup>3</sup>) + 7n = .....= 2<sup>k</sup>T(n/ 2<sup>k</sup>) + (k-1)n</p>
<p>At base case n/2<sup>k&nbsp;</sup>= 1, n = 2<sup>k</sup>, k = logn&nbsp;</p>
<p>T(n) = nT(1) + (logn - 1)n = nT(1) + nlogn - n</p>
<p>Thus the time complexity is O(nlogn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Algorithm name: QuickSort()</p>
<p>Input: Array A[1....n], the sorted list of elements; number k, the index</p>
<p>Output: number x as the largest number if x exists, ""none"" if x is not found</p>
<p>p := k &lt;-p is the chosen pivoit</p>
<p>if A[1] &gt; k then return ""none""</p>
<p>if end</p>
<p>r := partition(A[1....n], p)</p>
<p>i:= current element index</p>
<p>if k&lt;r do QuickSort(A[1....r-k], k)</p>
<p>else if k&gt;r do QuickSort(A[i+1....n], k)</p>
<p>else return A[r]</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",0.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Michael Chen,383485,UW904S500,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:32:32 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n) = T(n/5) +T(4n/5)+T(3n/5)+O(1)</p>,2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = (n/2) + O(1)</p>,0.75,Graded,18157,essay,"<p>T(n) = T(n/2) + O(1) =</p>
<p>T(n/4) + 2O(1) =</p>
<p>T(n/8) + 3O(1)&nbsp;</p>
<p>n/2^k = 1, 2^k = n, k = logn</p>
<p>O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Function takes parameter x, start, end. Set two variables begin and end, begin to 0 and end to x. Set variable r to (begin + end) / 2. If x==r*r return r, else if x is greater recurse with r+1 as begin parameter, else if x less than recurse with r-1 as end parameter.</p>",3.0,Graded,0,0,0,9.0,8.25
Sashvath Karthik,542384,UW103A495,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 19:34:04 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(n) = 3(2n/3) + O(2), as base case has swapping as O(1) as only swapping is done icasen the base , set is divided by 2/3 per call, and there are 3 recursive calls.</p>",2.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Now, each recurrence call divides the size (n) by 2, and there are 2 recurrence calls. Also, the work done in each recurrence call is a comparision, including the base cases, and a joining step, all of which are constant time.</p>
<p>T(n) = 2*T(n/2) + O(1) is the recurrence relation.</p>",0.0,Graded,18157,essay,"<p>For the above recurrence relation, take O(1) as some constant c.</p>
<p>We have T(n) = 2*(T(n/2)) + c = 2*(2*T(n/4) + c) + c = 4*T(n/4) + 3c = 4*(2*T(n/8) + c) + 3c = 8*T(n/8) + 7c</p>
<p>So, we get T(n) = 2^k * T(n/(2^k)) + (2^k - 1)c, where k is the height of the tree. Since the base case is at T(1), we have n/ (2^k) = 1, or k = log<sub>2</sub>n</p>
<p>We know 2^log<sub>2</sub>n = n, so 2^k = n. Substituting for k, we get T(n) as O(log n), as recursion height is log2(n), and the total cost per level is (2^k - 1)c&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Take the sorted array A as the input, and the number k as well.</p>
<p>If A[1] &lt; k, then return None</p>
<p>If |A| = 1 and A[1] &lt; k, return A[1]</p>
<p>First let the size of the array be n. Split the array in half, leaving n/2 elements in each half, and recursively call the method for the left and right halves, assigning their return values to left and right respectively.</p>
<p>For the comparision step there are 3 cases:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if the value of the left subarray is None, return None.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if the value of the left subarray is not None, and the right subarray is None, return the value of the left subarray.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if the value of the left subarray and the right subarray is not none, then return the value of the right subarray.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;Join the 2 subarrays and return them as well, returning (Joined array, max value)</p>",1.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
Eric Du,568509,UW107B285,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 19:04:54 UTC,00:20:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) = 2T(n/3)+n/3</p>,2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Algorithm: BinaryCores</p>
<p>given i cores</p>
<p>let j = number of cores we are testing runtime on</p>
<p>//base cases:</p>
<p>if i = 1, return i</p>
<p>begin<br>&nbsp; while j <img class=""equation_image"" title=""\ne"" src=""/equation_images/%255Cne?scale=1"" alt=""LaTeX: \ne"" data-equation-content=""\ne"" data-ignore-a11y-check="""">i</p>
<p>&nbsp; &nbsp; j = i / 2;&nbsp;</p>
<p>&nbsp; &nbsp;if routine runs in under 1 second on j cores, j = j / 2, i = j;<br>&nbsp; &nbsp; else, j = (j + i) /2</p>
<p>&nbsp; &nbsp; end</p>
<p>&nbsp; end</p>
<p>return j;&nbsp;</p>
<p>end</p>",3.0,Graded,18156,essay,"<p>T(n)&nbsp; <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> 2T(n/2) + c (assuming each experiment of routine running &lt; 1 second is constant)</p>
<p>Base Case T(1) = c</p>",0.25,Graded,18157,essay,"<p>Recursion Tree:</p>
<p>Step n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 time&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= c<br>step n/2&nbsp; &nbsp; &nbsp; 2 times&nbsp; &nbsp; &nbsp; c/2 c/2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = c</p>
<p>step n/2^2 4 times&nbsp; &nbsp; &nbsp; c/2^2&nbsp; c/2^2 c/2^2 c/2^2&nbsp; &nbsp; &nbsp; = c</p>
<p>step n/2^k 2^k times&nbsp; c/2^k c/2^k c/2^k ...............&nbsp; &nbsp; &nbsp;= c</p>
<p>figuring out how many steps we have n/(2^k) = 1, so k = log2n,</p>
<p>Base case T(1) = c, every step has cost c for log2n steps = c * log2n<br><br></p>
<p>so, our algorithm is O(c*log2n)</p>
<p>which simplifies to O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.75
Blake Weichbrodt,505956,UW998Q774,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:35:38 UTC,00:29:02,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>T(n) &lt;= 3T(2n/3) + c; T(1) = 1</p>,2.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n/2) + c; T(1) = 1 (assuming looking up a score takes constant time c)</p>,1.0,Graded,18157,essay,"<p>Unrolling Method:</p>
<p>T(n) &lt;= T(n/2) + c</p>
<p>T(n) = T(n/4) + c + c</p>
<p>...</p>
<p>(for the kth call)&nbsp;</p>
<p>...</p>
<p>T(n) = T(n/2^k) + kc</p>
<p>&nbsp;</p>
<p>We know T(1) = 1 and that n/2^k = 1</p>
<p>So n = 2^k -&gt; k = logn</p>
<p>Substituting in k = logn, we get...</p>
<p>T(n) &lt;= T(n/2^k) + clogn</p>
<p>and substituting in 1 = n/2^k we get...</p>
<p>T(n) &lt;= T(1) + clogn</p>
<p>T(n) &lt;= 1 + clogn</p>
<p>This gives...</p>
<p>O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>Algo</p>
<p>inputs: i := Current score to check</p>
<p>outputs: minimum number of points i that give you an A on the final</p>
<p>// Base Case</p>
<p>if i == minimum num points then</p>
<p>&nbsp; &nbsp; &nbsp;return i</p>
<p>// Recursive Case</p>
<p>else if i &lt; minimum num points then</p>
<p>&nbsp; &nbsp; &nbsp;return Algo(i/2) // Recurse on left side</p>
<p>else</p>
<p>&nbsp; &nbsp; &nbsp;return Algo(i + i/2) // Else, recurse on right side</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>(This is basically a binary search)</p>",2.5,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
Sophia Chen,507456,UW999S906,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 19:17:59 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n)=T(n/2)+2T(n/4)+1; T(1)=1</p>,2.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + 1 ; T(1)=1</p>,1.0,Graded,18157,essay,"<p>have recurrence relation</p>
<p>first level you have constant c for cost</p>
<p>then each next level n/2 size but cost at each level is still constant, which we know because isqrt() is done in O(1) time</p>
<p>C * depth of tree</p>
<p>know depth of tree is n/2^k = 1&nbsp;</p>
<p>which gives logn&nbsp;</p>
<p>so C*logn</p>
<p>This gives O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Return: value of k</p>
<p>Divide: Use the isqrt(a) algorithm and recursively call this on a until you get to a = 1&nbsp;</p>
<p>Conquer: You multiply the value of a by itself the number of times the recursive calls were made. (for example if a=8 and 1 recursive call was made, mutiply 8 by itself once, 8 times 8 = 64). So, value of k is the number of times isqrt() (the recursive function) was called. Return k.&nbsp;</p>
<p>Base case: when a = b then return k = 0</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Hunter Chan,517383,UW110W853,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 21:46:11 UTC,00:28:31,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2) + 2*T(n/4) + O(n) where n is the size of array A</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = T(k/2) + O(1), where k is the exponent represented in a = b^k</p>",0.75,Graded,18157,essay,"<p>T(k) = T(k/2) + O(1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = T(k/4) + O(1)&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = T(k/8) + O(1) therefore we have T(k) = T(k/2^i) + O(1) therefore solving for 1 = n/2^i is equivalent to O(logn) runtime complexity. O(logn + 1) ammoritzed to O(logn) thus O(logn) is our solution.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Algorithm:&nbsp;</p>
<p>Input a,b: a,b in N \ {0}</p>
<p>Base case: If a = 1 then return that k = 0. If b = 0 and a = 0, return 0 for no valid solution. If b = 1 and a = 1 then there is no solution or assume k = 1</p>
<p>we check whether a is a perfect square. If it is we recurse on isqrt(a) to get k/2 and multiply that value by 2, (2*k/2) to get k. If it is not a perfect square then we recurse on isqrt(a) to get (k-1)/2 and return k as 2*((k-1)/2) + 1. Otherwise we handle the case where it is a perfect square or not by returning null or 0 to indicate that no such k exists.&nbsp;</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,8.25
Anna Zhu,582412,UW107J670,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 19:18:47 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p><img class=""equation_image"" title=""S(n) = 2(\frac{2}{3}n) + c"" src=""/equation_images/S(n)%2520%253D%25202(%255Cfrac%257B2%257D%257B3%257Dn)%2520%252B%2520c?scale=1"" alt=""LaTeX: S(n) = 2(\frac{2}{3}n) + c"" data-equation-content=""S(n) = 2(\frac{2}{3}n) + c"" data-ignore-a11y-check="""">, S(1) = 1, <img class=""equation_image"" title=""S(2) = 1"" src=""/equation_images/S(2)%2520%253D%25201?scale=1"" alt=""LaTeX: S(2) = 1"" data-equation-content=""S(2) = 1"" data-ignore-a11y-check=""""> for some constant c</p>",2.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""R(n) = R(\frac{1}{2}n) + c"" src=""/equation_images/R(n)%2520%253D%2520R(%255Cfrac%257B1%257D%257B2%257Dn)%2520%252B%2520c?scale=1"" alt=""LaTeX: R(n) = R(\frac{1}{2}n) + c"" data-equation-content=""R(n) = R(\frac{1}{2}n) + c"" data-ignore-a11y-check="""">, <img class=""equation_image"" title=""R(0) = 1"" src=""/equation_images/R(0)%2520%253D%25201?scale=1"" alt=""LaTeX: R(0) = 1"" data-equation-content=""R(0) = 1"" data-ignore-a11y-check="""">, <img class=""equation_image"" title=""R(1) = 1"" src=""/equation_images/R(1)%2520%253D%25201?scale=1"" alt=""LaTeX: R(1) = 1"" data-equation-content=""R(1) = 1"" data-ignore-a11y-check=""""> for some constant c.<br><br>note: this recurrence is written with&nbsp;<em>n</em> as the factor for which R(n) grows asymptotically by convention; however, the equation above is written such that&nbsp;k, the power, &nbsp;is the factor of asymptotic growth.</p>",1.0,Graded,18157,essay,"<p>The recurrence has&nbsp;<em>k</em> layers, each with <em>c</em> work being done. Our base case occurs when&nbsp;<em>n&nbsp;</em>= 0, or&nbsp;<em>n = 1</em>; by nature of our splitting function our function will hit 0 or 1 at the same time. Thus, we can set up an equation for&nbsp;<em>k:&nbsp;</em><img class=""equation_image"" title=""(\frac{1}{2})^k \cdot n = 1\\
n = 2^k\\
k = \log_2n"" src=""/equation_images/(%255Cfrac%257B1%257D%257B2%257D)%255Ek%2520%255Ccdot%2520n%2520%253D%25201%255C%255C%250An%2520%253D%25202%255Ek%255C%255C%250Ak%2520%253D%2520%255Clog_2n?scale=1"" alt=""LaTeX: (\frac{1}{2})^k \cdot n = 1\\
n = 2^k\\
k = \log_2n"" data-equation-content=""(\frac{1}{2})^k \cdot n = 1\\
n = 2^k\\
k = \log_2n"" data-ignore-a11y-check=""""></p>
<p>This gives us the recurrence:&nbsp;<br><br><img class=""equation_image"" title=""R(n) = \Sigma_{k =0}^{\log_2n} c + \log_2n \cdot 1"" src=""/equation_images/R(n)%2520%253D%2520%255CSigma_%257Bk%2520%253D0%257D%255E%257B%255Clog_2n%257D%2520c%2520%252B%2520%255Clog_2n%2520%255Ccdot%25201?scale=1"" alt=""LaTeX: R(n) = \Sigma_{k =0}^{\log_2n} c + \log_2n \cdot 1"" data-equation-content=""R(n) = \Sigma_{k =0}^{\log_2n} c + \log_2n \cdot 1"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""R(n) = c\cdot \Sigma_{k=0}^{\log_n2} 1 + log_2n"" src=""/equation_images/R(n)%2520%253D%2520c%255Ccdot%2520%255CSigma_%257Bk%253D0%257D%255E%257B%255Clog_n2%257D%25201%2520%252B%2520log_2n?scale=1"" alt=""LaTeX: R(n) = c\cdot \Sigma_{k=0}^{\log_n2} 1 + log_2n"" data-equation-content=""R(n) = c\cdot \Sigma_{k=0}^{\log_n2} 1 + log_2n"" data-ignore-a11y-check=""""></p>
<p><img class=""equation_image"" title=""R(n) = c \cdot log_2n + log_2n"" src=""/equation_images/R(n)%2520%253D%2520c%2520%255Ccdot%2520log_2n%2520%252B%2520log_2n?scale=1"" alt=""LaTeX: R(n) = c \cdot log_2n + log_2n"" data-equation-content=""R(n) = c \cdot log_2n + log_2n"" data-ignore-a11y-check=""""><br><br>Thus we can say that <img class=""equation_image"" title=""R(n) \in O(\log n)"" src=""/equation_images/R(n)%2520%255Cin%2520O(%255Clog%2520n)?scale=1"" alt=""LaTeX: R(n) \in O(\log n)"" data-equation-content=""R(n) \in O(\log n)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Function RecursivePower</p>
<p>Input: n, k: Base n &gt; 0, Exponent k &gt;= 0.<br>Output: power: the value of n^k</p>
<p>&nbsp;</p>
<p>begin:</p>
<p>&nbsp; &nbsp; if k = 0,</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 1;</p>
<p>&nbsp; &nbsp; else if k = 1</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return n;</p>
<p>&nbsp; &nbsp; &nbsp;end if</p>
<p>&nbsp; &nbsp; &nbsp;a = RecursivePower(n, floor(k / 2));</p>
<p>&nbsp; &nbsp; &nbsp;if (k is even)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return n^2<br>&nbsp; &nbsp; &nbsp; else (k is odd)<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return (n^2) * n</p>",2.5,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
Maxwell Wang,492517,UW987A086,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 20:33:18 UTC,00:29:19,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2) + 2T(n/4) + O(n) and T(1) = 1&nbsp;</p>,3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = T(k/2) + O(1), and&nbsp; T(1) = O(1) T(0) = O(1)</p>",1.0,Graded,18157,essay,"<p>Recurrence tree has O(1) work done at every layer, and k is halved at every layer, so it would have a depth of log2(k) elements</p>
<p>The value of T(k) would therefore be the summation 1 to log2(k) of O(1), which is log2(k)</p>
<p>log2(k) = O(logk)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>FindK:</p>
<p>Inputs a, b, k: a, b <img class=""equation_image"" title=""\in"" src=""/equation_images/%255Cin?scale=1"" alt=""LaTeX: \in"" data-equation-content=""\in"" data-ignore-a11y-check=""""> (<img class=""equation_image"" title=""\mathbb{N}"" src=""/equation_images/%255Cmathbb%257BN%257D?scale=1"" alt=""LaTeX: \mathbb{N}"" data-equation-content=""\mathbb{N}"" data-ignore-a11y-check=""""> \ {0})</p>
<p>Base Case a == 1, return k = 0</p>
<p>Base Case: a == b, return k = 1</p>
<p>new_a = isqrt(a)</p>
<p>k = FindK(new_a, b)</p>
<p>if k even: return 2 * k</p>
<p>if k odd: return 2 * k + 1</p>
<p>Starting, run FindK(a, b)</p>",2.5,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Jaylen Korth,487356,UW982K837,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 19:25:00 UTC,00:24:30,1,18054,essay,<p>C(n) = (n/2) + n</p>,0.5,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>S(n) = S(n/2) * n + 1</p>,0.0,Graded,18157,essay,"<p>S(n) = S(n/2) * n + 1</p>
<p>S(n) = log(n) * n</p>
<p>O(n) = nlog(n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>begin</p>
<p>r = 0</p>
<p>return findSmallestRange(r);</p>
<p>end</p>
<p>&nbsp;</p>
<p>findSmallestRange(r) {</p>
<p>if(GetsService(r) == True &amp;&amp; GetsService(r - 1) == False)</p>
<p>return r;</p>
<p>else</p>
<p>if (r &gt; n)</p>
<p>findSmallestRange(r - 1)</p>
<p>if(r &lt; n)</p>
<p>findSmallestRange(r*2)</p>
<p>}</p>
<p>&nbsp;</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.5
Jason Ge,504403,UW988F320,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:00:30 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>O(n log n)</p>,0.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>O(log n)</p>,0.0,Graded,18157,essay,"<p>T(n) = T(n/2) + C</p>
<p>T(n/2) = c/2</p>
<p>T(n/4) = c/4</p>
<p>...</p>
<p>T(n) = T(n/2^i) + C</p>
<p>height = log n&nbsp;</p>
<p>T(n) = log n * T(1) + C</p>
<p>O(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Algorithm for finding minDistance</p>
<p>&nbsp;</p>
<p>base case: getsService(max) = true return binarysearch of (min, max)</p>
<p>//use binarysearch and check if it still equals true and if it does keep binaryseraching till you find the first one that becomes true</p>
<p>we start with a with a min of 0 and a max of 1.</p>
<p>As long getsService(max) does not equal true we recursevily expand the max * 2, while updating the the min to be the previous max</p>
<p>&nbsp;</p>
<p>binarysearch is o(logn)</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Lance Munson,424195,UW930Z869,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:22:00 UTC,00:29:45,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) <img class=""equation_image"" title=""\leq"" src=""/equation_images/%255Cleq?scale=1"" alt=""LaTeX: \leq"" data-equation-content=""\leq"" data-ignore-a11y-check=""""> 3T(n/5) + cn, T(n) = 1</p>",1.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n)<img class=""equation_image"" title=""\leq"" src=""/equation_images/%255Cleq?scale=1"" alt=""LaTeX: \leq"" data-equation-content=""\leq"" data-ignore-a11y-check=""""> 2T(n/2) + cn, T(n) = 1</p>",0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>recursiveSqr(x):</p>
<p>begin&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if (x == 1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1</p>
<p>&nbsp; &nbsp; &nbsp; count1 = recursiveSqr(x/2)&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; count2 = recursiveSrt(x/2)</p>
<p>&nbsp; &nbsp; &nbsp; return count1 + count2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,0,0,0,9.0,2.5
Annie Povich,499511,UW962G087,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 19:36:57 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n) = 3T(n/5)+O(1)</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c base case= n&gt;0</p>,1.0,Graded,18157,essay,"<p>reccurance tree im gonna do my best to type it out,&nbsp;</p>
<p>c</p>
<p>n/2&nbsp; &nbsp; &nbsp;n/2 cost -&gt; 2n/2 = n</p>
<p>n/2^2&nbsp; &nbsp;n/2^2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n/n^2&nbsp; &nbsp;n/2^2 cost -&gt; 4 n/2^2 = n</p>
<p>n/2^3 ..... for all the branches on this row&nbsp; 8 n/2^3 = n</p>
<p>eventually we get n^k n/2^k</p>
<p>n/2^k = 1 k = log(sub 2) n, n^k and the sub 2 aren't relavant for the runtime</p>
<p>so we get</p>
<p>O(n) = log(n)</p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>power(base, k)</p>
<p>k = 0 return 1</p>
<p>if k is even</p>
<p>x= recursively call power(base, k/2)</p>
<p>return&nbsp; x times x</p>
<p>else (k odd)</p>
<p>x = recursively call power(base, k-1/2)</p>
<p>return base times x times x</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Jane Park,509948,UW100A224,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 19:19:33 UTC,00:12:02,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) : running time of SuperMax on an array of length n</p>
<p>T(n) = 1 if n &lt;= 2</p>
<p>T(n) = 2T(n/3) + n if n &gt; 2&nbsp;</p>
<p>because the algorithm makes two recursive calls on subarrays of size n/3 and scans the first one third of the array which takes linear time</p>",2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(k) = T(k/2) + 1 with base case T(1) =1</p>,1.0,Graded,18157,essay,"<p>T(k) = T(k/2) + c</p>
<p>= T(k/4) + 2c</p>
<p>= T(k/8) + 3c</p>
<p>....&nbsp;</p>
<p>= T(1) + Clog2k</p>
<p>since T(1) is a constant : T(k) = logk</p>
<p>&nbsp;</p>
<p><img class=""equation_image"" title=""\therefore"" src=""/equation_images/%255Ctherefore?scale=1"" alt=""LaTeX: \therefore"" data-equation-content=""\therefore"" data-ignore-a11y-check="""">T(k) = T(k/2) + c = T(1) + clog2k = log k</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>FindK(a,b):</p>
<p>if a == 1 : return 0</p>
<p>if a == b: return 1</p>
<p>c = isqrt(a)</p>
<p>k_half = FindK(c,b)</p>
<p>if <img class=""equation_image"" title=""b^{\left\lbrack\frac{k}{2}\right\rbrack}"" src=""/equation_images/b%255E%257B%255Cleft%255Clbrack%255Cfrac%257Bk%257D%257B2%257D%255Cright%255Crbrack%257D?scale=1"" alt=""LaTeX: b^{\left\lbrack\frac{k}{2}\right\rbrack}"" data-equation-content=""b^{\left\lbrack\frac{k}{2}\right\rbrack}"" data-ignore-a11y-check=""""> == a:&nbsp;</p>
<p>return 2*k/2</p>
<p>else: return 2*k/2 +1</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Uzair Ahmed,519836,UW951U823,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 19:29:59 UTC,00:23:08,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n) = { O(1), if n =&lt; 4 (Base case)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2T(n/4) + O(1), if n &gt; 4}</p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c , Base case: T(1) = d</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n) = [T(n/4) + c] + c = T(n/4) + 2c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n/2^k = 1 -&gt; k = log2n</p>
<p>T(n) = T(n/8) + 3c</p>
<p>T(n) = T(1) + c * log2n = d + clogn</p>
<p>So, T(n) = (logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>1. Pick the middle position, mid, from current range</p>
<p>2. compare element at mid with the element directly on right mid + 1</p>
<p>if element at mid &lt; element mid + 1, then your still in increasing part amd continue searching the right part</p>
<p>if element at mid &gt; element mid + 1, then your at the peak or in the decreasing part, continue searchin left and mid</p>
<p>3. repeat, each time you eliminate half, until one element is left, which is the peak</p>",2.5,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Garrick Fuller,484467,UW979A588,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 19:38:17 UTC,00:29:36,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>T(n) = 2T(2/3 * n) + 1 <br>T(3)&nbsp; = 1</p>,2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Def improvePerformance(n) where l and h are the low and high bounds, n is the number of cores</p>
<p>l = 0</p>
<p>h = n</p>
<p>ans = 0</p>
<p>while l &lt;= h:</p>
<p>&nbsp; &nbsp; &nbsp;middle = (l + h) / 2 (rounding up)</p>
<p>&nbsp; &nbsp; &nbsp;if it runs in less than 1 second on middle cores</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = middle</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;l = mid + 1</p>
<p>&nbsp; &nbsp; &nbsp;else: h = mid - 1<br><br></p>
<p>return ans</p>",3.0,Graded,18156,essay,<p>T(N) = T(N/2) + 1<br>T(1) = 1</p>,1.0,Graded,18157,essay,"<p>With T(n/2) +1, we are cutting our work in half every single time of our input as we choose a middle value and go left or right, cutting the list in half. This gives us log n layers as it forms a tree, with O(1) work at each step. That means that our solution is O(log(n)) as we have log(n) layers and O(1) work each time.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Ishaan Kharbanda,548890,UW110S127,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 19:44:06 UTC,00:20:49,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,<p>Base case: when the input array A has a length of 1 or 2 the algorithm&nbsp; performs a constant number of operationds&nbsp; therefore the runtime is constant so as O(1)<br><br>Recursive case:<br>for n&gt;2<br>2T(n/3) the algorithm makes 2 recursive calls on the first third of the array and and on the last thrid so each as a size of subproblem as n/3<br><br>so it is O(n) as it iterates through the middle third of the array this loop runs n/3 times and since the work inside the loop is constain time the total work for the loop is proportional to the size of this segment which is O(n)</p>,2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>Base case: T(0)=O(1)<br>recursive case: T(x)=T(floor(x/2))+o(1)<br>for x&gt;0<br><br>reasoning:<br>for x&gt;0 the algorithm makes exactly one recursive call the size of the nre subproblem is the floor of x/2 . this is the divide as usual<br><br>o(1):<br>after the recursive call returns the algorith performs a constant number of operations in the worst case it performs 2 multiplications half* half anf result*e hence its O(1)</p>,1.0,Graded,18157,essay,"<p>T(x)=T(floor(x/2))+o(1)<br>T(0)=o(1)<br><br><br>using unrolling:<br>T(x)=T(x/2)+c<br>T(x)=((T(x/4)+c)+c<br>.<br>.<br>.<br>T(x)=T(x/2^k)+k.c<br>and it stops for base case T(1)</p>
<p>so x/2^k=1<br>k=log_2(x)</p>
<p>&nbsp;</p>
<p>T(x)=T(1)+log2(x).c<br>and since t(1) is anyways constant T(x) is of the order of O(logx)</p>",2.0,Graded,25540,essay,"<p>fn power(e,x){<br>base case :<br>if x==0 then return 1<br><br>recursively calculate e^x/2&nbsp;<br>half=power(e,floor(x/2))</p>
<p>then result = half*half<br><br></p>
<p>//if x is odd tho we need one extra computations<br><br>if x is odd then&nbsp;<br>result = result*e<br><br>return result</p>
<p>}</p>",3.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Ryan Ruhland,481111,UW880H200,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 19:36:32 UTC,00:20:53,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>T(1) = 1</p>
<p>T(n) &lt;= T(n/2) + T(n/4) + T(n/4) + n</p>",3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = 1</p>
<p>T(n) &lt;= 2*T(n/2) + 1</p>",0.0,Graded,18157,essay,"<p>T(n) &lt;= 2*T(n/2) + 1</p>
<p>T(n) &lt;= 2*( 2*T(n/4) + 1 ) + 1</p>
<p>T(n) &lt;= 2*( 2*( 2*T(n/8) + 1 ) + 1 ) + 1</p>
<p>And since T(1) = 1, T(n) &lt;= 2^k + k where k = log(n)</p>
<p>Making it O(log(n))</p>",0.0,Graded,25540,essay,"<p>exp(x):</p>
<p>&nbsp; &nbsp;if x == 1, return e</p>
<p>&nbsp; &nbsp;else:</p>
<p>&nbsp; &nbsp; &nbsp; if x odd:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return exp(x//2) * exp(x//2+1)</p>
<p>&nbsp; &nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return exp(x/2) * exp(x/2)</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Shreyansh Jain,480148,UW102A477,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 20:52:54 UTC,00:28:32,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n)&lt;= 2T(n/3)+cn;</p>
<p>T(1)=1;</p>
<p>T(2)=2;</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n)&lt;=T(n/2)+cn; T(1) = 1;</p>,0.0,Graded,18157,essay,"<p>T(n)&lt;=T(n/2)+cn;</p>
<p>T(n/2)&lt;=T(n/4)+cn/2</p>
<p>T(n/ 2 <sup>k</sup>) &lt;= T(n/2 <sup>k&nbsp;</sup>)+(2k+1/2)cn</p>
<p>taking k = log&nbsp;<sub>2&nbsp; n; </sub></p>
<p>T(n/log k) = T(1)+ (2logn +1)/2 n&nbsp;</p>
<p>T(n/log k ) = log n&nbsp;&nbsp;</p>
<p>this is solve down to O(log n )</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>We will use a modified binary search here&nbsp;</p>
<p>pseudocode -&nbsp;</p>
<p>logfunction(a , b , min , max)</p>
<p>min = 1 (when we call it at the start)</p>
<p>max = b <sup>a</sup>; (when we call it initaially)</p>
<p>if (max ==1){</p>
<p>return a;</p>
<p>}</p>
<p>if (b<sup>max</sup><sup>&nbsp;</sup>==a){</p>
<p>return a;</p>
<p>} else if (b&nbsp;<sup>max</sup> &gt; a){</p>
<p>&nbsp; &nbsp; &nbsp;max = isqrt(b <sup>a</sup>);</p>
<p>&nbsp; &nbsp; &nbsp;logfunction(a,b,min,max)</p>
<p>} else {</p>
<p>min = b<sup>a&nbsp;</sup></p>
<p>logfunction(a,b,min,max)</p>
<p>}</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Navya Pangarkar,487688,UW105R486,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 19:57:45 UTC,00:29:18,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>Base case is length of the array being less than 5. so T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) for a n less than 5.</p>
<p>Recursive casee: if length of array is greater or equal to 5, (i) we swap the first and last,(ii) we recursively call one-fifths of the size of array. so each smaller array is of size n/5. So 3*T(n/5).<br>Ans: Recurrence relation is : T(n) = 3*T(n/5) +<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Let T(n) be runtime.</p>
<p>Base case: if the search range has just one element or no elements,&nbsp; constant time: <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>Recursive step: every step, we find the avg middle value, and narrow down the search range by splitting recursive call to only n/2 size.</p>
<p>Recurrence relation upper bound is : T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)&nbsp;</p>",0.75,Graded,18157,essay,"<p>Recurrence relation was: &nbsp;T(n) = T(n/2) +<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1). we can also write as T(n/2) + c</p>
<p>We will iterate over this recurrence to solve it:</p>
<p>T(n/2) = (T(n/4) + 2c</p>
<p>T(n/4) = (T(n/8) + 3c</p>
<p>And so on till after m steps,&nbsp; T(n) = T(n/2<sup>m</sup>) + m * c</p>
<p>This terminates when size reaches base case.</p>
<p>To find the total number of iterations till termination: set n/2<sup>m</sup> = 1 (base case)</p>
<p>So, n = 2<sup>m</sup></p>
<p>m = log<sub>2</sub>n</p>
<p>When we substitute this value of m into the T(n) relation,</p>
<p>T(n) = T(1) + log<sub>2</sub>n * c</p>
<p>The asymptotic solution is T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Divide and conquer algorithm:</p>
<p>1) First, we set a search range from small = 0 to large = n.</p>
<p>2) We will check the average point of the range: avg = floor(large-small/2)</p>
<p>3)If GetsService(r) is True then the avg is the correct return. Else, a smaller range could also exist. We can store avg to compare later. Now large = avg-1 as we narrow range.</p>
<p>4)Else if GetsService(r) is False, then the avg range is too small and we need to find larger range. Now small = avg +1 as we narrow range</p>
<p>5)This is done in recursion till small gets bigger than large. The last range we find correct is returned.</p>
<p>This will be a faster algorithm than brute force solution.</p>
<p>4)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.75
Mary Kristjanson,429023,UW935C401,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:44:10 UTC,00:20:04,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>O(log(n))</p>,0.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n)=T(n)+T(n/2)+cn</p>,0.0,Graded,18157,essay,<p>O(nlog(n))</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>s=0</p>
<p>if GetsService(r)=true</p>
<p>&nbsp; &nbsp; &nbsp; return r</p>
<p>else&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;divideandconquer(n-1)</p>
<p>&nbsp; &nbsp; &nbsp;divideandconquer(s*2)</p>
<p>&nbsp;</p>
<p><em>where n is the max integer value between the residence and the tower</em></p>
<p>&nbsp;</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
AHMAD ATIQ BIN AHMAD YUNUS,505348,UW103E063,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 20:00:28 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 2T(n/3) + n, T(1) = 1, T(2) = 1</p>",2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0) = O(1), T(1) = O(1)</p>
<p>T(n) = T([n/2]) + 1</p>",1.0,Graded,18157,essay,"<p>let c &gt; 0</p>
<p>T(n) &lt;= T(n/2) + c</p>
<p>&nbsp;&lt;= T(n/2<sup>2</sup>) + 2c</p>
<p>&nbsp;&lt;=T(n/2<sup>k</sup>) +kc</p>
<p>n/2<sup>k</sup> = 1</p>
<p>k = log2n</p>
<p>&nbsp;</p>
<p>T(n) &gt;= T(1) +clog2n</p>
<p>T(n) = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Binary search for the floor of k</p>
<p>let n be the length of array A</p>
<p>if n==0, return none</p>
<p>lo = 1; hi = n</p>
<p>ans = none</p>
<p>while lo &lt;= hi</p>
<p>&nbsp; mid = ((low+hi)/2)</p>
<p>&nbsp; if A[mid] &lt;= k</p>
<p>&nbsp; &nbsp; ans = A[mid]</p>
<p>&nbsp; &nbsp; low = mid +1</p>
<p>&nbsp; else</p>
<p>&nbsp; &nbsp; hi = mid - 1</p>
<p>return ans</p>
<p>At each step, half the search interval.</p>
<p>If A[mid] &lt;= k, any valid answer must be in the right half, so we record A[mid] as the best so far and move right.</p>
<p>If A[mid] &gt; k, any valid answer must be in the left half.</p>
<p>When the loop ends, ans in the largest element &lt;= k, or none if none exist</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Haroon Quddus,486728,UW979T462,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 20:44:24 UTC,00:29:33,1,18054,essay,"<p>T(1) = O(1)</p>
<p>T(n) = 3T(n/2) + O(n)</p>
<p>&nbsp;</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = O(1)</p>
<p>T(n) = T(n/2) + O(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>= T(n/4) + 2c</p>
<p>= T(n/8) + 3c</p>
<p>... = T(n/2^k) + kc</p>
<p>Stop when n/2^k = 1, when k = logn</p>
<p>This means:<br>T(n) = T(1) + clogn = O(logn)</p>
<p>T(n) = O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>If A[n] &lt; k we return None, otherwise we will do a binary search for the first index i with A[i] <img class=""equation_image"" title=""\ge"" src=""/equation_images/%255Cge?scale=1"" alt=""LaTeX: \ge"" data-equation-content=""\ge"" data-ignore-a11y-check=""""> k. We keep the range [L, R] = [1 ... n] and check the the midpoint m. If A[m] &lt; k, then we set L = m + 1, else we will set R = m. When L = R, we return A[L]. We are basically halving the range during each step of the algorithm which will result in a O(logn) runtime.&nbsp;</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
James Crowe,480367,UW097F708,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 20:05:47 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n &lt; 4) = 0,&nbsp;</p>
<p>T(4) = 1,</p>
<p>T(n) = 2T(n/4) + c</p>",2.5,Graded,18155,essay,"<p>Algorithm: RunsDC</p>
<p>input: number of cores available n, start = 0, end = n</p>
<p>Goal: split the number of total available cores n in half and see if the routine can run on that number of cores n. Recursively call to see find the smallest number of cores that can be used to run the routine in 1 second. Logic: if it can run on half the cores. check to see if it can run on half of half the cores... etc. If it cannot run on half the cores check to see if it can run on 3/4 cores... etc.</p>
<p>output: the minimum number of cores needed to run the routine in 1 second</p>
<p>begin</p>
<p>&nbsp; &nbsp; if n &lt;= 1 return n //base case runs on 1 core in 1 second</p>
<p>&nbsp;&nbsp;</p>
<p>&nbsp; &nbsp; half_cores = (start + end) // 2</p>
<p>&nbsp; &nbsp; if half_cores cannot run routine in 1 second:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; RunDC(n, half_cores, n)</p>
<p>&nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; RunDC(n, , start, half_cores)</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>",2.5,Graded,18156,essay,"<p>T(1) = c</p>
<p>T(n) = T(n/2) + c&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n) = T(n/2<sup>2</sup>) + c + c</p>
<p>T(n) = T(n/2<sup>k</sup>) + ck</p>
<p>n/2<sup>k</sup> &lt;= 1</p>
<p>k = log<sub>2</sub>n</p>
<p>T(n)&nbsp; = T(1) + clog<sub>2</sub>n = c + clogn</p>
<p>T(n) = O(logn)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
VIBHRAV JHA,513582,UW103Q280,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 20:10:32 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n) = T(n/5)+T(3n/5)+T(4n/5)+1</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2(T(n/2))+1<br>We divide the array twice and each call is n/2 times and constant checks other than the recursion&nbsp;</p>,0.25,Graded,18157,essay,<p>T(n)&lt;= 2T(n/2)+c&lt; T(n/2)+c&lt;T(n/2); T(1)=1<br>T(n/2^k)+kc<br>using T(1) we know that n/2=kc= therefore log(n) base 2<br>Therefore asymptotically it is O(log(n))</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Base case : if array is empty or <br>if there is only a single element x ; then check if its &gt;k return x or return None</p>
<p>Divide: let m be the midpoint of the array (divide the array in two halves)<br>Conqueor: if m&gt;=k recurse on the left half as the array is sorted <br>return L(i) ( that is the smallest element &gt; K)<br>if m&lt;k recurse on the right half return R[i] ( that is the smallest element &gt;K)</p>
<p>else return none&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.75
Riya Swaminathan,500112,UW009A923,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 20:06:15 UTC,00:22:57,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>A(n) = 2*A(n/3)<sup>3</sup> + n, A(1) = 1</p>",0.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2(n/2) + n, T(1) = 1</p>",0.0,Graded,18157,essay,"<p>Root = n, next level splits into 2 with n/2, next level each n/2 from before splits into 2 n/4. So it becomes 2<sup>i</sup>*(n/2<sup>i</sup>). Rearrange it so it is n * (2<sup>i</sup>/2<sup>i</sup>). It could be written as a geometric series, however 2<sup>i</sup>/2<sup>i</sup> just cancelles to 1. so it becomes n * 1. This means it is O(n).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Take an array from 1 to k (already sorted from 1 to k). Split the array in half, and take the lower half and call the method that computes the power, where it takes the highest value (last value) called m, in the lower half of the array and does n times n, repeating until the value of m (if n=1, and m=3, it is 1 * 1 * 1 because m = 3). Then do the same for the upper half of the array. Then multiply the value returned by the multiplication method on the lower array and the value returned from the same method for the upper array. This value is the final answer.</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Bruno WU,503520,UW980R811,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:37:21 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>T(n) = 2T(2n/3) + 1; Base case n&lt;3: O(1) time.</p>,3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2T(n/2) + 1</p>,0.0,Graded,18157,essay,<p>T(n) = 2T(n/2) + 1<br>= 2(2T(n/4) + 1) + 1<br>&lt;= 2<sup>k</sup> T(n/2^k) + k<br>= O(logn)</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Let A be an array of size n<br>Let DivideAndCon return the length of subarray A1 accouding to the problem, 0 if it doesnt exist (the array is either fully inceasing or fully decreasing)</p>
<p>DivideAndCon(A):</p>
<p>&nbsp; &nbsp; if len(A) == 1: return 0&nbsp;</p>
<p>&nbsp; &nbsp; if len(A) == 2:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if first elemet is less than 2nd element: # found the point between A1 and A2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 0<br>&nbsp; &nbsp; L = DivideAndCon(A[:n/2]) # floor n/2<br>&nbsp; &nbsp; R = DivdeAndCon(A[n/2:]) # floor n/2<br><br>&nbsp; &nbsp; if L and R == 0:<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return L + R<br>&nbsp; &nbsp; if not L == 0: # left size of array A contains the point between A1 and A2<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return L<br>&nbsp; &nbsp; if not R == 0: # rigft size of array A contains the point between A1 and A2<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return R + n/2 floor<br><br><br>&nbsp; &nbsp;&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Rachith ANASURI,485224,UW978S042,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 20:23:10 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>For n &lt; 4 T(n) = $\theta(1)$</p>
<p>For n &gt;= 4. T(n) = 2T(n/4) + theta(1)</p>",2.5,Graded,18155,essay,"<p>WE can use a DC approach based on binary search to find the smallest number of core for it to run in under 1 second. We start with low = 1 and high = n then repeatedly test the midpoint mid = floor((low + high)/2). If it runs in under 1 second on the mid cores, we continure searching the lower half by setting high = mid. other wise we set low = mid + 1 and search the upper half. This process keeps going until low == high. at this point the value that returned is the min number of core needed. This goes from the brute force approach (O(n)) to the DC approach O(log(n))</p>",3.0,Graded,18156,essay,"<p>T(1) = theta(1) and T(n) = 1 + T((n/2)) for n&gt;= 2.</p>
<p>this give tight upper bound T(n) = log_2(n).</p>",1.0,Graded,18157,essay,"<p>T(1) = 1, T(n)= 1 + T(ceil(n/2)) for n &gt;= 2</p>
<p>Unroll k times:</p>
<p>T(n) = k + T(ceil(n/2^k))</p>
<p>we'll say k = ceil(log_2(n)) and then ceil(n/2^k) &lt;=1, so the recursion stops and T(n) = ceil(log_2(n)).</p>
<p>so the tight bounds by simple induction are floor(log_2(n)) &lt;= T(n) &lt;= ceil(log_2(n)) so T(n) = theta(log(n))</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Sanyam Garg,514782,UW103O062,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:45:00 UTC,00:25:36,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n) = 3T(n/5) + O(1)</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + n</p>
<p>therefore, number of levels in tree = log(n) and work per level is n in the worst case.</p>
<p>therefore, total work upper bound should be O(nlog(n))</p>",0.0,Graded,18157,essay,"<p>total number of levels = log(n) and work per level is constant</p>
<p>therefore, total work is O(n(log(n)))</p>",0.0,Graded,25540,essay,"<p>Assume the exponent to be x, and a number n</p>
<p>Base Case : x = 0, return 1</p>
<p>Divide into two parts of n^(x/2)&nbsp;</p>
<p>recursively conquer the calling the algorithm on n^(x/2) and storing in i</p>
<p>we calculate i*i, as n^(x/2) in 2 cases:<br>1. x is even : i*i = n^x</p>
<p>2. x is odd : i*i*x = n^x</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Edward Qin,449607,UW946J877,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 20:12:45 UTC,00:16:20,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"<p>Base case: T(n) = T(n/2) + cn T(n) = (nlogn)</p>
<p>Base case = T(1) = c, 1 log 1= log 1 = 0</p>
<p>We assume T(k) = T(k/2) + ck = k log k<br>Than T(k+1) = T ((k+1)/2) + ck + c = (k+1)(log k+1)= k log k * log 1 = 0</p>",0.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>Binary Search Recurssion in divide and conquer.&nbsp;<br>Search and test the cores such that the routine runes under 1 second.</p>
<p>T(n) = T(n/2) + O(1) with runtime O(nlogn).</p>",1.0,Graded,18156,essay,"<p>T(1) = c, O(1log1) = 0</p>
<p>T(n) = T(n/2) + cn = O(nlogn)</p>
<p>&nbsp;</p>",0.0,Graded,18157,essay,"<p>Induction</p>
<p>Base case:</p>
<p>T(1) = c, 1log1 = 0</p>
<p>Assume n = k is true for all k &gt;= 1 E N</p>
<p>T(k) = T(k/2) + ck = k log k</p>
<p>n = k+1 is true for all k+1 &gt;= 2 E N</p>
<p>T(k+1) = T (k+1) + ck + c = k log (k+1) + log(k+1)<br>ck &gt;= k log (k+1) + log(k+1)<br>Therefore, base case is true and k+1 case is true whenever k case is true, therefore the binary search with recurssion algorithm works for all given cases of cores.</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Henry Keeler,483066,UW978A361,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 20:20:36 UTC,00:14:07,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2T(n/4) + cn : T(1) = O(1)</p>,1.5,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) &lt;= T(n/2) + cn : T(1) = O(1)</p>,0.0,Graded,18157,essay,<p>I will recurrence tree starting with n at the top and go to n/2 on each branch until we see the pattern that it is n/2^k. Then notice the steps for each layer going down is cn and so to find the recurrence relation it ends up being the sum layers of the tree which computes out to O(n log n).&nbsp;</p>,0.0,Graded,25540,essay,"<p>if x = 0 then return 1 or if x = 1 return e</p>
<p>Otherwise divide x by 2 and recursively compute the value of e^x and return this value.</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Timothy Chen,481596,UW946S784,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 21:56:20 UTC,00:29:54,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n) &lt;= 2T(n/4) + O(1), T(4) &lt;= O(1)</p>",2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>Assume comparisons and index accessing takes constant time</p>
<p>T(n) &lt;= T(n/2) + O(1), T(1) &lt;= O(1)<br>We cut our problem size in half at each level. Each level does constant time work.<br>T(n) = O(logn)</p>",1.0,Graded,18157,essay,"<p>Let our recurrence relation be T(n) &lt;= T(n/2) + c &lt;= T(n/2) + O(1), T(1) &lt;= c &lt;= O(1)<br>T(n) &lt;= T(n/2) + c &lt;= T(n/4 + c/2) + c &lt;= T((n/8 + c/4) + c/2) + c &lt;= ... &lt;= T(n/(2^k)) + d, where d = c + c/2 + c/4 + ... + c/2^k</p>
<p>n/(2^k) = 1 --&gt; 2^k = n --&gt; k = logn<br>d is equal to the <img class=""equation_image"" title=""\Sigma"" src=""/equation_images/%255CSigma?scale=1"" alt=""LaTeX: \Sigma"" data-equation-content=""\Sigma"" data-ignore-a11y-check=""""> of c from i=0 to logn = clogn + c<br>clogn + c is asymptotically bound by omega(logn) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(logn)</p>
<p>&nbsp;T(n) = omega(logn) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(logn)</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p><br>Let the array of n possible points be M, i,e. M is a sorted array of size n</p>
<p>Algorithm: BinarySearch(M)</p>
<p>if length(M) = 1, return the only element in M</p>
<p>i = M[ (floor(n/2) ]</p>
<p>If i points doesn't give you an A: return BinarySearch(M[i ... n])<br>If i points gives you an A: return BinarySearch(M[1 ... i])</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
Yoonho Park,362860,UW941W172,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 20:42:30 UTC,00:28:30,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) , if length(a) &lt; 5</p>
<p>T(n) = 3T(n/5) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) , otherwise</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>base case : T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = (T(n/4) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = ...</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = T(n/(2^k)) + k*<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>stops when n/(2^k) = 1, k = log&nbsp;<sub>2</sub> (n)</p>
<p>T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n) + c</p>
<p>&nbsp;</p>
<p>therefore, T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>findSizeA1(1, n):&nbsp; &nbsp; &nbsp; // n is the size of array A&nbsp; &nbsp; &nbsp; 1234 | 54321</p>
<p>&nbsp; &nbsp; if 1 == n:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return n</p>
<p>&nbsp; &nbsp; mid = floor(n/2)</p>
<p>&nbsp; &nbsp; if A[mid] &gt; A[mid+1]:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; findSizeA1(mid, n)</p>
<p>&nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; findSizeA1(1, mid)</p>
<p>&nbsp; &nbsp; return n</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Kirtan Dusi,489787,UW981Z696,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 20:41:34 UTC,00:29:20,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Base case: n &lt; 5</p>
<p>T(n) = 3T(n/5) + n</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: n = 1. //if there is only one distance, then it either works or it doesn't.&nbsp;</p>
<p>T(n) = 2T(n/2) + n</p>
<p>&nbsp;</p>",0.25,Graded,18157,essay,"<p>First layer is n, followed by n/2, n/2, followed by n/4, n/4, n/4, n/4. Each layer adds to n. Because there are k layers, the total work is nk. Stop when n = 1, so we just have n * summation_i=1-&gt;i=k {1), which is n * k.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Another way you could do this is through a binary search style algorithm. Instead of increasing range until you find service (a linear search), you could overshoot and undershoot until you find it.&nbsp;</p>
<p>begin</p>
<p>min_distance = 0</p>
<p>max_distance = n</p>
<p>r = n/2</p>
<p>while (max_distance != min_distance) {</p>
<p>if GetsService(r) == true do //decrease range</p>
<p>max_distance = r;</p>
<p>r = (r + min_distance) / 2</p>
<p>else //increase range</p>
<p>min_distance = r;</p>
<p>r + (r + max_distance) / 2;</p>
<p>}</p>
<p>return r</p>
<p>end</p>
<p>Because the whole range is not being searched, and the total area is being subdivided each time, the runtime is O(logN).&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.75
Harsh Shrotriya,513717,UW104S499,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:05:56 UTC,00:20:48,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n) = O(1) for n≤4</p>
<p>T(n) = 2T(n/4) + O(1) for n&gt;4&nbsp; &nbsp; &nbsp; &nbsp; #floor of n/4</p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n/2) + O(1) for n&gt;1&nbsp; &nbsp; &nbsp; &nbsp;# floor for n/2</p>,0.75,Graded,18157,essay,"<p>T(n) ≤ T(n/2) + c&nbsp;</p>
<p>..</p>
<p>≤ T(n/2^k) + kc</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Stop when:</p>
<p>&nbsp;</p>
<p>n/2^k≤1 which implies that k = log n base 2</p>
<p>&nbsp;</p>
<p>therefore:&nbsp;</p>
<p>&nbsp;</p>
<p>T(n) ≤ T(1) + clog n base 2</p>
<p>&nbsp;= O(log n)</p>
<p>&nbsp;</p>
<p>final answer:<br><br>T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>BinarySqrt(x):</p>
<p>&nbsp; if x&lt;2: ret x</p>
<p>&nbsp; low = 0</p>
<p>&nbsp; high = (x/2)+1 # floor</p>
<p>&nbsp; while low≤high:</p>
<p>&nbsp; &nbsp; &nbsp;mid = low+high /2 #floor</p>
<p>&nbsp; &nbsp; &nbsp;s = mid*mid</p>
<p>&nbsp; &nbsp; if s == x: ret mid</p>
<p>&nbsp; &nbsp; elif s&lt;x: low = mid+1</p>
<p>&nbsp; &nbsp; else: high = mid -1&nbsp;</p>",3.0,Graded,0,0,0,9.0,8.75
Jiarui Yang,579172,UW117E045,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 20:42:59 UTC,00:29:19,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>T(n) = 3T(n/5) + c&nbsp; T(1) = 1</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(2) = 1</p>
<p>T(n)= 2T(n/2) + c</p>",0.0,Graded,18157,essay,"<p>T(n) = 2T(n/2) + c</p>
<p>= 2(2T(n/4)+ c/4)+c + c</p>
<p>= sum of i = 0 to k(c)</p>
<p>k = log2(n)</p>
<p>T(n) = c + k-1(c)</p>
<p>&nbsp;= kc</p>
<p>= clog2(n)</p>
<p>So T(n) is logn</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>FindLength</p>
<p>Input: A given array A[1..n]</p>
<p>Output: the length of the array A1</p>
<p>if |A| = 2{</p>
<p>&nbsp; &nbsp; if(A[0]&lt; A[1]){return 2}</p>
<p>&nbsp; &nbsp; else{return 0}</p>
<p>else{</p>
<p>let A = 0</p>
<p>L = FindLength(left half of A)</p>
<p>R = FindLength(right half of A)</p>
<p>A = L + R</p>
<p>return A}</p>",1.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Aiden Engel,487527,UW979Y065,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 20:34:45 UTC,00:20:14,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>T(n) &lt;= T(1/5) + T(4/5) + T(3/5) + c; T(1) = 1</p>
<p>Assuming Swap and finding the fifths are O(1) of course.</p>
<p>&nbsp;</p>",2.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) &lt;= T(n/2) + c, T(1) = 1</p>",1.0,Graded,18157,essay,<p>we know we are going to have k = log2(n) calls total since each time we split our data set in half and only check half the list. All we have per call is either a O(1) base case or some constant O(1) Comparisons.&nbsp; So log(n) calls * O(1) work gives us our final answer of O(log(n))</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>FindSplit (partition point p, Array A):</p>
<p>Base Case: Length(A) = 1, return p</p>
<p>ArrayLeft = A[0 to p]</p>
<p>ArrayRight = A[p+1 to n]</p>
<p>&nbsp;</p>
<p>if (ArrayLeft[p-1] &lt; ArrayLeft[p]) and (ArrayRight[P+1] &gt; ArrayRight[P+2]):&nbsp; //If left is increasing and right is decreasing</p>
<p>return index p&nbsp;</p>
<p>else if ArrayLeft[p-1] &gt; ArrayLeft[p]:&nbsp; //If Left is decreasing, we are to far to the right</p>
<p>FindSplit(p/2, ArrayLeft)</p>
<p>else:&nbsp; &nbsp; //We are to far to the left</p>
<p>FindSplit(p/2,ArrayRight) + p&nbsp;</p>
<p>&nbsp;</p>
<p>Its a modified Partition select algorithm :)</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Madison Lin,501847,UW099L927,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 20:50:24 UTC,00:28:30,1,18054,essay,<p>T(n) = 3*T(n/2) + cn; T(1) = 1</p>,3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c; T(1) = 1;</p>,1.0,Graded,18157,essay,"<p>Solve by unwinding.<br>T(n) = T(n/2) + c<br>&nbsp; &nbsp; &nbsp; &lt;= T(n/4) + c + c<br>&nbsp; &nbsp; &nbsp; &lt;= T(n/8) + c + c + c<br>&nbsp; &nbsp; &nbsp; ...<br>&nbsp; &nbsp; &nbsp; &lt;= <img class=""equation_image"" title=""T\left(\frac{n}{2^k}\right)+kc"" src=""/equation_images/T%255Cleft(%255Cfrac%257Bn%257D%257B2%255Ek%257D%255Cright)%252Bkc?scale=1"" alt=""LaTeX: T\left(\frac{n}{2^k}\right)+kc"" data-equation-content=""T\left(\frac{n}{2^k}\right)+kc"" data-ignore-a11y-check=""""><br>if <img class=""equation_image"" title=""1=\frac{n}{2^k};2^k=n;k=\log_2n"" src=""/equation_images/1%253D%255Cfrac%257Bn%257D%257B2%255Ek%257D%253B2%255Ek%253Dn%253Bk%253D%255Clog_2n?scale=1"" alt=""LaTeX: 1=\frac{n}{2^k};2^k=n;k=\log_2n"" data-equation-content=""1=\frac{n}{2^k};2^k=n;k=\log_2n"" data-ignore-a11y-check=""""><br>&nbsp; &nbsp; &nbsp; &nbsp; = <img class=""equation_image"" title=""T\left(1\right)+\log_2n\cdot c"" src=""/equation_images/T%255Cleft(1%255Cright)%252B%255Clog_2n%255Ccdot%2520c?scale=1"" alt=""LaTeX: T\left(1\right)+\log_2n\cdot c"" data-equation-content=""T\left(1\right)+\log_2n\cdot c"" data-ignore-a11y-check=""""> = <img class=""equation_image"" title=""c+\log_2n\cdot c"" src=""/equation_images/c%252B%255Clog_2n%255Ccdot%2520c?scale=1"" alt=""LaTeX: c+\log_2n\cdot c"" data-equation-content=""c+\log_2n\cdot c"" data-ignore-a11y-check=""""><br>&nbsp; &nbsp; &nbsp; &nbsp; T(n) is O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Algorithm: PivotSearch</p>
<p>Input: An array A of length n<br>Output: The total length of <img class=""equation_image"" title=""A_1"" src=""/equation_images/A_1?scale=1"" alt=""LaTeX: A_1"" data-equation-content=""A_1"" data-ignore-a11y-check=""""> (the part of the array with increasing order)<br>if |A| == 1, then return A[1]<br>Let mid be n/2.<br>if A[mid] &lt; A[mid + 1),&nbsp;<br>&nbsp; &nbsp; PivotSearch( A[mid + 1....n] )<br>else we have started decreasing, check left<br>&nbsp; &nbsp; PivotSearch (A[1...mid])<br>end<br><br></p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
James Li,506612,UW999Z409,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:12:18 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>L3: Base case - T(n) = O(1) for n &lt; 4</p>
<p>L5: T(4) = O(1)</p>
<p>L7-L11: T(n/4) = O(n/4)</p>
<p>Recurrence: T(n)&nbsp; = 2T(n/4) + O(1)</p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: T(1) = O(1)</p>
<p>T(n) = T(n/2) + O(1)</p>",0.0,Graded,18157,essay,"<p>Recursion Tree:<br>n -&gt; n/2 - n/2^2 -&gt; n/(2^k)</p>
<p>Work per tree level k: 1</p>
<p>T(n) = Summation i = 0 to k for n/(2^i) + O(1) = O(log n) + O(1) = O(log n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Input: Perfect square x where x &gt;= 0. Base case: if the middle^2 value of x equals x, we have found sqrt(x) so return middle. Divide: split x in left and right halfs. Conquer: for each half, determine the middle = (left + right) / 2 and recurse.&nbsp;</p>",1.0,Graded,0,0,0,9.0,4.0
Benjamin Cook,423485,UW931J028,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 20:45:55 UTC,00:19:31,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n) = (n/5) + (4n/5) + (3n/5) + 5; T(1) &lt;= 5</p>,2.0,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = (n/2) + n; T(1) = 1</p>,1.0,Graded,18157,essay,<p>&nbsp; &nbsp; n -&gt; n/2 - n/2 -&gt; n/4 ... n/2^k-&gt; k = logn which would be the run time for the binary search of the algorithm.</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,<p>The way you could do this is to start off with the number n/2 and if he gets signal then go to the next number between there and zero and if he doesn't get serice then go up to 3n/4 and keep doing this till you either find that he has signal which would be the smallest range of if you don''t find anything then he doesn't.&nbsp; Pretty much use a binary search because you know the max range of the tower.</p>,1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Hannah Wang,449657,UW103P032,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 20:48:42 UTC,00:19:24,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) if n&lt;=2</p>
<p>T(n) = 2T(2n/3)+<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2)+<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2)+c = (T(n/4)+c) + c = ...</p>
<p>each level you have cost adds up to 1 and n/2^k = 1 k = log_2n so we have T(n) = T(1)+clog_2n = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"<p>begin</p>
<p>low = 1</p>
<p>high = max_possible_scores</p>
<p>while low&lt;high:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mid = (high-low)//2+low</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if mid got A&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;high = mid</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;low = mid+1</p>
<p>&nbsp; return mid</p>
<p>end</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",3.0,Graded,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
John Mertz,343661,UW836N041,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:22:01 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,<p>T(n) = T(n/2) + n; T(1) = 1</p>,0.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + 1; T(1) = 1</p>,1.0,Graded,18157,essay,"<p>Using recurrence trees, we see that each branch of the tree has a value of 1. We also see that for the height of the tree <em>k</em>, it follows that (n/(2^k)) = 1. Solving for <em>k</em>, we see that <em>k</em> = log(n) . Hence, the algorithm has a bound of O(log n).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>The base case of this algorithm will return 2 if the elements in an input array of length 2 are in increasing order, and 0 otherwise. Then the algorithm will then check the middle element of the input array, and get indicies <em>a</em> and&nbsp;<em>b</em>, where&nbsp;<em>a</em> is the element directly to the left of the middle of the array and&nbsp;<em>b</em> is the element to the right of the middle of the array. If&nbsp;<em>a</em> is less than <em>b</em>, then the algorithm will recurse into the right half of the input array. If <em>a</em> is greater than <em>b</em>, it will recurse to the left half of the array. The algorithm then returns the sum of each of the recursive calls it made minus 1.</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.5
ANUVA BHAGIRATH,515134,UW110E913,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 21:05:21 UTC,00:29:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>Base Case: O(1)&nbsp;</p>
<p>3T(<img class=""equation_image"" title=""\lceil"" src=""/equation_images/%255Clceil?scale=1"" alt=""LaTeX: \lceil"" data-equation-content=""\lceil"" data-ignore-a11y-check="""">n/3<img class=""equation_image"" title=""\rceil"" src=""/equation_images/%255Crceil?scale=1"" alt=""LaTeX: \rceil"" data-equation-content=""\rceil"" data-ignore-a11y-check="""">) + O(1)<br>T(n)= O(n)</p>",0.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0)=c, T(1)=c</p>
<p>base case : O(1)</p>
<p>T(n)=T(k/2)+O(1)</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p>T(0)= c&nbsp;<br>T(1)=c<br>Base Case:O(1)</p>
<p>T(n)=T(k/2)+O(1)&nbsp; &lt;= T(k/2) &lt;= O(log k)<br><br>Asymptotic solution: O(log n)<br><br></p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Base Case: If a=1 return k=0, if a=b return k=1<br>Divide: We will divide the input using isqrt(a,2) function,&nbsp;<br>x= <img class=""equation_image"" title=""\sqrt{\placeholder{}}"" src=""/equation_images/%255Csqrt%257B%255Cplaceholder%257B%257D%257D?scale=1"" alt=""LaTeX: \sqrt{\placeholder{}}"" data-equation-content=""\sqrt{\placeholder{}}"" data-ignore-a11y-check="""">a</p>
<p>store the result as middle, check middle raised to power of 2 equals a. If yes, k is even, if no k is odd.</p>
<p>Conquer: If x is an integer of b then k is even , so recursively compute m such that x=b^m and return k=2m<br>Else, k is odd. Divide out one power of b: set a=a/b, now k=1+exponent of smaller problem.<br><br>T(n/2)+O(1)&nbsp;<br>O(log k)</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Thijs Vermeij,424264,UW931A385,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 21:13:35 UTC,00:29:19,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>Base case; T(1) = O(1), this checks if the length is 1 and then returns&nbsp;</p>
<p>Recursive case: The algo makes 3 recursive calls: Shuffls the first half (T(n/2)),, shuffles third quarter (T(n/4)) and shuffles 4th quarter (T(n/4)).&nbsp;</p>
<p>Per level, the work done is O(n). Finding the max element and swapping it takes linear time (O(n)). Thus we can find the recurrence to be: <strong>T(n) = T(n/2) + 2T(n/4) + O(n)</strong> with a <strong>base case T(1) = O(1).</strong></p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Recurrence: T(n/2) +O(1), with the base case being T(1) = O(1). Each recursive call examines only one half of the remaining array - hence the dividing of the problem size by 2. It also performs constant work, hence O(1) in our recurrence relation answer above!</p>",1.0,Graded,18157,essay,"<p>We are solving the recurrence relation of B: T(n) = T(n/2) + O(1). We will NOT be usign the master theorem, unfortunately, due to the question specifications. We will instead be using the Recursion tree method!</p>
<p>starting w/ T(n) = T(n/2) + c, as c is the work constant, we can start at level 0: T(n) = c + T(n/2).. Level 1 we get the following: T(n) = c + (c+ T(n/4)) = 2c +T(n/4). For level 2 we continue: T(n) = 2c + (c + T(n/8)) = 3c +T(n/8). Level 3: 3c + (c + T(n/16))/ you can start to see the pattern from here:</p>
<p><strong>Pattern: After k levels, we get T(n) = kc + T(n/(2^k)).</strong></p>
<p>Finding the number of levels is oretty straight forward. The recursion stops when we reach the base case T(1). This happens when n/(2<sup>k</sup>) = 1. This means 2<sup>k</sup> = n, so k = log<sub>2</sub>(n). from here we can substitute back:</p>
<p>T(n) = (log<sub>2</sub>(n))*c + T(1)</p>
<p>T(n) = c*log<sub>2</sub>(n) + O(1), and thus <strong>T(n) = theta(log(n))</strong> -- assume that ""theta""&nbsp; a theta symbol as I do not know how to use the greek keyboard. . Th ealgorith performs in logarithmic time complexity because at each level of recursionwe do constant work -- O(1) -- and there are log<sub>2</sub>(n) levels total before reaching te base case, hence our solution</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>The algorithm will use Binary search to find the largest element of the sorted array (A( that is less than or equal to that of the value k. We will start by calling the function w/ the entire array range from low =1 to hight = n.</p>
<p>First, we check if the search range is valid. if low is greater than high, range is empty, etc. rwe retturn none because no valid element exists within the range</p>
<p>Second, we calculate the middle index of the current range using mid = ((low + high)/2). This esssentially divides the problem into 2. Now, we examine mid(a) and compare it to k. if mid(a) is greater than k, mid(a) and all elements to the right are too large. We will recursively search only the left half by calling the algo with the range (low, mid-1 -- since mid is already accounted for). We do not have to search the right half in this case.&nbsp;</p>
<p>if mid(a) is LESS than or equal to k, then mid(a) is a candidate answer. That being sad, there might be a larger valid elementto the right. We have 2 check 2 conditions: either mid is the last index (mid = n) OR the next element a(mid+1)&nbsp; is greater than k. if either ocndition is tre, mid(a) is the answer, and we will return it. we do NOT continue searching in this case.</p>
<p>If neither condition holds -- meaning a(mid+1) also satisfies the condition -- then recursivel search the right half by calling the algo w/ range (mid+1, high). Do not search the left half because we want the largest valid element, which MUST be to the right. We do not scan the entire array, and we do not make multiple recursive calls for efficiency sake. Only recurse on one half. We do not check elements outside of the current range for this same reason!</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Aaron Dong,547741,UW104K142,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 20:55:54 UTC,00:18:54,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = Theta(1) if n &lt;= 2, 2T(n/3) + Theta(n/3) if n &gt; 2</p>",3.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = Theta(1) if k &lt;= 1, Theta(k/2) + Theta(1) if k &gt; 1-</p>",1.0,Graded,18157,essay,"<p>Theta(1) = c.</p>
<p>&nbsp;</p>
<p>T(k) = T(k/2) = c<br>= (T(k/4) + c) + c<br>= T(k/4) + 2c</p>
<p>= T(k/8) + 3c<br>This pattern continues<br>= T(k/2^i) + ic<br><br>The recursion goes until the size = 1<br><br></p>
<p>So when k/2^i = 1:<br>i = log2k<br><br>So&nbsp;<br>T(k) = T(1) + clog2k.&nbsp; (T(1) is constant)<br><br>So</p>
<p>T(k) = clog2k<br>So<br>T(k) = theta(1) if l &lt;= 1, theta(logk) if k &gt; 1<br><br></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Algorithm(n,k)<br>if k == 0:<br>&nbsp; &nbsp;return 1<br>if k == 1:<br>&nbsp; &nbsp;return n<br>if k%2 = 0:<br>&nbsp; &nbsp;half = Algorithm(n, k/2)<br>else:<br>&nbsp; &nbsp;half = Algorithm(n, (k-1)/2)<br>&nbsp; &nbsp;return n * half * half<br>&nbsp; &nbsp;</p>
<p>&nbsp;</p>",2.5,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Vincent Cimino,501685,UW100X031,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 21:54:52 UTC,00:26:10,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,<p>T(n&lt;5)=c. T(n)=8T(n/5)+c for n&gt;=5</p>,1.5,Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k)=c for k=1, T(k)=T(k/2)+c for k&gt;1</p>",1.0,Graded,18157,essay,<p>T(k)=c+T(k/2)=c+c+T(k/4)=c+c+c+T(k/8) etc etc. until k/2^x=1. x is the number of c terms until we get to T(1). We solve x as being log2(k) as 2^x=k for the last term of the sequence for T(k/2^x) to be 1 and reach the base case. Therefore we know T(k) = c*log2(k). Thus we know that T(k) is O(logk).</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>power(n, k):</p>
<p>if k==1 return n</p>
<p>if k%2==1, return n*power(n*n,(k-1)/2)</p>
<p>else return power(n*n,k/2)</p>",2.5,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.0
Zachery Fleming,535313,UW102C974,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 21:11:33 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = T(n/3) + cn, T(1) = 1</p>",1.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + cn, T(1) = 1.&nbsp;</p>",0.0,Graded,18157,essay,"<p>Using reccurence tree:<br><br></p>
<p>1st: n = n</p>
<p>2nd: (n/2)^2 - n/2 = 2(n/2)</p>
<p>3rd: (n/4)^2&nbsp; (n/4)^2 * (n/4)^2 * (n/4)^2&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Returns: The algorithm needs to return the value of n^k in fewer multiplications.&nbsp;</p>
<p>Divide: We can take a mergesort like approach. We take an array of the base n with a length k. We then will divide it into a left half L and right half R are recursivally multiply those numbers which will lead to calculation of n^k in fewer multiplications.&nbsp;</p>
<p>Merge: We will merge do the final multiplication at the end and merge the arrays into 1 array representing the product.&nbsp;</p>
<p>Basecase: if n = 1, and k = 0, then we will have [0] which cannot be multiplied since there is only 1 element so base case would correctly return 0.&nbsp;</p>",1.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.0
Qiancheng Yang,577237,UW118M438,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 21:18:56 UTC,00:29:36,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>T(n) = T(n/2) + 2T(n/4) + n, T(1) = 1</p>",3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + 1, T(1) = 1</p>",0.0,Graded,18157,essay,"<p>T(n) = 2T(n/2) + 1 = 2(2T(n/4) + 1) + 1 =......= 2^k*T(n/2^k) + 2^k - 1</p>
<p>2^k = n, thus k = log2(n)</p>
<p>The above equation = O(logn)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>mid = n // 2</p>
<p>Recursively split the array A[1...n] into two halves: A_left[1...mid] and A_right[mid+1...n] until reach the base case.</p>
<p>The base case is where the array has length = 1 or length = 2</p>
<p>If length = 1, returns</p>
<p>If length = 2, compare the 2 numbers in the array, if A[1] &gt; A[2], return the index of A[1], else returns</p>
<p>Then merge the two splited arrays, if the last element of A_left[1...mid] is larger than the first element of A[mid+1...n], returns mid.</p>",1.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Bruno Inzunza,430539,UW936A220,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:22:39 UTC,00:29:12,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n&lt;=4) = O(1)</p>
<p>T(n &gt; 4) = 2*T(n/4) + c</p>",3.0,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n&lt;=2) = O(1)</p>
<p>T(n&gt;2) = 1*T(n/2) + c</p>",1.0,Graded,18157,essay,"<p>recursive tree</p>
<p>At level 0: size = n, work done = c</p>
<p>At level 1: size = n/2, work done = c</p>
<p>At level 2: size = n/4, work done = c</p>
<p>At level 3: size = n/8, work done = c</p>
<p>Work done per level = c</p>
<p>size of n per level = n/2<sup>k</sup></p>
<p>(n/2^k = 1) -&gt; (n = 2^k) -&gt; (n = klog<sub>2</sub>) -&gt; O(logn) which is faster than O(n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Using a type of binary search, we will find the intersection between both and return index + 1 for length of A1.</p>
<p>Base Case: if length of array is 2 or less, return array</p>
<p>divide: split array in half</p>
<p>conquer compare middle two values,</p>
<p>if left value is smaller than right: recurse(right_half)</p>
<p>if right value is smaller than left: recurse(left_half)</p>
<p>merge: merge the left halves that were made up to the intersection point minus 1 value (since it is the first elem of A2)</p>
<p>&nbsp;</p>
<p>12345876</p>
<p>1234 5876</p>
<p>1234 <strong>58</strong> 76</p>
<p>123458<strong>&nbsp;</strong></p>
<p><strong>12345</strong></p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Pelin Sarac,516804,UW099R246,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 21:27:22 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>T(n) = 2T(2n/3) + cn for n &gt;= 3 and O(n) for n &lt; 3</p>,1.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = T(k/2) + c for k &gt; 1</p>
<p>T(k) = O(1) for k &lt;= 1</p>",1.0,Graded,18157,essay,"<p>T(k) = T(k/2) + c</p>
<p>= T(k/4) + c + c = T(k/4) + 2c</p>
<p>= T(k/8) + c + c + c = T(k/8) + 3c</p>
<p>= T(k/2^i) + ic</p>
<p>&nbsp;</p>
<p>k / 2^i &lt;= 1</p>
<p>i = log(2) k&nbsp;</p>
<p>&nbsp;</p>
<p>T(k) = T(0) + T(1) + c * log(2) k = O(1) + O(1) + c log(2) k = O(log k)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>Base case: k == 0 return 1</p>
<p>Base case: k == 1 return n</p>
<p>Divide exponent, k, by 2.&nbsp;</p>
<p>If k is is even, compute n^(k/2) recursively, then square the result.&nbsp;</p>
<p>If k is odd, compute n^((k-1)/2) recursively, then square the result, then multiply by n.&nbsp;</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.5
Trinity Krohn,493753,UW917S510,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 21:30:22 UTC,00:29:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>T(n) = T(n/2) + 2T(n/4) + O(n)</p>,2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1)<br><br></p>,0.75,Graded,18157,essay,"<p>T(n) = T(n/2) + O(1)&nbsp;<br>Expand down the tree&nbsp;<br>T(n/2) + T(n/4) + T(n/8) + ..... T(n/2^k)<br><br>We are trying to get down to the base case of 1 so we set T(n/2^k) = 1&nbsp;<br>That gives us n = 2^k&nbsp;<br>which then gives log2n, if we take log on both sides, which therefore tells us the running time is O(logn)&nbsp;</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"<p>// We will use a divide and conquer algorithm to reduce our exponent by dividing by 2. This has an asymptotically faster performance than the given brute force algorithm.<br>Function Power(n, k)&nbsp;<br>input= n,k, output= n^k</p>
<p>if k = 0:</p>
<p>return 1</p>
<p>if k is even:<br>//Divide, solve for half exponent &amp; then combine by squaring</p>
<p>half_power = Power(n, k/2)</p>
<p>return half_power * half_power</p>
<p>else: //k is odd, must do 2 multiplications because if k is odd (2m + 1) then n must be multiplied and squared.<br>half_power = Power(n, (k-1)/2) //we are doing (k-1) because we need to calculate on truncated half</p>
<p>square = half_power * half_power</p>
<p>return n * square</p>
<p>&nbsp;</p>
<p><br><br>&nbsp; &nbsp; &nbsp;</p>",3.0,Graded,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,7.75
George Maney,444329,UW108C672,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 21:31:02 UTC,00:26:28,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>Base case: T(1) = O(1), T(2) = O(1).</p>
<p>With n &gt;= 3 the algorithm makes 2 recursive calls on thirds of A(the first and last thid), and scans the middle third:</p>
<p>T(n) = 2T(ceil(n/3)) + c(ceil(n/3))</p>",3.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>low = 1; high = n; out = n;</p>
<p>while low &lt;= high do</p>
<p>&nbsp; &nbsp; mid = (low + high)/2</p>
<p>&nbsp; &nbsp; if (routine runs in under 1 second on mid cores) then</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; out = mid</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; high = mid-1</p>
<p>&nbsp; &nbsp; else</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; low = mid+1</p>
<p>return out</p>",3.0,Graded,18156,essay,"<p>Base case T(1) = O(1).</p>
<p>For n &gt;= 2 each step does one check and cuts half the size:</p>
<p>T(n) = T(ceil(n/2)) + O(1) or:</p>
<p>T(n) = T(ceil(n/2)) + c</p>",1.0,Graded,18157,essay,"<p>T(n) &lt;= T(ceil(n/2)) + c and T(n) &gt;= T(ceil(n/2)) + c*</p>
<p>for some c* &gt; 0</p>
<p>Unfolding k times:</p>
<p>T(n) = T(ceil(n/(2^k))) + k*O(1)</p>
<p>Once we get to the base case and unfold this gives:</p>
<p>T(n) = T(1) + ceil(log_2 n)*O(1) = O(log n)</p>
<p>Then, from our inequalities:</p>
<p>T(1) + ceil(log_2 n)*(c*) &lt;=T(n) &lt;= T(1) + ceil(log_2 n)*c</p>
<p>Therefore T(n) = \Omega(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Jeet Mehta,429721,UW100Z667,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 21:35:18 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>2T(2N/3) + O(1)</p>,2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>Since we're calling once on halves with linear complexity<br>base case:- O(1)<br>T(N/2) + O(1)</p>,0.0,Graded,18157,essay,"<p>T(N/2) + c for iter 1, then T(N/4) + 2c for iter 2, then T(N/8) + 3c for iter 3 ...<br>This goes on till N/k = 1,&nbsp; so this is O(logn) as its dividing in half till we reach n as 1.&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Pseucode:-&nbsp;</p>
<p>We first pass a value k which is the power, a and b which are the numbers into the function which we call FasterAlgo.<br>We first check if b^k is equal to a, if yes, then we return the number k. If not, we continue. We then call the isqrt function on b^k giving us the value of b^k/2. We call this variable mid_value.&nbsp;<br>If a/b^k/2 is greater than 1, we calcualte new value of&nbsp; to be k/2 undercase + 1, and if a/(b^(k/2)) is smaller than 1, we calculate new value of k to be k/2 undercase -1<br>Now we call the FasterAlgo function on (k) , a,b a<br><br></p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Adhik Sivakumar,524277,UW994V718,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:46:05 UTC,00:29:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"<p>T(n) = T(n/2) + 2T(n/4)+<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(n)</p>",2.5,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>1. I would start with all cores, from 1 to n</p>
<p>2. Then I would pick the middle number of cores</p>
<p>3. Then I would test the routine using that amount of cores</p>
<p>4. If that runs under one second, then we know the smallest number is at or below that middle number and we would check the lower half</p>
<p>5. If that runs over a second, we know to check the second half</p>
<p>6. Then, finally I would keep halving till I reach the first number of cores where it runs in under a second</p>",3.0,Graded,18156,essay,"<p>T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1), T(n) = T(n/2) + <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>",1.0,Graded,18157,essay,"<p>We unroll k times:</p>
<p>So it would be T(n) = T(n/2^k)+kc.</p>
<p>We stop when the argument hits the base case, so n/2^k&lt;=1, so k&gt;=log2n</p>
<p>T(n) = T(1) +c(log2n)= d+c(log2n)</p>
<p>This is O(log n), since d is a constant and c just multiplies the log function</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Yang Chu,597713,UW115W700,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:37:39 UTC,00:29:57,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n)=2T(n/4)+c&nbsp; &nbsp;(n&gt;4)</p>
<p>T(1)=0, T(2)=0, T(3)=0, T(4)=c</p>",2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(k) = T(k/2) + c&nbsp;</p>
<p>T(1) = 1</p>",0.0,Graded,18157,essay,"<p>T(k) = O(logk)</p>
<p>T(k) = T(k/2)+1=T(k/4)+2=T(k/8)+3=...=T(k/2^d)+dc</p>
<p>k/(2^d)=1 =&gt; d = logk</p>
<p>T(k) = T(1)+clogk =O(logk)</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>input: a, b</p>
<p>begin: i = 0</p>
<p>while a / b^i &gt; isqrt(a), i = k/2 + 1&nbsp;</p>
<p>while a / b^1 = isqrt(a), i = k/2</p>
<p>while a / b^i &lt; isqrt(a), i = k/2 -1</p>
<p>end&nbsp;</p>
<p>return i</p>
<p>end</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,3.5
Claudia Ratajczyk,484614,UW979B815,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 21:40:05 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2T(n/3)+cn</p>
<p>Base Case: T(1) = 1</p>",2.5,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + cn</p>
<p>Base Case: T(1) = 1</p>",0.0,Graded,18157,essay,"<p><img class=""equation_image"" title=""\frac{n}{2^k}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ek%257D?scale=1"" alt=""LaTeX: \frac{n}{2^k}"" data-equation-content=""\frac{n}{2^k}"" data-ignore-a11y-check=""""> = 1 rearranges is logn=k which is the number of levels of recursion. The cost of each level of recursion is the same constant c times n. Using the base case and T(n) we get 2T(1) + c which is 2 + cn and therefore O(logn) is the solution to the recurrence relation.</p>",0.0,Graded,25540,essay,"<p>Algorithm called DCExponentation(x) where x is &gt;= 0.</p>
<p>if x == 1, return e;</p>
<p>if x is even (x%2 == 0), do: return DCExponentation(x/2)</p>
<p>else (odd) do: return e * DCExponentation(x-1) // assuming it is integer division and rounds down</p>
<p>end</p>",2.5,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.0
Guangwen Xiong,566335,UW107G467,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 21:39:50 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"<p>T(n) = 2T(<img class=""equation_image"" title=""\frac{2}{3}"" src=""/equation_images/%255Cfrac%257B2%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{2}{3}"" data-equation-content=""\frac{2}{3}"" data-ignore-a11y-check="""">n) + O(1)<br>T(1) = O(1), T(2) = O(1)</p>",3.0,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">) + O(1)<br>T(3) = O(1)</p>",1.0,Graded,18157,essay,"<p>From Part B we have: T(n) = T(<img class=""equation_image"" title=""\frac{n}{2}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%257D?scale=1"" alt=""LaTeX: \frac{n}{2}"" data-equation-content=""\frac{n}{2}"" data-ignore-a11y-check="""">) + O(1) = ( T(<img class=""equation_image"" title=""\frac{n}{4}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B4%257D?scale=1"" alt=""LaTeX: \frac{n}{4}"" data-equation-content=""\frac{n}{4}"" data-ignore-a11y-check="""">) + O(1) ) + O(1) = T(<img class=""equation_image"" title=""\frac{n}{4}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B4%257D?scale=1"" alt=""LaTeX: \frac{n}{4}"" data-equation-content=""\frac{n}{4}"" data-ignore-a11y-check="""">) + 2O(1) = ... = T(<img class=""equation_image"" title=""\frac{n}{^{2^k}}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B%255E%257B2%255Ek%257D%257D?scale=1"" alt=""LaTeX: \frac{n}{^{2^k}}"" data-equation-content=""\frac{n}{^{2^k}}"" data-ignore-a11y-check="""">) + kO(1)&nbsp;<br>When 3 <img class=""equation_image"" title=""\cdot"" src=""/equation_images/%255Ccdot?scale=1"" alt=""LaTeX: \cdot"" data-equation-content=""\cdot"" data-ignore-a11y-check=""""> <img class=""equation_image"" title=""^{2^k}"" src=""/equation_images/%255E%257B2%255Ek%257D?scale=1"" alt=""LaTeX: ^{2^k}"" data-equation-content=""^{2^k}"" data-ignore-a11y-check=""""> = n, k = <img class=""equation_image"" title=""log_2"" src=""/equation_images/log_2?scale=1"" alt=""LaTeX: log_2"" data-equation-content=""log_2"" data-ignore-a11y-check="""">(<img class=""equation_image"" title=""\frac{n}{3}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{n}{3}"" data-equation-content=""\frac{n}{3}"" data-ignore-a11y-check="""">）, then T(n) = T(<img class=""equation_image"" title=""^{\frac{n}{2^k}}"" src=""/equation_images/%255E%257B%255Cfrac%257Bn%257D%257B2%255Ek%257D%257D?scale=1"" alt=""LaTeX: ^{\frac{n}{2^k}}"" data-equation-content=""^{\frac{n}{2^k}}"" data-ignore-a11y-check="""">) + kO(1) <img class=""equation_image"" title=""\le"" src=""/equation_images/%255Cle?scale=1"" alt=""LaTeX: \le"" data-equation-content=""\le"" data-ignore-a11y-check=""""> T(3) + <img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">(<img class=""equation_image"" title=""\frac{n}{3}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{n}{3}"" data-equation-content=""\frac{n}{3}"" data-ignore-a11y-check="""">) <img class=""equation_image"" title=""\cdot"" src=""/equation_images/%255Ccdot?scale=1"" alt=""LaTeX: \cdot"" data-equation-content=""\cdot"" data-ignore-a11y-check=""""> O(1) = O(1) +<img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">(<img class=""equation_image"" title=""\frac{n}{3}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{n}{3}"" data-equation-content=""\frac{n}{3}"" data-ignore-a11y-check="""">) <img class=""equation_image"" title=""\cdot"" src=""/equation_images/%255Ccdot?scale=1"" alt=""LaTeX: \cdot"" data-equation-content=""\cdot"" data-ignore-a11y-check=""""> O(1) = O(<img class=""equation_image"" title=""\log_2"" src=""/equation_images/%255Clog_2?scale=1"" alt=""LaTeX: \log_2"" data-equation-content=""\log_2"" data-ignore-a11y-check="""">n) -O(<img class=""equation_image"" title=""\log_{2^{}}"" src=""/equation_images/%255Clog_%257B2%255E%257B%257D%257D?scale=1"" alt=""LaTeX: \log_{2^{}}"" data-equation-content=""\log_{2^{}}"" data-ignore-a11y-check="""">3) + O(1)</p>
<p>Therefore, the complexity of the algorithm is O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Input: A[1,... ,n]<br>begin</p>
<p>if the length of the input array is 3:</p>
<p>&nbsp; &nbsp; return the index of the first element in A[1,... ,n]</p>
<p>mid = n / 2</p>
<p>if A[mid]&nbsp; &gt; A[mid+1]: search in A[1:mid+1]</p>
<p>else if A[mid] &lt; A[mid+1]: search in A[mid:n]<br><br>the number of the index is the length of A1</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Ahaan Bohra,492007,UW102T795,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:43:18 UTC,00:29:21,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = 3T(n/5) + 1&nbsp; for n &gt;= 5</p>
<p>T(1) = 1 for n &lt; 5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(1) = d</p>",1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n) = T(n/4) + c + c</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>T(n) = T(n/2^k) + kc</p>
<p>We stop when n/2^k = 1 =&gt; n = 2^k =&gt; k = log2(n)</p>
<p>So, T(n) = T(1) + c*log2(n)&nbsp; = d + c*log2(n)</p>
<p>Removing constants, T(n) = O(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Return: The integer k such that a = b<sup>k</sup></p>
<p>Divide: If a = 1, return 0</p>
<p>Else, compute c = isqrt(a) which gives b<sup>k/2</sup>. Then, recurse on c to find j such that c = b<sup>j</sup></p>
<p>Merge: Check if a = c * c. If so, then k = 2j, else k = 2j + 1</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Aarya Deshpande,393639,UW910Q336,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:30:57 UTC,00:39:25,1,18054,essay,"<p>Given T(n), where n=given list:</p>
<p>Recurrence is: <strong>T(1) = 1; T(n) = 3*T(n/2) + 2n</strong></p>
<p>Explanation: T(1) = 1 is the base case as the algorithm terminates when the length of the input list is of size 1; for the general recurrence, there is recursive and non-recursive work done on each level, with three recursive SuperReverse calls, each given input of half the size (hence 3*T(n/2), and the non-recursive work is the two linear scans of size of the input, or +2n.</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 1*T(n/2) + 5</p>
<p>Explanation: T(n/2) is multiplied by one, as we make only one recursive call each stage when dividing the problem roughly in half. ""+3"" since we are doing a constant two constant inequality comparisons and three element accesses.</p>",0.75,Graded,18157,essay,"<p>T(n) = 1*T(n/2) + 5</p>
<p>= T(n/2^2) + 5 +5</p>
<p>= T(n/2^3) +5 + 5 +5&nbsp;</p>
<p>= T(n/2^k) + ...</p>
<p>until size n/2^k = 1 element left, or k= log_2(n) levels.</p>
<p>Thus O(logn) since constant work per level times log_2(n) levels. This was unrolling the recurrence.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Strategy: start at the middle of the list and compare the current element, A[i], with both its left and right elements, A[i-1] and A[i+1], and check the conditions for when A[i] &gt; A[i-1] and A[i] &gt; A[i+1] (that is, A[i] is larger than its neighbor elements). If that element does not satisfy that condition, and if A[i-1] &lt; A[i] &lt; A[i+1], then we are in the ascending side and we then spawn a recursive call on the right side (new middle being [len(A) - i] / 2) that conducts the same check for A[i]&gt;A[i-1] &amp;&amp; A[i] &gt; A[i+1]. Else if, it the case was A[i-1] &gt; A[i] &gt; A[i+1], then we're in the descending side and we instead make a recursive call to the the middle of the left side. Since the equality check is constant time O(1), and given you can divide at most logn times, we new bound is O(logn).</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.75
Alex Ge,494697,UW988Q842,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 21:42:19 UTC,00:29:59,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>A(n) = A(n/4) + A(n/4) + 1 while len(A) &gt; 4</p>
<p>base cases: A(n) where n &lt; 4: 0, A(n) where n == 0: 1</p>",2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>A(n) = A(n/2)+c; c is some constant work</p>
<p>base case: n = 1 as next that means lo and hi are equal to each other</p>
<p>A(1) = d; d is some constant work</p>",1.0,Graded,18157,essay,"<p>d+c*<img class=""equation_image"" title=""\sum_0^{\log_{2_{}}n}\left(\frac{1}{2}\right)^k"" src=""/equation_images/%255Csum_0%255E%257B%255Clog_%257B2_%257B%257D%257Dn%257D%255Cleft(%255Cfrac%257B1%257D%257B2%257D%255Cright)%255Ek?scale=1"" alt=""LaTeX: \sum_0^{\log_{2_{}}n}\left(\frac{1}{2}\right)^k"" data-equation-content=""\sum_0^{\log_{2_{}}n}\left(\frac{1}{2}\right)^k"" data-ignore-a11y-check="""">=d+c*<img class=""equation_image"" title=""\frac{1-\left(\frac{1}{2}\right)^{\log_2n+1}}{1-\frac{1}{2}}"" src=""/equation_images/%255Cfrac%257B1-%255Cleft(%255Cfrac%257B1%257D%257B2%257D%255Cright)%255E%257B%255Clog_2n%252B1%257D%257D%257B1-%255Cfrac%257B1%257D%257B2%257D%257D?scale=1"" alt=""LaTeX: \frac{1-\left(\frac{1}{2}\right)^{\log_2n+1}}{1-\frac{1}{2}}"" data-equation-content=""\frac{1-\left(\frac{1}{2}\right)^{\log_2n+1}}{1-\frac{1}{2}}"" data-ignore-a11y-check="""">=d+2c*<img class=""equation_image"" title=""1-\left(\frac{1}{2}\cdot\left(\frac{1}{2^{\log_2n}}\right)\right)"" src=""/equation_images/1-%255Cleft(%255Cfrac%257B1%257D%257B2%257D%255Ccdot%255Cleft(%255Cfrac%257B1%257D%257B2%255E%257B%255Clog_2n%257D%257D%255Cright)%255Cright)?scale=1"" alt=""LaTeX: 1-\left(\frac{1}{2}\cdot\left(\frac{1}{2^{\log_2n}}\right)\right)"" data-equation-content=""1-\left(\frac{1}{2}\cdot\left(\frac{1}{2^{\log_2n}}\right)\right)"" data-ignore-a11y-check="""">)=d+2c*(<img class=""equation_image"" title=""1-\frac{1}{2}\cdot\frac{1}{n}"" src=""/equation_images/1-%255Cfrac%257B1%257D%257B2%257D%255Ccdot%255Cfrac%257B1%257D%257Bn%257D?scale=1"" alt=""LaTeX: 1-\frac{1}{2}\cdot\frac{1}{n}"" data-equation-content=""1-\frac{1}{2}\cdot\frac{1}{n}"" data-ignore-a11y-check="""">)=d+2c*(1-1/2n)=d+2c-c/n&nbsp; where d and c are constant factors</p>
<p>Theta(logn)</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Input: A, k,</p>
<p>while lo &lt; hi:</p>
<p>mid = (hi - lo)/2</p>
<p>if A[mid]&gt;=k</p>
<p>&nbsp; if(i = 1 or A[i-1]&lt;k):</p>
<p>&nbsp; &nbsp; return A[i]</p>
<p>&nbsp; else:</p>
<p>&nbsp; &nbsp; hi = mid</p>
<p>else:</p>
<p>&nbsp; lo = mid</p>
<p>return None</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
Ryan Chung,516761,UW099K879,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 21:53:39 UTC,00:29:52,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 2T(n/3) + O(n)</p>
<p>Base case: T(1) = O(1), T(2) = O(1)</p>",3.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>min_cores(1, n):</p>
<p>low = 1</p>
<p>high = n</p>
<p>if low &gt; high, return low (base case)</p>
<p>mid = (low + high) // 2</p>
<p>if using mid cores runs in under 1:<br>return min_cores(low, mid-1)</p>
<p>else:<br>return min_cores(mid+1, high)</p>
<p>&nbsp;</p>",3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>Base case: T(1) = 1</p>",1.0,Graded,18157,essay,"<p>This recurrence will create a recurrence tree of height log_2(n) since at each level, each call recursively makes 2 more calls until reaching the base case. At each level the work is constant, so the total work done is O(log_2(n)), so we can just say O(log(n)).</p>",1.5,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Zuheb IBRAHIM,445749,UW949X385,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 21:48:07 UTC,00:28:20,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>base case: T(n) = O(1) for n &lt; 3<br>T(n) = 2T(2n/3) + O(1)</p>,3.0,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>BinarySearch(1,n)<br>start&nbsp;<br>if n == 1<br>return 1</p>
<p>middle &lt;- [(1+n)/2]<br>if run is under 1 sec on middle then<br>return BinarySearch(1, middle)<br>else<br>return BinarySearch(middle + 1, n)<br>end</p>",3.0,Graded,18156,essay,<p>base case: T(1) = O(1)<br>on each recuersion we do one and recurse on half<br>T(n) = T(n/2) + O(1)</p>,1.0,Graded,18157,essay,<p>T(n) = T(n/2) + c = T(n/4) +2c = T(n/8) + 3c ..... = T(1) + clog2n<br>T(n) = O(log n) since T(1) = O(1)</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Yuliang Wu,519573,UW997H186,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 21:55:45 UTC,00:30:00,1,18054,essay,"<p>Base case: for n=1: T(1)=<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1).</p>
<p>Recurrence: for n&gt;1: three recursive calls (one for first half, second for second half, third for first half) and does two full linear scans. So, T(n)=T(n/2)+T(n/2)+T(n/2)+<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1).</p>
<p>Therefore, T(n)=3T(n/2)+<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(n)</p>",3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base case: for n=1: T(1)=<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1).</p>
<p>Recurrence(upper bound): for n&gt;1: T(n)=T(n/2)+c for a constant c&gt;0 accounting for the O(1) work done at each step before recursing on one half.</p>",1.0,Graded,18157,essay,"<p>T(n)=T(n/2)+c=[T(n/2^2)+c]+c=...=T(n/2^k)+kc</p>
<p>n/2^k=1, k=log2(n).</p>
<p>T(n)=T(1)+clog2(n)=d+clog2(n)</p>
<p>Since c and d are constants, the asymptotic growth is determined by the log term.</p>
<p>T(n)=<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(log n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Since A1 is increasing and A2 is decreasing, there is a index value that is the turning point. We can apply a binary-search-like algorithm: divide the array in half, check the middle element, and recursively search one side. If A[mid]&lt;A[mid+1], then we are still inside the increasing part of A, so we recursively seach the right half; otherwise, we recursively search the left half. Continue this process until we find the only one element, and that position gives the length of A1.&nbsp;</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Joy Hong,515137,UW112F962,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 21:52:51 UTC,00:25:24,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>T(n) = O(1) if n &lt; 5;&nbsp;3T(n/5) + O(1) if n &gt;= 5</p>
<p>&nbsp;</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(x) = 1 if x &lt;= 1</p>
<p>T(x) = T(floor(x/2)) + 1</p>",1.0,Graded,18157,essay,"<p>Each recursion adds +1 to the work, so after k steps, T(n) = T(n<sub>k</sub>) + k. We stop when n<sub>k</sub> &lt;= 1, and the smallest such k is floor(logn). T(n) = T(1) + k = 1 + logn -&gt; O(logn)</p>
<p>Solution: O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Using binary search. low = 0, high = x, m = (low + high) / 2. Repeatedly test the midpoint m and compare m<sup>2</sup> with x to decide whether the root lies above or below m. If m<sup>2</sup> equals x then return m, if m<sup>2</sup> is less than x then with low = m + 1, else high = m - 1.</p>",3.0,Graded,0,0,0,9.0,9.0
Lucy Lisberg,430141,UW936K160,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 22:16:48 UTC,00:45:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,<p>A(n) = A(n/2) + 2A(n/4) + n + c ; A(1) = 1</p>,3.0,Graded,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c ; T(1) = 1</p>,1.0,Graded,18157,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n/2) = (T(n/4) + c) + c</p>
<p>T(n/4) = ( (T(n/8) + c) + c ) + c</p>
<p><strong>T(n) = T(n/2^k) + kc</strong><br><strong></strong></p>
<p>T(1) = 1 --&gt; 1 = n / (2^k) = (2^k) = n :&nbsp;<strong>k = log n</strong></p>
<p>T(n) = T(1) + (log n)c : <span style=""background-color: #fbeeb8;"">T(n) = O(log n)</span></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Input A,k : Array A, number k</p>
<p><em>find </em>(A,k) :</p>
<p>if ( length(A) == 1 ) {</p>
<p>if ( A[0] &lt; k ) : return None</p>
<p>else : return A[0] }</p>
<p>split array A into two halves:</p>
<p>L = left half of A</p>
<p>R = right half of A</p>
<p>if <span style=""text-decoration: underline;""><strong>last</strong></span> element of LEFT is &lt; k : return <em>find </em>(RIGHT, k)</p>
<p>else : return <em>find</em> (LEFT, k)</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Avery Schwalbe,351070,UW892H234,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 21:58:02 UTC,00:21:15,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>3 recursive calls</p>
<p>lines 1-6, O(1)</p>
<p>T(n/3) + 1</p>",1.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>2 recursive calls, base cases of O(1) run time</p>
<p>T(n/2) + 1</p>",0.0,Graded,18157,essay,"<p>T(n/2) + 1</p>
<p>&nbsp; &nbsp; &nbsp;T(n)</p>
<p>T(n/2)&nbsp; &nbsp; T(n/2)&nbsp; &nbsp;=&nbsp; 2n/2</p>
<p>T(n/4) t(n/4) t(n/4) t(n/4)&nbsp; =&nbsp; &nbsp;4n/4</p>
<p>&nbsp;</p>
<p>can be solved as (2^i *n )/2^k</p>
<p>k = log2n</p>
<p>therefore the relation&nbsp; = O(logn)</p>
<p>&nbsp;</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>algorithm Divide and Conquer<br>divide list of distances from 0&lt;= n into 2 lists L and R.</p>
<p>r = 0</p>
<p>if GetsService(r) == True return r</p>
<p>if n == 0 return r</p>
<p>Recursively check list L and also recursively check list R until GetsService(r) == True and store idx Li and Ri respectively</p>
<p>if Li &lt; Ri r = Li</p>
<p>if Ri&lt; Li r = Ri</p>
<p>else Li = Ri = r</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.0
Harshit Goyal,493447,UW105O890,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 22:00:12 UTC,00:21:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>A(n)=A(n/2)+2A(n/4)+cn for some constant c&nbsp;</p>
<p>Base Case: A(1)=1</p>",3.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n)=T(n/2)+1 as the division is cut in half in every iteration and there is constant operation on each level</p>,0.75,Graded,18157,essay,"<p>T(n)=T(n/2)+1</p>
<p>T(n)=T(n/4)+2</p>
<p>T(n)=T(n/8)+3</p>
<p>T(n)=T(n/2^k)+k</p>
<p>then if we equate base case T(1)=1</p>
<p>&nbsp;then logn is depth and each step has 1 as the running time so we get O(log n)&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Algorithm GetRange(r):</p>
<p>low=1</p>
<p>high=n</p>
<p>while low&lt;high:</p>
<p>mid=floor((low+high)/2)</p>
<p>if GetsService(mid)==True:</p>
<p>high=mid</p>
<p>else:</p>
<p>low=mid+1</p>
<p>return low</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.75
Colin Yamada,513386,UW097A415,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:06:32 UTC,00:28:28,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,<p>T(n) = 2*T(1/3) + O(n)</p>,2.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 2T(n/2) + O(n)<br>T(1) = 1</p>
<p>&nbsp;</p>",0.0,Graded,18157,essay,"<p>For each recursive layer i, n/(2^i)</p>
<p>T(1) = 1 = n/(2^i)</p>
<p>i = log(n)</p>
<p>&nbsp;</p>
<p>Sum of all layers, i.e, T(n) can be written as:<br>&nbsp;<img class=""equation_image"" title=""T\left(n\right)=\sum_{i=1}^{\log\left(n\right)}n=n\sum_{i=1}^{\log\left(n\right)}=O\left(\log\left(n\right)\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253D%255Csum_%257Bi%253D1%257D%255E%257B%255Clog%255Cleft(n%255Cright)%257Dn%253Dn%255Csum_%257Bi%253D1%257D%255E%257B%255Clog%255Cleft(n%255Cright)%257D%253DO%255Cleft(%255Clog%255Cleft(n%255Cright)%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=\sum_{i=1}^{\log\left(n\right)}n=n\sum_{i=1}^{\log\left(n\right)}=O\left(\log\left(n\right)\right)"" data-equation-content=""T\left(n\right)=\sum_{i=1}^{\log\left(n\right)}n=n\sum_{i=1}^{\log\left(n\right)}=O\left(\log\left(n\right)\right)"" data-ignore-a11y-check=""""></p>
<p>Thus, asymptotic solution is <img class=""equation_image"" title=""O\left(\log\left(n\right)\right)"" src=""/equation_images/O%255Cleft(%255Clog%255Cleft(n%255Cright)%255Cright)?scale=1"" alt=""LaTeX: O\left(\log\left(n\right)\right)"" data-equation-content=""O\left(\log\left(n\right)\right)"" data-ignore-a11y-check=""""></p>",0.0,Graded,25540,essay,"<p>Func(x):</p>
<p>&nbsp; &nbsp; if(x == 0) return 1</p>
<p>&nbsp; &nbsp; else if(x == 1) return e</p>
<p>&nbsp; &nbsp; else if (x is even):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return Func(x/2) * Func(x/2)</p>
<p>&nbsp; &nbsp; else (x is odd):</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return Func(x/2) * Func(x/2) * e</p>
<p>&nbsp; &nbsp;&nbsp;</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,3.0
Enrique Villasenor,499140,UW100U189,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:40:41 UTC,00:45:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(3) = 0.&nbsp; T(n) = 2T(n/4) + 1</p>,2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,"<p>T(0) = 0, T(n) = T(n/2) + 1</p>",0.0,Graded,18157,essay,<p>we would get the recursive sum of sum(1) from i = 0 to k. The recursion ends when the n/2^i = 1 so when i = log(n) so then our sum will sum 1 log(n) times so our time complexity results in O(logn)&nbsp;</p>,0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Given the value x we use a the remainder operator (%) to figure out if x is an even or odd number (O(1))</p>
<p>By doing this we cut the number of possible value in half since either we're going to be looking for an odd number or an even number&nbsp;</p>
<p>now we start looking for r</p>
<p>if x is odd we start from r = 1 and increment by 2 until we reach x. if x&nbsp; is even then we start at r =2 and increment by 2 until we reach x&nbsp;</p>
<p>we preform floor(x/2) and if it is not equal to 1 we call a recursive call using floor(x/2) as as an argument&nbsp;</p>
<p>These recursive loops will find the median betwen r initial and r = x-1 which should result in the value of sqrt(x)</p>
<p>&nbsp;</p>
<p>for r to x&nbsp;</p>
<p>if floor(x/2) != 1&nbsp;</p>
<p>recursive call(x/2)</p>
<p>else&nbsp;</p>
<p>&nbsp;</p>",1.0,Graded,0,0,0,9.0,3.5
Sharath Kowdle,514080,UW981T465,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:08:54 UTC,00:22:04,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>If the array has fewer than 5 elements, the algorithm stops.</p>
<p>Base case: constant time T(n) = <img class=""equation_image"" title=""\theta\left(1\right)"" src=""/equation_images/%255Ctheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \theta\left(1\right)"" data-equation-content=""\theta\left(1\right)"" data-ignore-a11y-check=""""> for n &lt; 5</p>
<p>Otherwise:</p>
<p>One swap is done <img class=""equation_image"" title=""\theta\left(1\right)"" src=""/equation_images/%255Ctheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: \theta\left(1\right)"" data-equation-content=""\theta\left(1\right)"" data-ignore-a11y-check=""""></p>
<p>Three recursive calls:</p>
<p>&nbsp; &nbsp; &nbsp; On the first fifth of A : size n/5</p>
<p>&nbsp; &nbsp; &nbsp; On the third fifth of A : also roughly size n/5</p>
<p>&nbsp; &nbsp; &nbsp; On the foruth fifth of A: also roughly size n/5</p>
<p>Thus, each recursive call is made on a subarray of size n/5</p>
<p>&nbsp;</p>
<p>Writing the recurrence relation</p>
<p>Each recursive call is independent and has size n/5</p>
<p>There are 3 recursive calls so:</p>
<p>T(n) = 3T(n/5) + (1)</p>
<p>&nbsp;</p>
<p>Base Case</p>
<p>For arrays smaller than size 5:</p>
<p>T(n) = (1) for n &lt; 5</p>
<p>&nbsp;</p>
<p>Final Recurrence:</p>
<p>T(n) = 1 if n &lt; 5,</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3T(n/5) + (1), if n5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = (1) if n <img class=""equation_image"" title=""\le1"" src=""/equation_images/%255Cle1?scale=1"" alt=""LaTeX: \le1"" data-equation-content=""\le1"" data-ignore-a11y-check="""">,</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;T(n/2) + (1) if n <img class=""equation_image"" title="">1"" src=""/equation_images/%253E1?scale=1"" alt=""LaTeX: >1"" data-equation-content="">1"" data-ignore-a11y-check=""""></p>",1.0,Graded,18157,essay,"<p>Solving by expanding:</p>
<p>T(n) = T(n/2) + c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = T(n/4) + 2c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = T(n/8) + 3c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= T(n/2<img class=""equation_image"" title=""^k"" src=""/equation_images/%255Ek?scale=1"" alt=""LaTeX: ^k"" data-equation-content=""^k"" data-ignore-a11y-check="""">) + kc</p>
<p>The recursion stops when n/<img class=""equation_image"" title=""2^k"" src=""/equation_images/2%255Ek?scale=1"" alt=""LaTeX: 2^k"" data-equation-content=""2^k"" data-ignore-a11y-check="""">&nbsp;= 1, so k = <img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""></p>
<p>Substitute back:</p>
<p>T(n) = T(1) + c<img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""></p>
<p>Since T(1) = (1):</p>
<p>T(n) = (logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>function FindMinRange(n):</p>
<p>&nbsp; &nbsp; &nbsp; low = 0</p>
<p>&nbsp; &nbsp; &nbsp; high = n</p>
<p>&nbsp; &nbsp; &nbsp; while low &lt; high:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid = (low+high) // 2</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if GetService(mid) == True:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;high = mid</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else:</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;low = mid + 1</p>
<p>&nbsp; &nbsp; &nbsp;return low</p>
<p>&nbsp;</p>
<p>Each call to GetService(r) splits the search space in half</p>
<p>You only need O(log n) checks instead of O(n)</p>
<p>Once the loop ends low will hold the smallest range r where GetService(r) becomes true</p>
<p>Asymptotic Runtime</p>
<p>Brute force: O(n)</p>
<p>Divide and conquer: O(log n)</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Adi Srinivasan,504524,UW986T088,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:38:24 UTC,00:28:06,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,<p>3T(n/5) + c</p>,2.5,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>2T(n/2) + c</p>,0.0,Graded,18157,essay,"<p>Tree with n/2 in nodes. Solve for n/2^k = 1. so log2(n) = k. Then summation from 1 to log2k-1 of (1/2)^2k + 2^log2k since log2k equals n. From here, solving the summation gives, using the geometric sum formula, gives Big O(logn) since the work at each step outside of the recursion is constant.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Divide and conquer approach:<br><br>Base case: If(k &lt; 1) return k</p>
<p>&nbsp;</p>
<p>Divide k, recurse on the halves. (2 calls * (n/2) for recurrence)</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Grayson Peake,584128,UW101A289,"602067,592418","COMP SCI 577:DIS312,COMP SCI 577:LEC001","1262:30195,1262:23138",2025-10-17 22:12:30 UTC,00:11:05,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 2T(n/3) + n</p>
<p>T(1) = 1</p>",2.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c&nbsp; (where c is some constant time operations)</p>
<p>T(1) = 1</p>
<p>&nbsp;</p>",1.0,Graded,18157,essay,"<p><span style=""font-family: inherit; font-size: 1rem;"">Unrolling:</span></p>
<p><span style=""font-family: inherit; font-size: 1rem;"">T(n) = T(n/2) + c -&gt; T(n/4) + c -&gt; T(n/8) + c&nbsp;</span></p>
<p>Thus at level i we have a list of size <img class=""equation_image"" title=""\frac{n}{2^i}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B2%255Ei%257D?scale=1"" alt=""LaTeX: \frac{n}{2^i}"" data-equation-content=""\frac{n}{2^i}"" data-ignore-a11y-check="""">. Thus <img class=""equation_image"" title=""i=\log_2n"" src=""/equation_images/i%253D%255Clog_2n?scale=1"" alt=""LaTeX: i=\log_2n"" data-equation-content=""i=\log_2n"" data-ignore-a11y-check="""">. This means that T(n) is O(log(n)) since there are log(n) levels of recursion and a constant-time amount of work done per level.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Algorithm: Divide and Conquer</p>
<p>Input: A[1...n]</p>
<p>begin</p>
<p>&nbsp; if(n==1) {return 1}</p>
<p>&nbsp; mid = floor(n / 2)</p>
<p>&nbsp; left = A[1...mid]</p>
<p>&nbsp; right = A[mid + 1...n]</p>
<p>&nbsp; if(left[mid] &lt; right[mid + 1]) {return Algorithm(left)}</p>
<p>&nbsp; &nbsp;else{return Algorithm(right)}</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.0
Lily Wang,505968,UW999V188,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:22:25 UTC,00:23:20,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"<p>T(n) = 2T(n/4) + O(1)</p>
<p>base case: T(length(A) &lt; 4) = 0</p>",2.5,Graded,18155,essay,"<p>findMinCores(low, high):</p>
<p>&nbsp; &nbsp; if high == low then return low</p>
<p>&nbsp; &nbsp; mid = (low +&nbsp; high)/2</p>
<p>&nbsp; &nbsp; if runtime runs in under 1 second then return findMinCores(low,mid)</p>
<p>&nbsp; &nbsp; else then findMinCores(mid +1 , high)</p>",3.0,Graded,18156,essay,"<p>T(n) = T(n/2) + O(1)</p>
<p>T(1) = c</p>",1.0,Graded,18157,essay,"<p>Unrolling:&nbsp;</p>
<p>T(n/2) = T(n/4) + 2c</p>
<p>T(n/4) = T(n/8) + 3c</p>
<p>pattern: T(n/2^k) + kc at the kth level</p>
<p>n/2^k = 1</p>
<p>n = 2^k</p>
<p>k = log2(n)</p>
<p>O(n) = log2(n)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Aksel Jackson,503261,UW979N791,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:45:00 UTC,00:27:51,1,18054,essay,<p>P(n) = 3P(n/2) + 2n; p(1) = 1</p>,3.0,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>/* When using this array to find the # of neccessary cores, we would use 1 as the start, and n as the end.</p>
<p>&nbsp; &nbsp; &nbsp;This way we can do a simple binary search, observe the middle, if it fullfills the required task (runs in under</p>
<p>&nbsp; &nbsp; &nbsp;1 second) then we can search the lower half of the number of cores to figure out if there is a possible smaller # of cores we could use.</p>
<p>&nbsp; &nbsp; &nbsp;If it doesn't fullfill the task then we can divide the list to just the front half, and perform the same check to find our target value. */</p>
<p>&nbsp;</p>
<p>FindMinCores(start, end):</p>
<p>&nbsp; /* BASE CASE */</p>
<p>&nbsp; if (end &lt;= start) return end;<br><br>&nbsp; /* RECURSIVE CASE */</p>
<p>&nbsp; mid = start + end / 2</p>
<p>&nbsp; if (the routine runs in under 1 second on mid cores):</p>
<p>&nbsp; &nbsp; FindMinCores(start, mid);</p>
<p>&nbsp; else:</p>
<p>&nbsp; &nbsp; FindMinCores(mid + 1, end);</p>",3.0,Graded,18156,essay,<p>D(n) = D(n/2) + 2; D(1)=1</p>,1.0,Graded,18157,essay,"<p>D(n) = D(n/2) + 2<br>D(n/2) = D(n/4) + 2<br>...<br>D(n/2^k) = D(n/2^(k+1)) + 2</p>
<p>...</p>
<p>D(1) = 1</p>
<p>As a tree we can see that each call to D is performing a constant number of operations. That means the tree will commit 1 operation for every level of the tree is only 1 call of D. The reccurence tree is at the bottom when n/2^k = 1.<br>n/2^k = 1</p>
<p>n = 2^k</p>
<p>logn = k<br>This means that there will be logn total layers on our tree (except the bottom), all performing a constant opperation.&nbsp; Then there will be the last operation that is 1 check (base case).<br>logn * 2 + 1 =&gt; O(logn)</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Aron FRIDMAN,492346,UW986Y900,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:24:02 UTC,00:28:11,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,<p>T(n) = 2T(n/4) + C; T(3) = 0</p>,2.5,Graded,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + C ; T(1) = 1</p>,1.0,Graded,18157,essay,"<p>level 1: (n) | work - C.&nbsp; level 2: ( n/2) | work - C level 3: (n/4) | work - C&nbsp; level k: (n/2^k) ,&nbsp; n/2^k = 1&nbsp; n = 2^k, k = log_2 n&nbsp; &nbsp;sum from k =1 to log_2n of C = Clogn so this Algorithm is O(logn)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>We will first check the middle element if that element is greater than or equal to k we will store it as a local min and recursively check the left side of the list. if it is less than K we will recursivley check the right side of the list, we will do this until there is one element left in our list if this element is less than k and we havent found another candidate then we return none. we will compare the local mins at each step and return the smallest x &gt;= k.</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Carter Powelson,442508,UW929M215,"602069,592418","COMP SCI 577:DIS314,COMP SCI 577:LEC001","1262:30197,1262:23138",2025-10-17 22:26:14 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = O(logn) + O(n) + 2(logn)</p>,0.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + kc; T(1) = 1; T(1) &lt;= c</p>,1.0,Graded,18157,essay,"<p>The recurrence: T(n) = T(n/2) + c is the same as a binary search algorithm, which has a runtime of O(logn).</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"<p>Goal: Find the largest number x where x &lt;= k.</p>
<p>Return Values: Largest number x that is greater than k if any.</p>
<p>Divide: We will divide the sorted list A into two halves, A_L and A_R. We will recursivley split these halves to find the largest value x that is less than or equal to k.</p>
<p>Conquer: At each step, we will devide whether or not to call recursion on A_L or A_R. Let m be the size of A_L. if A_L[m] is greater than k, then we need to call A_L. If A_R[0] is less than k, we need to call A_R.</p>
<p>Solution: Eventually we will return one value whenever our list size is 1, or none if there doesn't exist a value x that is &lt;= k.&nbsp;</p>
<p>Base Case: (2 statements)</p>
<p>If A[0] &gt; k, return ""None""&nbsp;</p>
<p>If |A| == 1, return A[0]</p>",3.0,Graded,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,4.0
Edward Zhao,511799,UW009L581,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 22:28:04 UTC,00:29:46,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>Let n be the number of elements in array A. There are 2 possible base cases, both return constant time O(1). The base case happens when n&lt;=2, giving us the base case T(1) = 1. There are 2 recursive calls, each with 1/3 the size of the input of the original array. The work in each recursive call is O(n) because it iterates through one third of the array. This gives us a reccurence relation of:</p>
<p>T(n) = 2T(n/3) + n, T(1) = 1</p>",2.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>The base case just checks if x is equal to 0 or 1, which is constant time, so base case T(1) = 1. In each recursive call, the value of x is split in half, giving us an input of n/2, and only one half is chose, the other is discarded, giving us T(n/2). The work to calculate mid and check squares is constant time O(1), giving us a final reccurence relation of:<br>T(n) = T(n/2) + 1, T(1) = 1</p>",1.0,Graded,18157,essay,"<p>Given the reccurence relation T(n) = T(n/2) + 1, T(1) = 1</p>
<p>We can use the reccurence tree method to solve this problem. We know the root node of the tree is n, and then it has one child n/2, then that child has a one child node n/4, then n/8 and so forth. The work at each step in the tree is constant and we get a size of n /(2^k). Setting this equal to the base case, we get n/ (2^k) = 1=&gt; n = 2^k, and finally giving us k = log2 n which can be simplified to just log n. Because the work is constant in each step, the total work is just the height of the tree, giving us log n. Therefore, the asymptotic solution to the algorithm is O(logn).</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>Input: x, a perfect square</p>
<p>Output: r, the square root of x</p>
<p>Root (x):</p>
<p>if (x == 0) return 0</p>
<p>if (x == 1) return 1</p>
<p>l = 0</p>
<p>r = x</p>
<p>while (l &lt; r)</p>
<p>mid = (l + r) / 2</p>
<p>if ((mid * mid) == x) return mid</p>
<p>else if ((mid * mid) &lt; x)</p>
<p>l = mid + 1</p>
<p>else&nbsp;</p>
<p>r = mid - 1</p>",3.0,Graded,0,0,0,9.0,8.0
Dieu-Hien Le,252458,UW718B840,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:45:00 UTC,00:39:11,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=2T\left(\frac{n}{3}\right)+\frac{n}{3}+c"" src=""/equation_images/T%255Cleft(n%255Cright)%253D2T%255Cleft(%255Cfrac%257Bn%257D%257B3%257D%255Cright)%252B%255Cfrac%257Bn%257D%257B3%257D%252Bc?scale=1"" alt=""LaTeX: T\left(n\right)=2T\left(\frac{n}{3}\right)+\frac{n}{3}+c"" data-equation-content=""T\left(n\right)=2T\left(\frac{n}{3}\right)+\frac{n}{3}+c"" data-ignore-a11y-check=""""></p>",2.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"",0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Input: Array A, number k</p>
<p>Output: smallest number x such that <img class=""equation_image"" title=""x\ge k"" src=""/equation_images/x%255Cge%2520k?scale=1"" alt=""LaTeX: x\ge k"" data-equation-content=""x\ge k"" data-ignore-a11y-check=""""> and <img class=""equation_image"" title=""x\in A"" src=""/equation_images/x%255Cin%2520A?scale=1"" alt=""LaTeX: x\in A"" data-equation-content=""x\in A"" data-ignore-a11y-check=""""></p>
<p>Base Case: n = 0, return ""none""</p>
<p>Check the element at <img class=""equation_image"" title=""j=A\left\lbrack\lceil\frac{n}{2}\rceil\right\rbrack"" src=""/equation_images/j%253DA%255Cleft%255Clbrack%255Clceil%255Cfrac%257Bn%257D%257B2%257D%255Crceil%255Cright%255Crbrack?scale=1"" alt=""LaTeX: j=A\left\lbrack\lceil\frac{n}{2}\rceil\right\rbrack"" data-equation-content=""j=A\left\lbrack\lceil\frac{n}{2}\rceil\right\rbrack"" data-ignore-a11y-check="""">. If j = k return. If j &lt; k, recurse on the right half of A from ((n/2)+1, n). if j&gt;k recurse on the left half</p>
<p>&nbsp;</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.5
Keagan Kautzer,481023,UW875L370,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:31:36 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>A(n) = A(2/3n) + A(2/3n) + 1</p>,2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Let t be the number possible values for sqrt(x), such that t initially equals x/2. Then, since our range either returns a valid value when found, or cuts the range of values in half with each iteration, S(t, x, r) = S(t/2, x) + 1. S(t, 0) = 0, and S(t, 1, r) = 1. We can also define a value r, such that r = lower bound + t / 2. When r^2 = x, this also returns.</p>",1.0,Graded,18157,essay,"<p>The algorithm reduces by at least a size of 2 with each call. In the worst case, sqrt(x) is the last possible value that we can check. For an input value x, assuming x is greater than or equal to 2, the most amount of checks we can do is log_2 (x). If x = 0 or x = 1, this function completes in constant time. Also, this function only returns the value r such that r^2 = x, so each recursive call has constant time operations. Thus, the worst-case performance is O(1) if x is less than or equal to 1, or O(log_2 (x)) otherwise.</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>If x == 0 or x == 1: return x, since 0^2 = 0 and 1^2 = 1</p>
<p>Else, let our initial lower bound = 1, initial upper bound = x/2</p>
<p>Let r be the midpoint between the lower and upper bound for any recursive call</p>
<p>If r^2 = x, return r</p>
<p>Otherwise, if r^2 is greater than x, update the upper bound to be r-1, and recurse again.</p>
<p>Otherwise, if r^2 is less than x, update the lower bound to be r+1, and recurse again.</p>",3.0,Graded,0,0,0,9.0,8.5
Timothy Pavelko,499094,UW100S154,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:26:35 UTC,00:24:58,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,<p>T(n) = 3T(n/2 + n/4) + c</p>,0.0,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + c</p>,0.75,Graded,18157,essay,"<p>O(log n)</p>
<p>T(n/2) + c</p>
<p>T(n/4) + c</p>
<p>T(n/8) + c</p>
<p>T(n/2^k) + c</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>We will use a version of binary search with the help of the isqrt(a) function. Instead of only moving by 1 step, we should be moving by squares. start by checking power of 0 which is 1 which is too small. Instead of only adding one step, we multiple by 2. In the first pass, we will go from 0 --&gt; 1 then 1 --&gt; 2 then 2 --&gt; 4. This way, we skip checking many middle numbers. In the likely chance we overshoot, we will go back n/2 steps just like binary search. so if we got to 16 and that number was too high, we will go to 12 because it is in the middle of 8 and 16.</p>",1.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,1.75
Sudeep Srisailapu,431426,UW938B857,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:13:26 UTC,00:10:30,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,<p>T(n) = 3T(n/3) + O(1) which gives us a runtime of T(n) -&gt; O(n) as this simplifies to T(n) = T(n) + O(1).</p>,0.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = T(n/2) + c</p>
<p>T(n/ 2) because we divide each side recursively in half, we get + C or + O(1) because checking the values takes constant work.</p>",0.75,Graded,18157,essay,<p>As we rercusively divide the list into smaller and smaller halves we find that the depth of this tree is equal to that of log2(n). At each step we do constant work to check for the desired condition. By writing this out we get that O(log2n + C) which simplifies to O(log n) runtime.</p>,2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Divide: First split the array into two halves and find the mid point (mid = low + high / 2)</p>
<p>Conquer: Next we need to return the number of elements in A1, which is the elements in increasing order. This means that we must check at the mid point to determine whether the values next to the midpoint, is either greater or less than. If the value to the left is greater, this means that we search the right side. If the value to the right side is greater, this means that we search the left side.</p>
<p>Base case: low == high, in which we return the length.</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.75
Faizan Ali,423907,UW117U048,"604835,592418","COMP SCI 577:DIS318,COMP SCI 577:LEC001","1262:32155,1262:23138",2025-10-17 22:27:34 UTC,00:22:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p><img class=""equation_image"" title=""T\left(n\right)\lbrace\Theta\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%255Clbrace%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)\lbrace\Theta\left(1\right)"" data-equation-content=""T\left(n\right)\lbrace\Theta\left(1\right)"" data-ignore-a11y-check="""">, if n&lt;5</p>
<p><img class=""equation_image"" title=""T\left(n\right)\lbrace3T\left(\frac{n}{5}\right)+\Theta\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%255Clbrace3T%255Cleft(%255Cfrac%257Bn%257D%257B5%257D%255Cright)%252B%255CTheta%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)\lbrace3T\left(\frac{n}{5}\right)+\Theta\left(1\right)"" data-equation-content=""T\left(n\right)\lbrace3T\left(\frac{n}{5}\right)+\Theta\left(1\right)"" data-ignore-a11y-check="""">, if n&gt;=5</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Base Case:-</p>
<p>T(n) = O(1), for n &lt;=1</p>
<p>Recursive case:-</p>
<p>T(n)= T9n/2) +O(1) for n&gt;1</p>
<p>where n represents the size of the search range(high - low +1)</p>",1.0,Graded,18157,essay,"<p>Given T(n) = T(n/2)+c with T(1)=c<br>T(n) = T(n/2) +c<br>= c + c+ c+...+c<br>=clog2n<br>O(logn)</p>
<p>T(n)=O(logn)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"<p>sqrtDivideConquer(x,low,high):</p>
<p>iflow.high:</p>
<p>return -1<br><br>mid=(low+high)/2</p>
<p>square = mid*mid</p>
<p>&nbsp;</p>
<p>if square == x:</p>
<p>return mid</p>
<p>esle if square&gt;x:</p>
<p>return sqrtDivideConquer(x,low,mid-1)</p>
<p>else:</p>
<p>return sqrtDivideConquer(x,mid+1, high)</p>",3.0,Graded,0,0,0,9.0,9.0
Peter Dimond,475779,UW974R633,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:33:26 UTC,00:24:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"<p>T(1) = c, T(2) = c</p>
<p>T(n) = 3T(2/3n) + c</p>",3.0,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>R(1) = c</p>
<p>R(n) = R(n/2) + c</p>",1.0,Graded,18157,essay,"<p>R(1) = c</p>
<p>R(n) = R(n/2) + c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = R(n/4) + 2c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = R(n/8) + 3c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = R(1) + c * log(n)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = c * log(n) + c&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= O(log n)&nbsp;</p>
<p>&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>Start with search area [1..., n] of A, call it S. Run Recursion(S) and return that value as the number of elements in A1.</p>
<p>Recursion on S:</p>
<p>If the size of S is 1, return that value. Else,</p>
<p>Select the midpoint m of S and compare the values of A[m] and A[m+1].</p>
<p>If A[m] &lt; A[m+1], set S to [m, end of S] and repeat.</p>
<p>If A[m] &gt; A[m+1] set S to [start of S, m] and repeat.</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,9.0
Qingyi Xiang,499139,UW108R233,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:39:21 UTC,00:29:08,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,<p>T(n) = 2T(2n/3)+c&nbsp; &nbsp;base case n=2</p>,2.5,Graded,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = 2T(n/2)+c the bsae case is n=2</p>,0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>the base case is a&nbsp; = b^k</p>
<p>we use isqrt(a) and get answer r</p>
<p>if a/r &gt;1 k+2</p>
<p>if a/r&lt;1 k-2</p>
<p>&nbsp;</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Praneet Popuri,516839,UW099X450,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:35:12 UTC,00:28:42,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"<p>T(n) = 3T(n) + n</p>
<p>T(1) = 1</p>",1.5,Graded,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(1) = 1</p>
<p>T(n) = T(n/2) + 1</p>",1.0,Graded,18157,essay,"<p><img class=""equation_image"" title=""\sum_i"" src=""/equation_images/%255Csum_i?scale=1"" alt=""LaTeX: \sum_i"" data-equation-content=""\sum_i"" data-ignore-a11y-check="""">1/2^i *1 is the number of computations and using the geometric series it will simplify to log(n). this can be seen in the recursion tree where there is no branches just 1 -&gt; 1/2 -&gt; 1/4. and this constant time expersion will happen log(n) times so its log(n)*c = log(n)</p>",1.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>base case is: if the element to left is less than the current element and the element to the right is less than the current element, return i-1;</p>
<p>take the middle element check the base case,</p>
<p>if the element to the right is greater than the current element than recurse on the right array</p>
<p>if the element to the left is greater then recurse on the left side of the array</p>
<p>&nbsp;</p>",3.0,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.5
Conner Moore,481060,UW877F204,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 22:40:04 UTC,00:30:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"<p>T(n) = 2T(n/3) + n, and T(1) = O(1)</p>",2.0,Graded,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>T(n) = 1*T(n/2) + O(n), T(1) = O(1)</p>
<p>Recurrence tree shows that at depth k, there will be n/2^k work being done.</p>
<p>At depth k = d (base case, depth.), log base 2(n) = k is our depth.</p>
<p>So, n * summation from k=0 to depth log base 2(n) of 1/2^k is the equation. Which is O(logn)</p>",0.5,Graded,18157,essay,"<p>Base case: |R| == 1, return R[0], this holds because the distance between the tower and the friend must be the one element in the array.</p>
<p>Inductive hypothesis: Assume the algorithm holds for input R = k.</p>
<p>Inductive&nbsp; step: want to show the algorithm holds for k+1.</p>
<p>The algorithm makes a recursive call of size k/2, so all recursive steps must hold as per the Inductive Hypothesis.</p>
<p>That leaves the first step being made, which has 2 cases after splitting the input:</p>
<p>1. The last element of r_left is within range. This case, recursion is not necessary on the right half (r_right), because the array is sorted, there is no need to recurse on this half, since we know that&nbsp; the largest element of r_left is strictly less than the smallest element of r_right. So, recursing on&nbsp; r_left returns the correct result as per the Inductive hypothesis.</p>
<p>2. The last element of r_left is NOT within range. This implies that the friend must live further away than the last element of r_left, so there is no point in recursing on the left half because the house is not in that range. Recursing on r_right returns the correct result as per the Inductive Hypothesis.</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>Input: int array R shows the distance between friend's house and the tower.</p>
<p>returns: int s, the smallest range required</p>
<p>SmallestRange(int[] R) -&gt; int s</p>
<p>Base case: If |R| == 1, return R[0].</p>
<p>divide: Split r into 2 halves at the midpoint of R; r_left = R[0..r/2] and r_right = R[ r/2...r ]</p>
<p>Conquer: If GetsService( r_left[ last element of r_left ]&nbsp; ) == TRUE, then SmallestRange( r_left )</p>
<p>ELSE, SmallestRange(&nbsp; r_right )</p>",3.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,5.5
Josie Ronk,321622,UW869J538,"611992,592418","COMP SCI 577:DIS317,COMP SCI 577:LEC001","1262:41549,1262:23138",2025-10-17 22:39:06 UTC,00:26:12,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>Let S be the recurrence for SuperMax() and let n be the number of elements in the initial array A.&nbsp;<br>S(n) = 2S(<img class=""equation_image"" title=""\frac{n}{3}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{n}{3}"" data-equation-content=""\frac{n}{3}"" data-ignore-a11y-check="""">) + c<img class=""equation_image"" title=""\frac{n}{3}"" src=""/equation_images/%255Cfrac%257Bn%257D%257B3%257D?scale=1"" alt=""LaTeX: \frac{n}{3}"" data-equation-content=""\frac{n}{3}"" data-ignore-a11y-check="""">, S(1), S(2) = c</p>",3.0,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"<p>let routine(i) be an experiment testing if the routine runs under 1 second on i cores, returning true or false. let avg(a,b) return the average of two indices.</p>
<p>end = n</p>
<p>start = 0</p>
<p>MinCores(start, end) {</p>
<p>if(start+1 = end): return end</p>
<p>test = avg(start,end)</p>
<p>if(routine(test) == false): return MinCores(test, end)</p>
<p>else return MinCores(start,test)</p>
<p>}</p>",3.0,Graded,18156,essay,"<p>M(n) = 2M(n/2), M(2) = c</p>",0.0,Graded,18157,essay,"<p>Using a recurrence tree- constant time for each level, total height of tree = <img class=""equation_image"" title=""\log_2n"" src=""/equation_images/%255Clog_2n?scale=1"" alt=""LaTeX: \log_2n"" data-equation-content=""\log_2n"" data-ignore-a11y-check=""""> so total work = <img class=""equation_image"" title=""c\log_2\left(n\right)\in O\left(\log n\right)"" src=""/equation_images/c%255Clog_2%255Cleft(n%255Cright)%255Cin%2520O%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: c\log_2\left(n\right)\in O\left(\log n\right)"" data-equation-content=""c\log_2\left(n\right)\in O\left(\log n\right)"" data-ignore-a11y-check=""""></p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
Andrew Moses,492461,UW985X126,"611995,592418","COMP SCI 577:DIS319,COMP SCI 577:LEC001","1262:41550,1262:23138",2025-10-17 22:22:47 UTC,00:06:53,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=3T\left(n\right)+T\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253D3T%255Cleft(n%255Cright)%252BT%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=3T\left(n\right)+T\left(1\right)"" data-equation-content=""T\left(n\right)=3T\left(n\right)+T\left(1\right)"" data-ignore-a11y-check=""""></p>",0.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p><img class=""equation_image"" title=""T\left(n\right)=T\left(\lfloor\frac{n}{2}\rfloor\right)+T\left(1\right)"" src=""/equation_images/T%255Cleft(n%255Cright)%253DT%255Cleft(%255Clfloor%255Cfrac%257Bn%257D%257B2%257D%255Crfloor%255Cright)%252BT%255Cleft(1%255Cright)?scale=1"" alt=""LaTeX: T\left(n\right)=T\left(\lfloor\frac{n}{2}\rfloor\right)+T\left(1\right)"" data-equation-content=""T\left(n\right)=T\left(\lfloor\frac{n}{2}\rfloor\right)+T\left(1\right)"" data-ignore-a11y-check=""""></p>",0.0,Graded,18157,essay,"<p><img class=""equation_image"" title=""O\left(n\log n\right)"" src=""/equation_images/O%255Cleft(n%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: O\left(n\log n\right)"" data-equation-content=""O\left(n\log n\right)"" data-ignore-a11y-check=""""></p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>Input Array A, number K</p>
<p>Def find():</p>
<p>If the cardinality of A is 1, return A</p>
<p>Else,</p>
<p>Midpoint m = Length of A // 2</p>
<p>Return bigger(A[0:m], A[m + 1: len(A)]))</p>
<p>&nbsp;</p>
<p>Inputs x, y</p>
<p>Def bigger()</p>
<p>If x &gt; y, return x</p>
<p>If x &lt; y, return y</p>",1.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,1.0
Vedant Mamidwar,514526,UW987S330,"602070,592418","COMP SCI 577:DIS315,COMP SCI 577:LEC001","1262:30198,1262:23138",2025-10-17 22:43:53 UTC,00:28:15,1,18054,essay,"<p><img class=""equation_image"" title=""T(n) = 3n  T(n/2) + O(1)"" src=""/equation_images/T(n)%2520%253D%25203n%2520%2520T(n%252F2)%2520%252B%2520O(1)?scale=1"" alt=""LaTeX: T(n) = 3n  T(n/2) + O(1)"" data-equation-content=""T(n) = 3n  T(n/2) + O(1)"" data-ignore-a11y-check=""""></p>",1.5,Graded,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n) = T(n/2) + O(1)</p>,0.0,Graded,18157,essay,"<p>T(n) = T(n/2) + O (1)</p>
<p>T(n) = T(n/4) + O(1) + O(1)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; = O(n)</p>",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>int k = 0;</p>
<p>isqrt(a) {</p>
<p>&nbsp; if (a == b) return k;</p>
<p>&nbsp; k++;</p>
<p>&nbsp; a = <img class=""equation_image"" title=""\sqrt{a}"" src=""/equation_images/%255Csqrt%257Ba%257D?scale=1"" alt=""LaTeX: \sqrt{a}"" data-equation-content=""\sqrt{a}"" data-ignore-a11y-check=""""></p>
<p>&nbsp; isqrt(<img class=""equation_image"" title=""a"" src=""/equation_images/a?scale=1"" alt=""LaTeX: a"" data-equation-content=""a"" data-ignore-a11y-check="""">)</p>
<p>&nbsp; reurn k;</p>
<p>}</p>",0.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,1.5
Aniketh Kancherla,504672,UW986Z416,"602068,592418","COMP SCI 577:DIS313,COMP SCI 577:LEC001","1262:30196,1262:23138",2025-10-17 22:45:00 UTC,00:28:35,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,<p>3*T(2n/3)+cn</p>,1.5,Graded,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,<p>T(n/2) + c</p>,0.75,Graded,18157,essay,"<p>1=n/2^k =&gt; log2n = k</p>
<p><img class=""equation_image"" title=""\sum_1^{\log_2n}c=c\sum_1^{\log_2n}1=c\left(\log_2n+1\right)>=c\left(\log_2n+\log_2n\right)=2c\log_2n\Rightarrow O\left(\log n\right)"" src=""/equation_images/%255Csum_1%255E%257B%255Clog_2n%257Dc%253Dc%255Csum_1%255E%257B%255Clog_2n%257D1%253Dc%255Cleft(%255Clog_2n%252B1%255Cright)%253E%253Dc%255Cleft(%255Clog_2n%252B%255Clog_2n%255Cright)%253D2c%255Clog_2n%255CRightarrow%2520O%255Cleft(%255Clog%2520n%255Cright)?scale=1"" alt=""LaTeX: \sum_1^{\log_2n}c=c\sum_1^{\log_2n}1=c\left(\log_2n+1\right)>=c\left(\log_2n+\log_2n\right)=2c\log_2n\Rightarrow O\left(\log n\right)"" data-equation-content=""\sum_1^{\log_2n}c=c\sum_1^{\log_2n}1=c\left(\log_2n+1\right)>=c\left(\log_2n+\log_2n\right)=2c\log_2n\Rightarrow O\left(\log n\right)"" data-ignore-a11y-check=""""></p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"<p>input: A[1....n], sum</p>
<p>if |A| = 1: ret value, sum = 0</p>
<p>sum = 0</p>
<p>m = middle index of the array&nbsp;</p>
<p>if(A[m] &gt; A[m + 1]): sum += Algo(A[1...m], sum)</p>
<p>else if(A[m] &lt; A[m+1]): sum += Algo(A[m...n], sum)</p>
<p>else if(A[m] has both sides less than it): sum&nbsp; += Algo(A[m...n], sum)</p>
<p>if(last element&gt;= next value): sum += 1</p>
<p>ret sum</p>",2.5,Graded,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,6.75
Shekhar Shah,514240,UW982B411,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:40:38 UTC,00:20:47,1,18054,essay,"","",Not Attempted,18057,essay,"<p>Two recursive calls where we extract 2/3's of A each time, and then a max function which runs in constant run time. If these cases don't occur we are simply checking length's and calling a max function in case there are two elements in the array.&nbsp;<br>T(n) = 2T(2n/3) + O(1)<br>T(1) = 1</p>",2.5,Graded,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Because we divide the array in half and then recurse on each half, the recurrence relation would be:</p>
<p>T(n) = T(n/2) + O(1)<br>T(1) = 0</p>",1.0,Graded,18157,essay,"<p>The nodes split such that each level after the first would be equal to n/2^k, (i.e n/4, n/8, etc.). We stop when we reach 1, so n/2^k = 1, meaning k = log<sub>2</sub>n<br><br>Since we are only adding some constant C to our divides, the solution is O(log n), which is faster than the original algorithm given.&nbsp;</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>FastAlg<br>input: array A, number k, low index, high index<br>output: smallest value such that the value is in A and greater than or equal to k<br>mid = (low + high)/2</p>
<p>if(low &gt; high)<br>&nbsp; &nbsp; return ""None""</p>
<p>if A[mid] &lt; k<br>&nbsp; &nbsp;if (mid == length(A) or A[mid+1] &gt;= k)<br>&nbsp; &nbsp; &nbsp; &nbsp; return A[mid]<br>&nbsp; &nbsp;else<br>&nbsp; &nbsp; &nbsp; &nbsp;return FastAlg(A, k, mid+1, high)<br>else<br>&nbsp; &nbsp; return FastAlg(A, k, low+1, mid)</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.5
Keshav ADITYA,513761,UW102J484,"604107,592418","COMP SCI 577:DIS316,COMP SCI 577:LEC001","1262:33612,1262:23138",2025-10-17 22:44:27 UTC,00:22:39,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"<p>The recurrence for the reuntime of the algorithm is: T(n) = 3T(N/5) + theta(1) for n &gt;=5, as the function makes 3 recursive calls on the subarrays. each is one fifth of the original arrays size and performs a constant amount of work for the swap operation.l teh base case happens when n&lt;5. in that case the function returns and the runtime is theta(1).</p>",3.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Let T(n) be the runtime of the divide and conquer algorithm. As each step compares once and makes one recursive call on half of the array, the recurrence will be: T(n) = T(n/2) + theta(1)</p>
<p>&nbsp;</p>",0.75,Graded,18157,essay,"<p>we expand T(n) = T(n/2) + c.&nbsp;</p>
<p>This gives us: T(n) = T(n/2) + c = T(n/4) + c + c = T(n/2<sup>k</sup>) +kc</p>
<p>Stopping when subproblem size is 1: n/2<sup>k</sup> = 1. =&gt; k = log<sub>2</sub>n.&nbsp;</p>
<p>Thus, T(n) = T(1) + c log<sub>2</sub>n = theta(1) + theta(log n) = theta(log n).</p>
<p>So, the algorithm runs in theta(log n)&nbsp;</p>
<p>(What is mean by theta in all my answers is this symbol <img class=""equation_image"" title=""\theta"" src=""/equation_images/%255Ctheta?scale=1"" alt=""LaTeX: \theta"" data-equation-content=""\theta"" data-ignore-a11y-check="""">. )</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"<p>A divide and conquer algorithm to find smallest number x in a sorted array A such that x&gt;=k can be used with binary search. The algorithm compares k witht he middle element A[mid]. If A[mid] &gt;=k, it recursively searches the left half of the array. Else it searches the left half. THis continues to happen until the smallest element &gt;= to k is found or no such elemtn exists.</p>",3.0,Graded,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,8.75
Haowen Zheng,381749,UW902S790,"602066,592418","COMP SCI 577:DIS311,COMP SCI 577:LEC001","1262:30194,1262:23138",2025-10-17 22:39:12 UTC,00:11:00,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"",0.0,Graded,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"",0.0,Graded,18157,essay,"",0.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"<p>we begin at range of 1 and call GetsService for this range. If the return value is false, multiply the range by 2 and call again, until we found the range R returning true. Then we collect this range and the range before this which is R'&nbsp; and do the recurrence again. But this time we start at R' + 1 and only double the integer after R'. Repeat until R-R' = 1. This R is what we what.</p>",1.0,Graded,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,1,0,9.0,1.0
Mehmet Tomak,566018,UW107A492,"","","",2025-10-17 19:35:39 UTC,00:19:43,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"<p>T(n) = 2T(n/3) + c</p>
<p>2 recursive calls for each supermax call, size decreases to 1 / 3</p>",1.5,Graded,18069,essay,"","",Not Attempted,18073,essay,"","",Not Attempted,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>Couldn't find a recurssive solution, but it should be faster than O(n). First while loop takes log(x), base 2. Second loop goes back from the first higher value count &gt; x.</p>
<p>Upper bound will most likey be : O(log n)</p>
<p>I assume recursive solution will have 2 in-function calls and divide the size of the input to two. It should be something like T(n) = 2T(n/2) + kc</p>",0.0,Graded,18157,essay,<p>Couldn't find a correct recurrence function.</p>,0.0,Graded,25540,essay,"<p>if (x == 0) return 1</p>
<p>if (x == 1) return e</p>
<p>exp = e ** 2;</p>
<p>count = 2;</p>
<p>&nbsp;</p>
<p>while (count &lt; x) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;count *= count;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;exp *= exp;</p>
<p>}</p>
<p>&nbsp;</p>
<p>while (count != x) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; count -= 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; exp /= e;</p>
<p>}</p>
<p>&nbsp;</p>
<p>return exp;</p>",1.0,Graded,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"","",Not Attempted,25556,essay,"","",Not Attempted,0,0,0,9.0,2.5
Jaspal Khanuja,514120,UW980L879,"","","",2025-10-16 23:24:35 UTC,00:26:17,1,18054,essay,"","",Not Attempted,18057,essay,"","",Not Attempted,18060,essay,"","",Not Attempted,18061,essay,"","",Not Attempted,18065,essay,"","",Not Attempted,18069,essay,"","",Not Attempted,18073,essay,"<p>base case: T(n) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1) for n &lt;5</p>
<p>Identify the call that is recursive</p>
<p>shuffle(1/5 of A) = size n/5</p>
<p>shuffle(4/5 of A) = size of 4n/5</p>
<p>shuffle(3/5 of A) = size of 3n/5</p>
<p>In total 3 recursion calls</p>
<p>Figure out the non recursive work:&nbsp;</p>
<p><img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>Recurrence relation</p>
<p>T(n) = T(n/5) + T(4n/5) + T(3n/5) +<img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>
<p>with base case being: <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)</p>","",Not Graded,18077,essay,"","",Not Attempted,18079,essay,"","",Not Attempted,18082,essay,"","",Not Attempted,18083,essay,"","",Not Attempted,18155,essay,"","",Not Attempted,18156,essay,"<p>&nbsp;</p>
<p>Reference, (lowerbound) is supposed to repersent the fact that when doing an operation you round down instead of up I just dont know the symbol for it on the computer</p>
<p>For even k = 2j: T(2j) &lt;= T(j) +c</p>
<p>For odd k = 2k=1: T(2j+1) &lt;= T(j) +c</p>
<p>combinging both of those ^ gives you: T(k) &lt;= T( (lowerbound) k/2 (lowerbound) ) +c for k &gt;=2</p>
<p>Base cases: T(0) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1), T(1) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(1)&nbsp;</p>
<p>c &gt; 0 is a constant accounting for the O(1) work doen bc isqrt_b(a) and a couple consatnt time checks/multiplies</p>",1.0,Graded,18157,essay,"<p>Refernce (lowerbound) signifies the fact that doing an operation will yeild the answer rounded DOWN i dont now the symbol for int on the coputer</p>
<p>Given Recurresne from B: T(k) = T ((lowerbound) k/2 (lowebound)) + c for k &gt;=2</p>
<p>with base case T(1) = d where c and d and positive constants</p>
<p>Expand the recurrence: T(k) = T(k/2) + c</p>
<p>= T(k/4) + c + c</p>
<p>&nbsp;= T(k/8) + c + c + c</p>
<p>...</p>
<p>= T(k/(2^i)) +ic</p>
<p>stop when argument hits abse case</p>
<ul>
<li>we reach base cahse when k/(2^i) == 1</li>
<li>that gives i = log(base2)(k)</li>
<li>substitude i = log(base2)(k) into eq: T(k) = 1 + c(log(base2)(k))</li>
</ul>
<p>simplify constraints:</p>
<p>T(k) = d + c log(base2)k</p>
<p>since d is constant it can be ignored and final result is:</p>
<p>T(k) = <img class=""equation_image"" title=""\Theta"" src=""/equation_images/%255CTheta?scale=1"" alt=""LaTeX: \Theta"" data-equation-content=""\Theta"" data-ignore-a11y-check="""">(logk)</p>
<p>this is bc each recursive call halves the problem and adds extra work (thats were log comes in)</p>",2.0,Graded,25540,essay,"","",Not Attempted,25541,essay,"","",Not Attempted,25542,essay,"","",Not Attempted,25544,essay,"","",Not Attempted,25550,essay,"","",Not Attempted,25552,essay,"","",Not Attempted,25553,essay,"","",Not Attempted,25555,essay,"<p>Reference: (lowerbound) signifies tje opreation when something is done to a set of opwrations where the result is rounding the value down to teh whole number instead of up i just dont know the symbol on the computer for it&nbsp;</p>
<p>&nbsp;</p>
<p>function FindExp(a, b):</p>
<p>&nbsp; if a == 1: return 0 //b^0</p>
<p>&nbsp; r = issqrt_b(a) //r = b^{ (lower bound) k/2 (lowerbound)}</p>
<p>&nbsp; if r * r == a:&nbsp; //k is even : a = (b^{ k/2 })^2</p>
<p>&nbsp; &nbsp; return 2 * FindExp(r, b) //recurse on b ^ {k/2}</p>
<p>&nbsp; else:</p>
<p>&nbsp; &nbsp;return 2 * FindExp(r,b) +1&nbsp;</p>
<p>&nbsp;</p>
<p>faster bc each cell halves the exp and does constant time work&nbsp;</p>
<p>asymtptically faster than brute force method</p>",3.0,Graded,25556,essay,"","",Not Attempted,0,0,0,9.0,6.0
